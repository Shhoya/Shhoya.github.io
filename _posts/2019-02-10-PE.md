---
layout: article
title: "[Rev]PE Format"
key: 20190210
tags:
  - C
  - Reversing
toc: true
mathjax: true
mathjax_autoNumber: true
published : true
---

# [+] PE Format

<!--more-->

매번 까먹고 다시 찾아보기 귀찮으니 블로그에 올려놓고 보자아ㅏ

## [+] DOS Header

### IMAGE_DOS_Header

32bit 운영체제에서 IMAGE_DOS_Header의 크기는 40byte이다.

```c
typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
```

위의 구조체는 `winnt.h` 파일에 나와있다. 자료형을 계산해보면 딱 40byte 인 것을 알 수 있다.
중요한건 맨 아래 `e_lfanew` 값이다. 설명에 새로운 exe 헤더의 파일 주소라고 나와있다. 이건 `IMAGE_NT_HEADER`의 오프셋을 의미한다.

## [+] NT Header

### IMAGE_NT_HEADERS

3개의 멤버를 가지는 구조체로 되어있다.

```c
typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
```

`Signature` 에는 `PE` 파일을 의미하는 `0x50450000` 이 존재한다. 다음 Fileheader와 Optional Header가 존재한다.

### IMAGE_FILE_HEADER

```c
typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
```

몇가지 중요한 멤버만 설명한다.

#### Machine

CPU 아키텍쳐를 의미한다. x86의 경우 `0x014c`로 세팅되어 있다.

#### NumberOfSections

말 그대로 섹션의 수를 의미한다.

#### SizeOfOptionalHeader

`IMAGE_NT_HEADER`의 마지막 멤버인 `IMAGE_OPTIONAL_HEADER32`의 크기를 의미한다. 해당 멤버의 값을 보고 `PE Loader`는 구조체의 크기를 알 수 있는 것이다.

#### Characteristics

해당 파일의 속성을 의미한다. 실행 가능한 파일인지, 시스템 파일인지 등등에 대한 속성을 의미한다. 실제 간혹 단독으로 DLL파일을 디버깅하려할 때 이 멤버의 값을 수정하여 실행 가능하다. 물론 정상적으로 모두 실행되지는 않지만....



### IMAGE_OPTIONAL_HEADER32

```c
typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;
```

사이즈도 매우 크다. 마찬가지로 중요한 멤버를 확인해본다.

#### Magic

마찬가지로 식별 값이다. x86의 경우 `0x010B`, x64의 경우 `0x020B`의 값을 가진다.

#### AddressOfEntryPoint

엔트리포인트의 RVA 값을 가지고 있다. 프로그램 최초 실행 코드의 시작 주소로 매우 중요하다.

#### ImageBase

PE파일이 로딩되는 시작 주소를 나타낸다. `exe`, `dll`과 같은 pe파일은 유저 메모리 영역의 0 ~ 7FFFFFFF 범위에 로드되고 `sys`파일은 커널 메모리 영역의 80000000~FFFFFFFF 범위에 로드된다. 보통 연습용으로 만드는 대부분의 실행 파일의 ImageBase 값은 0x00400000이고 `dll` 파일의 경우 0x10000000이다. 

**PE Loader는 실행시키기 위해 프로세스를 생성하고 파일을 메모리에 로딩한 후 EIP 레지스터의 값을 ImageBase + AddressOfEntryPoint 값으로 세팅**

#### SectionAlignment, FileAlignment

파일에서 섹션의 최소단위를 나타내는 값이 `FileAlignment` 이고, 메모리에서 섹션의 최소단위를 나타내는 것이 `SectionAlignment` 이다. 

### SizeOfImage

PE파일이 메모리에 로딩되었을 때 가상 메모리에서 PE 이미지가 차지하는 크기를 나타낸다. 파일의 크기가 아님

#### SizeOfHeader

PE헤더의 전체 크기를 의미한다. 이 값은 `FileAlignment`의 배수이다. PE헤더에서 해당 값만큼 떨어진 위치에 첫번째 섹션이 위치하는 것이다.

#### Subsystem

이 값을 보고 시스템 드라이버 파일(.sys)인지 실행파일(.exe, .dll)인지 구분할 수 있다.

#### DataDirectory

`IMAGE_DATA_DIRECTORY`구조체의 배열로 각 배열마다 정의된 값을 가진다. [0] = export, [1] = import ....



### IMAGE_SECTION_HEADER

섹션 헤더는 각 섹션별로 나뉘어져 있다. `.text`, `.data`, `.rsrc` ....

```c
typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
```

여기서도 역시 중요한 5가지 멤버가 있다. `VirtualSize`(메모리 내 해당 섹션의 크기), `VirtualAddress`(메모리에서 섹션의 시작 주소(RVA), `SizeofRawData`(파일 내 해당 섹션의 크기), `PointerToRawData`(파일 내 해당 섹션의 시작위치), `Characteristics`(섹션의 속성) 가 그 멤버이다.

`VirtualAddress`와 `PointToRawData`는 위의 `IMAGE_OPTIONAL_HEADER32`에 있는 `SectionAlignment`와 `FileAlignment`에 의해 결정된다.

`VirtualSize`와 `SizeOfRawData`는 서로 다른 값을 가지는 경우가 대부분이다. 파일에서의 섹션 크기와 메모리 내 섹션크기가 다르다는 이야기다.

`Characteristics` 역시 속성을 의미하는데 실행,쓰기,읽기 등 속성을 나타낸다.





## [+] RVA

실행파일이 메모리에 로드되었을 때 각 섹션의 메모리 주소(RVA)와 파일 오프셋을 매핑해야 한다. 그 방법은 다음과 같다.

`RAW - PointerToRawData = RVA - VirtualAddress`
`RAW = RVA - VirtualAddress + PointerToRawData`

`VA`는 가상 메모리의 절대주소를 의미하고 `RVA`는 상대주소를 의미한다. 즉 `ImageBase`가 그 기준이 된다.
다르게 표현하면 `VA = RVA + ImageBase` 를 의미한다.

위와같은 방식을 RVA to RAW라고도 표현한다. 즉 메모리에 로드되기 전에 파일 오프셋과 메모리에 로드된 후에 주소를 매칭하는 것을 의미한다.

