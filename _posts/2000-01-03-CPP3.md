---
layout: article
title: "[Dev]Programming 3"
key: 19700101
tags:
  - Dev
toc: true
mathjax: true
mathjax_autoNumber: true
published : true
---

# [+] C++ Language

사회에서 개무시 안당하고 살려면 공부를 해야 한다.

## [+] Inheritance

상속 부분을 다시 짚고 넘어간다.

### Concept

최근 많이 느끼지만 왜 사용하느냐 를 이해하면 언어를 좀 더 쉽게 이해할 수 있는 것 같다.
객체지향에서 중요한 것 중 하나는 요구사항에 따라 프로그램이 유연하냐는 것이다.

```c++
#include <iostream>
#pragma warning(disable:4996)
using namespace std;

class Person
{
	int age;
	char name[20];

public:
	int GetAge() const {
		return age;
	}

	const char* GetName() const {
		return name;
	}

	Person(int _age = 1, const char* _name = "noname") {
		age = _age;
		strcpy(name, _name);
	}
};

class Student : public Person
{
	char major[20];

public:
	Student(const char* _major) {
		strcpy(major, _major);
	}

	const char* GetMajor() const {
		return major;
	}

	void ShowData() const {
		cout << "Name : " << GetName() << endl;
		cout << "Age : " << GetAge() << endl;
		cout << "Major : " << GetMajor() << endl;
	}
};

int main()
{
	Student Kim("Computer");
	Kim.ShowData();
	return 0;
}
```

위와 같은 코드가 있다.`Student` 클래스의 선언에 보면 `Student : public Person` 이라는 내용을 볼 수 있다. `Student` 클래스가 자신의 특성은 유지한 채, `public` 상속 한다라는 의미다.

즉, `Student` 클래스는 `Person`클래스를 상속하므로 `Student` 객체는 `Person` 클래스에 선언되어 있는 멤버를 모두 포함하게 된다.

`Student` 클래스의 멤버함수에 `GetName`과 `GetAge`가 없음에도 사용 가능한 것을 보면 이해가 쉽다.

`Person`처럼 상속해주는 클래스를 `Super` 또는 `Base` 클래스라고 한다.

`Student`처럼 상속 받는 클래스는 `Sub` 또는 `Derived` 클래스라고 한다.

### [-] 생성과 소멸 과정

#### 생성

```c++
#include <iostream>
#pragma warning(disable:4996)
using namespace std;

class AAA	// Base Class
{
public:
	AAA() {
		cout << "AAA() Call" << endl;
	}

	AAA(int i) {
		cout << "AAA(int i) Call" << endl;
	}
};

class BBB : public AAA	// Derived Class
{
public:
	BBB() {
		cout << "BBB() Call" << endl;
	}

	BBB(int j) {
		cout << "BBB(int j) Call" << endl;
	}
};

int main()
{
	cout << "Create of Object (1) " << endl;
	BBB bbb1;
	cout << "Create of Object (2) " << endl;
	BBB bbb2(10);

	return 0;
}
```

```
Create of Object (1)
AAA() Call
BBB() Call
Create of Object (2)
AAA() Call
BBB(int j) Call
```

상속 받는 서브 클래스의 객체를 생성하면 베이스 클래스의 디폴트 생성자가 먼저 호출되는 것을 확인할 수 있다. `10`이라는 인자로 생성되는 객체 역시 베이스 클래스의 디폴트 생성자를 먼저 호출한다.

순서는 메모리 공간 할당, 베이스 클래스 생성자 호출, 서브 클래스 생성자 호출 순이 되겠다.
리버싱을 할 때 이 부분을 잘 캐치해야겠다. 메모리 공간을 할당할 때 베이스 클래스를 감안하여 할당된다고 한다.(추후 확인)

서브 클래스가 생성자를 호출할 때 인자에 맞게 베이스 클래스를 호출하려면 아래와 같이 멤버 이니셜라이저 선언을 통해 가능하다.

```c++
	BBB(int j) : AAA(j) {
		cout << "BBB(int j) Call" << endl;
	}
```

```
Create of Object (1)
AAA() Call
BBB() Call
Create of Object (2)
AAA(int i) Call
BBB(int j) Call
```

아주 적절하게 베이스, 서브 클래스의 생성자가 호출된 것을 확인할 수 있다.
위의 `BBB(int j) : AAA(j)` 는 "j를 인자로 받을 수 있는 `AAA` 클래스의 생성자를 호출해라" 의 의미로 해석될 수 있다.

```c++
#include <iostream>
#pragma warning(disable:4996)
using namespace std;

class Person
{
	int age;
	char name[20];

public:
	int GetAge() const {
		return age;
	}

	const char* GetName() const {
		return name;
	}

	Person(int _age = 1, const char* _name = "noname") {
		age = _age;
		strcpy(name, _name);
	}
};

class Student : public Person
{
	char major[20];

public:
	Student(int _age, const char* _name, const char* _major) {
		age = _age;		
		strcpy(name, _name);
		strcpy(major, _major);
	}

	const char* GetMajor() const {
		return major;
	}

	void ShowData() const {
		cout << "Name : " << GetName() << endl;
		cout << "Age : " << GetAge() << endl;
		cout << "Major : " << GetMajor() << endl;
	}
};

int main()
{
	Student Kim(32,"Shin","Computer");
	Kim.ShowData();
	return 0;
}
```

자 `Student` 서브 클래스는 자신의 베이스 클래스 `Person`의 멤버 변수인 `age`, `name` 까지 초기화 하기 위해 인자를 요구하고 있다. 매우 좋은 코드이지만 초기화 과정에서 컴파일이 되지 않는다.

그 이유는 `Person`의 멤버변수는 현재 `Private` 로 존재하기 때문이다. 그렇다면 이상적으로 에러를 유발하지 않고 베이스 클래스의 멤버 변수까지 초기화하려면 어떻게 해야할까...

위의 생성과정에서 배운 멤버 이니셜라이저 선언을 통해 가능하다.

```c++
public:
	Student(int _age, const char* _name, const char* _major) : Person(_age,_name){
		strcpy(major, _major);
	}
```

해석해보자. 생성과정에서 해본 것과 같이.. `_age, _name, _major` 3개의 인자로 생성자를 호출하게 되면 `Person` 클래스에서 `_age, _name`의 인자를 전달받을 수 있는 생성자를 호출하라고 명시되어 있다. 

여기서 위와 같은 형태가 가능한 것 또한 해당 생성자가 `public`으로 선언되어 있기 때문이다.

#### 소멸

continue~~~