---
layout: article
title: "[Dev]Programming 3"
key: 19700101
tags:
  - Dev
toc: true
mathjax: true
mathjax_autoNumber: true
published : true
---

# [+] C++ Inheritance

사회에서 개무시 안당하고 살려면 공부를 해야 한다.

## [+] Inheritance

상속 부분을 다시 짚고 넘어간다.

### [-] Concept

최근 많이 느끼지만 왜 사용하느냐 를 이해하면 언어를 좀 더 쉽게 이해할 수 있는 것 같다.
객체지향에서 중요한 것 중 하나는 요구사항에 따라 프로그램이 유연하냐는 것이다.

```c++
#include <iostream>
#pragma warning(disable:4996)
using namespace std;

class Person
{
	int age;
	char name[20];

public:
	int GetAge() const {
		return age;
	}

	const char* GetName() const {
		return name;
	}

	Person(int _age = 1, const char* _name = "noname") {
		age = _age;
		strcpy(name, _name);
	}
};

class Student : public Person
{
	char major[20];

public:
	Student(const char* _major) {
		strcpy(major, _major);
	}

	const char* GetMajor() const {
		return major;
	}

	void ShowData() const {
		cout << "Name : " << GetName() << endl;
		cout << "Age : " << GetAge() << endl;
		cout << "Major : " << GetMajor() << endl;
	}
};

int main()
{
	Student Kim("Computer");
	Kim.ShowData();
	return 0;
}
```

위와 같은 코드가 있다.`Student` 클래스의 선언에 보면 `Student : public Person` 이라는 내용을 볼 수 있다. `Student` 클래스가 자신의 특성은 유지한 채, `public` 상속 한다라는 의미다.

즉, `Student` 클래스는 `Person`클래스를 상속하므로 `Student` 객체는 `Person` 클래스에 선언되어 있는 멤버를 모두 포함하게 된다.

`Student` 클래스의 멤버함수에 `GetName`과 `GetAge`가 없음에도 사용 가능한 것을 보면 이해가 쉽다.

`Person`처럼 상속해주는 클래스를 `Super` 또는 `Base` 클래스라고 한다.

`Student`처럼 상속 받는 클래스는 `Sub` 또는 `Derived` 클래스라고 한다.

### [-] 생성과 소멸 과정

#### 생성

```c++
#include <iostream>
#pragma warning(disable:4996)
using namespace std;

class AAA	// Base Class
{
public:
	AAA() {
		cout << "AAA() Call" << endl;
	}

	AAA(int i) {
		cout << "AAA(int i) Call" << endl;
	}
};

class BBB : public AAA	// Derived Class
{
public:
	BBB() {
		cout << "BBB() Call" << endl;
	}

	BBB(int j) {
		cout << "BBB(int j) Call" << endl;
	}
};

int main()
{
	cout << "Create of Object (1) " << endl;
	BBB bbb1;
	cout << "Create of Object (2) " << endl;
	BBB bbb2(10);

	return 0;
}
```

```
Create of Object (1)
AAA() Call
BBB() Call
Create of Object (2)
AAA() Call
BBB(int j) Call
```

상속 받는 서브 클래스의 객체를 생성하면 베이스 클래스의 디폴트 생성자가 먼저 호출되는 것을 확인할 수 있다. `10`이라는 인자로 생성되는 객체 역시 베이스 클래스의 디폴트 생성자를 먼저 호출한다.

순서는 메모리 공간 할당, 베이스 클래스 생성자 호출, 서브 클래스 생성자 호출 순이 되겠다.
리버싱을 할 때 이 부분을 잘 캐치해야겠다. 메모리 공간을 할당할 때 베이스 클래스를 감안하여 할당된다고 한다.(추후 확인)

서브 클래스가 생성자를 호출할 때 인자에 맞게 베이스 클래스를 호출하려면 아래와 같이 멤버 이니셜라이저 선언을 통해 가능하다.

```c++
	BBB(int j) : AAA(j) {
		cout << "BBB(int j) Call" << endl;
	}
```

```
Create of Object (1)
AAA() Call
BBB() Call
Create of Object (2)
AAA(int i) Call
BBB(int j) Call
```

아주 적절하게 베이스, 서브 클래스의 생성자가 호출된 것을 확인할 수 있다.
위의 `BBB(int j) : AAA(j)` 는 "j를 인자로 받을 수 있는 `AAA` 클래스의 생성자를 호출해라" 의 의미로 해석될 수 있다.

```c++
#include <iostream>
#pragma warning(disable:4996)
using namespace std;

class Person
{
	int age;
	char name[20];

public:
	int GetAge() const {
		return age;
	}

	const char* GetName() const {
		return name;
	}

	Person(int _age = 1, const char* _name = "noname") {
		age = _age;
		strcpy(name, _name);
	}
};

class Student : public Person
{
	char major[20];

public:
	Student(int _age, const char* _name, const char* _major) {
		age = _age;		
		strcpy(name, _name);
		strcpy(major, _major);
	}

	const char* GetMajor() const {
		return major;
	}

	void ShowData() const {
		cout << "Name : " << GetName() << endl;
		cout << "Age : " << GetAge() << endl;
		cout << "Major : " << GetMajor() << endl;
	}
};

int main()
{
	Student Kim(32,"Shin","Computer");
	Kim.ShowData();
	return 0;
}
```

자 `Student` 서브 클래스는 자신의 베이스 클래스 `Person`의 멤버 변수인 `age`, `name` 까지 초기화 하기 위해 인자를 요구하고 있다. 매우 좋은 코드이지만 초기화 과정에서 컴파일이 되지 않는다.

그 이유는 `Person`의 멤버변수는 현재 `Private` 로 존재하기 때문이다. 그렇다면 이상적으로 에러를 유발하지 않고 베이스 클래스의 멤버 변수까지 초기화하려면 어떻게 해야할까...

위의 생성과정에서 배운 멤버 이니셜라이저 선언을 통해 가능하다.

```c++
public:
	Student(int _age, const char* _name, const char* _major) : Person(_age,_name){
		strcpy(major, _major);
	}
```

해석해보자. 생성과정에서 해본 것과 같이.. `_age, _name, _major` 3개의 인자로 생성자를 호출하게 되면 `Person` 클래스에서 `_age, _name`의 인자를 전달받을 수 있는 생성자를 호출하라고 명시되어 있다. 

여기서 위와 같은 형태가 가능한 것 또한 해당 생성자가 `public`으로 선언되어 있기 때문이다.

#### 소멸

베이스 클래스와 서브 클래스의 생성, 소멸 과정은 마치 스택의 자료구조와 같은 느낌으로 생각이 든다.

먼저 아래와 같은 간단한 예제를 본다.

```c++
#include <iostream>
#pragma warning(disable:4996)
using namespace std;

class AAA
{
public:
	AAA() {
		cout << "AAA() Call" << endl;
	}

	~AAA() {
		cout << "~AAA() Call" << endl;
	}
};

class BBB : public AAA
{
public:
	BBB() {
		cout << "BBB() Call" << endl;
	}

	~BBB() {
		cout << "~BBB() Call" << endl;
	}
};

int main()
{
	BBB bbb;
	return 0;
}
```

```
AAA() Call
BBB() Call
~BBB() Call
~AAA() Call
```

위와 같이 당연한 결과가 출력된다.
당연한 이유는 메모리 상에서 베이스 클래스의 생성자가 할당한 메모리 공간까지 해제를 해야 하기 떄문에 위와 같은 결과가 출력되는 것이다.

### [-] Quiz

다음은 은행 계좌정보를 담을 수 있도록 정의되어 있는 `Account` 클래스이다. 

```c++
#include <iostream>
#pragma warning(disable:4996)
using namespace std;

class Account
{
private:
	char acc_num[10];
	int balance;
	
public:
	Account(const char* num, int bal)
	{
		strcpy(acc_num, num);
		balance = bal;
	}
};
```

`Account` 클래스를 `public` 상속하는 `KBAccount` 클래스를 정의하라.

- `KBAccount` 는 `Account` 클래스가 지니고 있는 멤버 변수 외에 고객별 이체 한도 정보를 담고 있는 멤버 변수 `trans_limit`이 있어야 함

메인 함수는 다음과 같다.

```c++
int main()
{
    KBAccount acc("1111-2222",5000,10000);
    acc.ShowData();
    return 0;
}
```

#### Solution

```c++
#include <iostream>
#pragma warning(disable:4996)
using namespace std;

class Account
{
	char acc_num[10];
	int balance;
	
public:
	Account(const char* num, int bal)
	{
		strcpy(acc_num, num);
		balance = bal;
	}

	char* GetAcc()
	{
		return acc_num;
	}

	int GetBal()
	{
		return balance;
	}

};

class KBAccount : public Account	// public 상속
{
private:
	int trans_limit;

public:
	
	KBAccount(const char* _num, int _bal, int _limit) : Account(_num, _bal)	// 베이스 클래스의 private 변수를 사용하기 위한 멤버 이니셜라이저
	{
		trans_limit = _limit;
	}

	void ShowData()
	{
		cout << "Account : " << GetAcc() << endl;
		cout << "Balance : " << GetBal() << endl;
		cout << "Trans_Limit : " << trans_limit << endl;
	}
};


int main()
{
	KBAccount acc("1111-2222", 5000, 100000);
	acc.ShowData();
	return 0;
}
```



## [+] Protected Member

`public`, `private` 선언 외에 `protected` 선언이 존재했었다. 상속을 배우면서 이 `protected` 멤버까지 정복할 수 있다.

쉽게 이해하면 `protected` 멤버는 `private`과 같은 속성을 가지고 있다. 외부에서 접근이 불가능한 멤버라는 선언이다.

단, 상속 관계라면 접근을 허용한다.

아래 예제를 통해 정확한 이해를 할 수 있다.

```c++
#include <iostream>
#pragma warning(disable:4996)
using namespace std;

class AAA
{
private:
	int a;

protected:
	int b;
};

class BBB : public AAA
{
public:
	void SetData()
	{
		a = 10;	// private 멤버이기 떄문에 Error
		b = 20;	// 상속관계의 protected 멤버이기 때문에 Pass
	}
};

int main()
{
	AAA aaa;
	aaa.a = 10;	// private 멤버이기 때문에 외부에서 접근 불가
	aaa.b = 20;	// protected 멤버이기 때문에 외부에서 접근 불가

	BBB bbb;
	bbb.SetData();
	return 0;
}
```

위에서 설명한 내용대로 에러를 확인할 수 있다.

### [-] Example

위에서 학습한 내용을 토대로 만들어진 간략한 예제이다.

```c++
#include <iostream>
#pragma warning(disable:4996)
using namespace std;

class Person
{
protected:	// 서브 클래스에서 접근 가능, 외부 접근 불가

	int age;
	char name[20];

public:
	
	Person(int _age=1, const char* _name="noname")
	{
		age = _age;
		strcpy(name, _name);
	}

	int GetAge() const
	{
		return age;
	}

	const char* GetName() const
	{
		return name;
	}

};

class Student :public Person
{
private:
	
	char major[20];

public:
	
	Student(int _age, const char* _name, const char* _major) : Person(_age, _name)
	{
		strcpy(major, _major);
	}

	//Student(int _age, const char* _name, const char* _major)
	//{
	//	age = _age;
	//	strcpy(name, _name);
	//	strcpy(major, _major);
	//}

	void ShowData()
	{
		cout << "Name : " << GetName() << endl;
		cout << "Age : " << GetAge() << endl;
		cout << "Major : " << major << endl;
	}
};

int main()
{
	Student Shin(32, "Shh0ya", "Computer");
	Shin.ShowData();
	return 0;
}
```

`Student` 클래스의 생성자를 보면 주석처리한 부분이 있다. 명확하게 `protected` 멤버에 접근하여 해당 값을 수정하고 정상적으로 동작한다. 다만 결합도가 높아진다고 한다. 

#### Coupling

클래스를 디자인할 때 중요한 것이 결합도이다. 결합도는 두 개의 클래스가 서로 얼마나 긴밀하게 연결되어 있는가를 의미한다.

이 결합도는 다른 의미로 보면 의존도와도 같은 의미이다. 프로그램을 유연하게 설계하기 위해 이러한 의존도가 낮을수록 좋다.

### [-] Quize

위의 예제에서`Person`, `Student` 클래스를 만들었다. 그러나 `Person` 클래스의 멤버 변수 `name`과 `Student` 클래스의 `major`는 배열 형태로 선언되어 생성되는 모든 객체는 동일한 형태의 메모리 공간을 할당받게 된다.

`name`과 `major`를 문자열 포인터로 선언하고 생성자 내에서 문자열 길이에 따라 메모리 공간을 동적 할당 하도록 변경하라. 복사 생성자에 대한 내용을 참고하자.

다음과 같은 메인 함수로 정상 실행이 가능해야 한다.

```c++
int main()
{
    Student Shin(32,"Shin","Computer");
    Shin.ShowData();
    Student Shin2 = Shin;
    Shin2.ShowData();
    return 0;
}
```

```
Name : Shin
Age : 32
Major : Computer
Name : Shin
Age : 32
Major : Computer
```

#### Solution

```c++
#include <iostream>
#pragma warning(disable:4996)

using namespace std;

/*
Person Class
*/
class Person
{
protected:
	int age;
	char* name;

public:
	Person();
	Person(int, char*);
	Person(const Person&);
	~Person();
	int GetAge() const;
	const char* GetName() const;
};

Person::Person()
{
	cout << "[+] Person Default Constructor" << endl;
}

Person::Person(int _age, char* _name)
{
	age = _age;
	name = new char[strlen(_name) + 1];	// 동적 할당
	strcpy(name, _name);
}

Person::Person(const Person& p)
{
	age = p.age;
	name = new char[strlen(p.name) + 1];
	strcpy(name, p.name);
}

Person::~Person()
{
	cout << "[+] Person Destructor" << endl;
	delete [] name;
}

int Person::GetAge() const
{
	return age;
}

const char* Person::GetName() const
{
	return name;
}

/*
Student Class
*/
class Student : public Person
{
private:
	char* major;

public:
	Student();
	Student(int, const char*, const char*);
	Student(const Student&);
	~Student();
	const char* GetMajor() const;
	void ShowData() const;
};

Student::Student()
{
	cout << "[+] Student Default Constructor" << endl;
}

Student::Student(int _age, const char* _name, const char* _major)
{
	age = _age;
	name = new char[strlen(_name) + 1];
	major = new char[strlen(_major) + 1];
	strcpy(name, _name);
	strcpy(major, _major);
	
}

Student::Student(const Student& s) : Person(s)	// 복사 생성자 멤버 이니셜라이저
{
	major = new char[strlen(s.major) + 1];
	strcpy(major, s.major);
}

Student::~Student()
{
	cout << "[+] Student Destructor" << endl;
	delete[] major;
}

const char* Student::GetMajor() const
{
	return major;
}

void Student::ShowData() const
{
	cout << "Name : " << name << endl;
	cout << "Age : " << age << endl;
	cout << "Major : " << major << endl;
}


int main()
{
	Student Shin(32, "Shin", "Computer");
	Shin.ShowData();
	Student Shin2 = Shin;
	Shin2.ShowData();
	return 0;
}
```

```
[+] Person Default Constructor
Name : Shin
Age : 32
Major : Computer
[+] Person Default Constructor
Name : Shin
Age : 32
Major : Computer
[+] Student Destructor
[+] Person Destructor
[+] Student Destructor
[+] Person Destructor
```

## [+] Kind of Inheritance

현재 `public` 상속에 대해서만 다루고 있었다. 마찬가지로 `protected`, `private` 상속이 존재한다.

베이스 클래스의 멤버는 서브 클래스로 상속되는 과정에서 접근 권한이 변경된다.

- public 상속
  + public 멤버 권한 : public
  + protected 멤버 권한 : protected
  + private 멤버 권한 : 접근 불가
- protected 상속
  + public 멤버 권한 : protected
  + protected 멤버 권한 : protected
  + private 멤버 권한 : 접근 불가
- private 상속
  - public 멤버 권한 : private
  - protected 멤버 권한 : private
  - private 멤버 권한 : 접근 불가

기존 위와 같은 접근 권한이 존재한다. 상속 형태에 따라 어떻게 변하는지 확인해본다. 여기서 `private`과 접근 불가는 다른 의미다. 객체 내에서 `private` 는 직접 접근이 가능하다. 그러나 접근 불가는 객체 내에서 접근이 불가능한 것을 의미한다.

```c++
#include <iostream>
using namespace std;

class Base
{
public:
	int a;

protected:
	int b;
	
private:
	int c;
};

class Sub : public Base
{
	
};

int main()
{
	Sub object;
	return 0;
}
```

위와 같을 때, 각 변수에 대한 접근 권한은 다음과 같다.

- public 멤버 : public (int a)
- protected 멤버 : protected (int b)
- private 멤버 : 접근 불가 (int c)

이해력을 높이기 위해 다음과 같은 내용으로 기억하면 될 듯 하다.

`" "` 상속은 `" "` 보다 접근 권한의 폭이 넓은 것을 `" "`으로 맞춰준다.

**`protect` 상속을 하면, `public` 멤버는 `protected` 권한으로 변경된다.**

## [+] Conclusion

아주 좋은 예가 있다.

자동차, 열차, 선박, 항공기 클래스를 디자인한다고 가정했을 때 이들의 공통점은 이동 및 운반 수단이라는 점이다.
클래스는 정의하는 목적에 따라 정의되는 형태가 다양한데, 

자동차 정비 시스템을 구현하기 위해 정의한 자동차 클래스는 주차장 관리 시스템을 구현하기 위해 정의한 자동차 클래스와는 완전히 다르다. 

운반의 목적을 두고 한다면 중복되는 기능들이 많을 것이다. 이 때 상속을 도입한다면 쉽고 유연하게 관리가 가능할 것이다.

즉, 공통되는 부분을 베이스 클래스로 추상화하고 이를 상속하면 각각의 특징을 지니는 부분을 서브 클래스로 정의하면 된다.

```c++
#include <iostream>
using namespace std;

/* Vehicle Class */
class Vehicle // Base Class
{
	int passenger;
	int baggage;

public:
	Vehicle();
	Vehicle(int,int);
	~Vehicle();

	void Ride(int);
	void Load(int);
};

Vehicle::Vehicle(int person, int weight)
{
	passenger += person;
	baggage += weight;
}

void Vehicle::Ride(int person)
{
	passenger += person;
}

void Vehicle::Load(int weight)
{
	baggage += weight;
}
/* Vehicle Class */


/* AirPlain Class */
class AirPlain : public Vehicle
{
	int crew_man; // 승무원
	
public:
	AirPlain();
	AirPlain(int, int, int);
	~AirPlain();

	void TakeCrew(int);
};

AirPlain::AirPlain(int person = 0, int weight = 0, int crew = 0) : Vehicle(person,weight)
{
	crew_man = crew;
}

void AirPlain::TakeCrew(int crew)
{
	crew_man += crew;
}
/* AirPlain Class */

/* Train Class */
class Train : public Vehicle
{
	int length;

public:
	Train();
	Train(int, int, int);
	~Train();

	void SetLength(int);
};

Train::Train(int person = 0, int weight = 0, int len = 0) :Vehicle(person, weight)
{
	length = len;
}

void Train::SetLength(int len)
{
	length = len;
}
/* Train Class */
```

위와 같이 상속을 이용하여 공통된 부분을 하나의 베이스 클래스로 디자인하고, 각각의 특수한 기능에 대해 서브 클래스에 작성하여 디자인 가능하다.

### [-] Example

**기능적 성격이 강한 클래스**를 `Control Class`라고 부른다. 이 클래스는 프로그램이 지녀야 할 기능을 제공하는 것이 목적이다. 이러한 `Control Class`를 보면 이 프로그램이 어떤 기능이고 어떻게 진행되는지 알 수 있다.

**데이터 성격이 강한 클래스**를 `Entity Class`라고 부른다. 데이터적인 성향이 강한 클래스로 저장되어야 하는 최소 단위 데이터로 인식되는 것이 보통이다. 

이러한 점을 명심하고 이전에 작성하던 은행 시스템 프로그램의 코드를 작성해 본다.

```c++
#include <iostream>
#pragma warning(disable:4996)

using namespace std;
const int NAME_LEN = 20;

class Account
{
	int id;
	int balance;
	char* name;

public:
	Account() {};
	Account(int, char*, int);
	Account(const Account&);
	~Account();

	int GetId() const;
	int GetBalance() const;
	void AddMoney(int);
	void SubMoney(int);
	const char* GetName() const;
	void ShowData();
};

Account::Account(int _id, char* _name, int _bal)
{
	this->id = _id;
	this->balance = _bal;
	this->name = new char[strlen(_name) + 1];
	strcpy(name, _name);
}

Account::Account(const Account& a)
{
	this->id = a.id;
	this->balance = a.balance;
	this->name = new char(strlen(a.name) + 1);
	strcpy(name, a.name);
}

Account::~Account()
{
	delete[] name;
}

int Account::GetId() const
{
	return id;
}

int Account::GetBalance() const
{
	return balance;
}

void Account::AddMoney(int val)
{
	balance += val;
}

void Account::SubMoney(int val)
{
	balance -= val;
}

const char* Account::GetName() const
{
	return name;
}

void Account::ShowData()
{
	cout << "Account : " << id << endl;
	cout << "Name : " << name << endl;
	cout << "Balance : " << balance << endl;
}

/* AccManager Class, Control Class */
class AccManager
{
	Account* pArray[100];
	int index;

public:
	AccManager() { index = 0; };
	void PrintMenu();
	void MakeAccount();	// 개설
	void Deposit();	// 입금
	void WithDraw();	// 출금
	void Inquire();	// 조회
};

void AccManager::PrintMenu()
{
	cout << "[#] Menu" << endl;
	cout << "    [1] Make Account" << endl;
	cout << "    [2] Deposit" << endl;
	cout << "    [3] WithDraw" << endl;
	cout << "    [4] Inquire" << endl;
	cout << "    [5] Exit" << endl;
}

void AccManager::MakeAccount()
{
	int id,balance;
	char name[NAME_LEN];
	
	cout << "[#] Make Account Menu" << endl;
	cout << "    [-] Account ID : "; cin >> id;
	cout << "    [-] Name : "; cin >> name;
	cout << "    [-] Deposit : "; cin >> balance;

	pArray[index++] = new Account(id, name, balance);
}

void AccManager::Deposit()
{
	int money, id;
	cout << "ID : "; cin >> id;
	cout << "Money : "; cin >> money;

	for (int i = 0; i < index; i++)
	{
		if (pArray[i]->GetId() == id)
		{
			pArray[i]->AddMoney(money);
			cout << "[+] Complete";
			pArray[i]->ShowData();
			return;
		}
	}
	cout << "No Search ID" << endl;
}

void AccManager::WithDraw()
{
	int money, id;
	cout << "ID : "; cin >> id;
	cout << "Money : "; cin >> money;

	for (int i = 0; i < index; i++)
	{
		if (pArray[i]->GetId() == id)
		{
			if(pArray[i]->GetBalance()<money)
			{
				cout << "[!] Not Enough Balance." << endl;
				return;
			}
			pArray[i]->SubMoney(money);
			cout << "[+] Complete";
			pArray[i]->ShowData();
			return;
		}
	}
	cout << "No Search ID" << endl;
}

void AccManager::Inquire()
{
	for (int i = 0; i < index; i++)
	{
		pArray[i]->ShowData();
	}
}

enum{MAKE=1,DEPOSIT,WITHDRAW,INQUIRE,EXIT};

int main(void)
{
	int select;
	AccManager manager;

	while (1)
	{
		manager.PrintMenu();
		cout << "[+] Select : "; cin >> select;

		switch (select)
		{
		case MAKE:
			manager.MakeAccount();
			break;

		case DEPOSIT:
			manager.Deposit();
			break;

		case WITHDRAW:
			manager.WithDraw();
			break;

		case INQUIRE:
			manager.Inquire();
			break;

		case EXIT:
			return 0;

		default:
			cout << "[!] Invalid Select..." << endl;
			break;
		}
	}
	return 0;
}
```



# [+] C++ Inheritance 2

## [+] Problem

상속에도 단점이 존재한다. 장.단점을 잘 알고있어야 그때 그때 잘쓰겠지.. 사실 C++을 공부하는 이유는 다른 것에 있지만 개발도 참 매력적인 분야 같다.

상속은 잘못 사용하면 오히려 클래스 간의 관계가 복잡해진다는 단점이 존재한다. 이러한 과정에서 드디어 내가 궁금하던 다형성(`Polymorphism`)에 대해 배울 수 있다.

## [+] IS-A, HAS-A

상속에는 두 가지의 관계 모델이 존재한다. 바로 `IS A` 와 `HAS A` 모델이다.

간단히 예를 들면, `Student is a Person` 이 되겠다. 학생은 사람이다라는 말은 현실세계와도 잘 맞아 떨어진다. 그러나 그 반대의 경우에는 동떨어진 모델이 형성된다. 사람이 무조건 학생일수는 없으니...

`Thie Police have a Gun` 은 소유에 대한 모델이다. 경찰은 총을 가진다. 로 해석하면 될 것 같다.
이러한 상속을 통해서 `Police` 클래스는 `Gun` 클래스를 사용할 수 있게 된다. 즉 소유를 표현할 때도 상속은 유용하다.

그렇다면 상속을 통해서만 표현하는가에 대한 의문이 들 수 있다. **포함 관계**를 통해서도 이뤄질 수 있다.

```c++
#include <iostream>

using namespace std;

class Gun
{
public:
	void Fire() { cout << "Fire a Gun!" << endl; };
};

class Police
{
	Gun pGun;
public:
	void UseWeapon() { pGun.Fire(); };
};

int main()
{
	Police pol;
	pol.UseWeapon();
	return 0;
}
```

`Police` 클래스를 보면 멤버로 `Gun` 클래스의 객체가 선언되어 있다. 이러한 객체를 클래스 객체 멤버, 객체 멤버라고 표현한다. 

`Police` 객체 내부에 `Gun` 객체가 완전히 포함되었다는 것이다. 그러나 역시 주의할 점이 있다.
**예제처럼 `Police` 클래스 내 객체 멤버(`pGun`)가 되기 위해서는 `void` 생성자가 존재해야 한다. 객체 멤버가 메모리 공간에 할당되는 과정에서 `void` 생성자를 호출하기 떄문이다.**

약간은 다른 예제를 확인해보자.

```c++
#include <iostream>

using namespace std;

class Gun
{
public:
	void Fire() { cout << "Fire a Gun!" << endl; };
};

class Police
{
	Gun *pGun;	// 포인터

public:
	Police()
	{
		pGun = new Gun;
	}
	~Police()
	{
		delete pGun;
	}
	void UseWeapon() { pGun->Fire(); };
};

int main()
{
	Police pol;
	pol.UseWeapon();
	return 0;
}
```

`Police` 객체는 `Gun` 객체를 단순히 참조하고만 있다. 하지만 논리적으로는 위의 예제와 같이 `Gun` 객체를 포함하고 있다.
객체지향에서는 이렇듯 이야기하는 포함관계는 논리적인 관계를 뜻한다.

자 그럼, `IS-A`, `HAS-A`, `HAS-A(포함관계)` 모델을 봤다. 그렇다면 실제로 어떤 걸 사용해야 좋은 방법일까?

일반적으로 후자인 포함관계를 더 많이 사용한다. 그 이유는 두 클래스 간 의존도(결합도)가 높아지기 때문이다.

### [-] Quiz

`Circle` 클래스를 정의해 보자. 원의 중심과 반지름 정보를 지니고 있어야 하며, 해당 정보를 출력하는 기능도 있어야 한다. 단, 원의 중심을 나타내는 `Point` 클래스를 정의하고 `Circle` 클래스가 이를 상속하는 형태로 구현되어야 한다.

상속과 포함관계 두가지로 표현해보자.

메인함수는 다음과 같다.

```c++
int main()
{
    Circle cir(3, 5, 2.2);
    cir.ShowData();
    return 0;
}
```

#### Solution

```c++
#include <iostream>

using namespace std;

/* Inheritance */
class Point
{
protected:
	int x, y;
	
public:
	Point(int, int);
	void ShowXY()const;
};

Point::Point(int _x, int _y)
{
	x = _x;
	y = _y;
}

void Point::ShowXY() const
{
	cout << "X, Y : " << x << " " << y << endl;
}



class Circle : public Point
{
	double rad;
	double pi = 3.1415;
	
public:
	Circle(int, int, double);
	double Area();
	void ShowData();
	
};

Circle::Circle(int _x, int _y, double _rad) : Point(_x, _y)
{
	rad = _rad;
}

double Circle::Area()
{
	return rad * rad * pi;
}

void Circle::ShowData()
{
	ShowXY();
	cout << "Radius : " << rad << endl;
	cout << "Circle Area : " << Area() << endl;
}


int main()
{
	Circle cir(3, 5, 2.2);
	cir.ShowData();

	return 0;
}
```

#### Solution2

```c++
#include <iostream>

using namespace std;

class Point
{
protected:
	int x, y;
	
public:
	Point() {};
	Point(int, int);
	void ShowXY()const;
};

Point::Point(int _x, int _y)
{
	x = _x;
	y = _y;
}

void Point::ShowXY() const
{
	cout << "X, Y : " << x << " " << y << endl;
}


class Circle
{
	double rad;
	double pi = 3.14;
	Point cPoint;

public:
	Circle(int, int, double);
	double Area() const;
	void ShowData() const;
};


Circle::Circle(int _x, int _y, double _rad)
{
	cPoint = Point(_x, _y);
	rad = _rad;
}

double Circle::Area() const
{
	return rad * rad * pi;
}

void Circle::ShowData() const
{
	cPoint.ShowXY();
	cout << "Radius : " << rad << endl;
	cout << "Circle Area : " << Area() << endl;
}

int main()
{
	Circle cir(3, 5, 2.2);
	cir.ShowData();

	return 0;
}
```

