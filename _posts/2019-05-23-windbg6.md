---
layout: article
title: "[Rev]유저모드 디버깅(Dead Lock)"
key: 20190523
tags:
  - Windows
  - Kernel
  - Reversing
toc: true
mathjax: true
mathjax_autoNumber: true
published : true
---

# [+] Debugging Case

<!--more-->

## [+] Dead Lock

정보처리 공부를 할 때 운영체제 쪽에서 나왔었다. 교착상태라고도 하고 한정된 자원에 대해 경쟁으로 인해 발생한다. 해당하는 상황을 해결하기 위해서는 교착상태에 빠진 스레드가 어떤 동기화 객체에 대해 대기하고 있는지 확인하고, 해당 동기화 객체를 소유하고 있는 스레드가 계속해서 점유하고 있는 이유를 알아내야 한다.

### [-] 동기화 객체

멀티 스레드 환경에서 자원 공유에 대한 문제가 발생하기 쉽다. 여러 스레드가 하나의 메모리 공간에 어떠한 작업을 하는 경우 이러한 문제들이 발생한다.

(1) 스레드가 a라는 메모리 공간에 어떠한 작업을 하고 사용하려 하는데, (2) 스레드가 같은 공간에 다른 작업을 하게 되며 발생한다고 보면 된다. 즉 레이스 컨디션을 의미한다. 이 때 이를 해결하기 위해 스레드의 실행 순서를 제어할 수 있는 방법이 동기화라고 한다.

동기화 객체는 이러한 동기화에 사용되는 객체를 의미한다. 독립적인 핸들을 가지며 커널 객체이다. 일정한 시점에 이러한 동기화 객체는 `신호상태`와 `비신호상태` 를 가지게 된다. 특정 스레드가 동기화 객체를 가지고 있으면 해당 동기화 객체의 상태에 따라 계속 실행하거나 블록된다. 

동기화 객체는 `WaitForSingleObject`와 같은 대기 함수와 함께 사용되며 동기화 객체의 상태에 따라 스레드의 실행을 지연하거나 허가하는 함수다.

#### Critical Section(동기화)

동일한 프로세스 내에서 사용 가능하며 다른 스레드에게 방해받지 않아야 하는 작업이 있을 경우 해당 영역을 `Critical Section`으로 지정하여 독점하도록 해주는 기능이다.  API로 사용 가능하며 `InitializeCriticalSection, EnterCriticalSection, LeaveCriticalSection, DeleteCriticalSection` 으로 사용 가능하다. 순서대로 초기화, 보호, 종료, 해제로 볼 수 있다.

#### Mutex(동기화 객체)

뮤텍스는 Mutual Exclusion이란 의미로 동시에 소유할 수 없다는 의미를 가진다. `CreateMutext` 함수를 통해 뮤텍스의 핸들을 반환 받는다. API 원형은 다음과 같다.

```c++
HANDLE CreateMutexA(
  LPSECURITY_ATTRIBUTES lpMutexAttributes,
  BOOL                  bInitialOwner,
  LPCSTR                lpName
);
```

`bInitialOwner` 는 해당 함수를 호출한 스레드가 뮤텍스의 소유 권한을 가질 지에 대한 파라미터다. FALSE를 전달하는 경우 최초 대기함수를 호출하는 함수가 해당 뮤텍스를 소유하게 된다.

```c++
#include <stdio.h>
#include <Windows.h>

int main()
{
	HANDLE hMutex=CreateMutex(NULL,FALSE,NULL);
	WaitForSingleObject(hMutex,INFINITE);
    ...
    ...
    ReleaseMutex(hMutex);
    ...
    ...
    CloseHandle(hMutex);
    return 0;
}
```

뮤텍스를 생성하고 대기함수를 통해 신호상태의 뮤텍스를 소유하고 작업을 진행한다. 해당 뮤텍스를 소유했으므로 비신호 상태로 변경되며 작업이 끝나고 `ReleaseMutext`를 통해 다른 스레드가 사용할 수 있도록 신호상태로 변경해주고 모든 작업이 마무리 되면 `CloseHandle`을 통해 핸들을 닫아준다.

#### Semaphore(동기화 객체)

뮤텍스와 비슷하다. 마찬가지로 공유 자원을 보호하기 위해 사용되는 동기화 객체이지만 뮤텍스와 다른 점은 하나의 공유 자원이 아닌 유한한(1개 이상) 공유 자원을 보호할 수 있다.  `CreateSemaphore`를 통해 생성할 수 있으며 원형은 다음과 같다.

```c++
HANDLE CreateSemaphoreW(
  LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
  LONG                  lInitialCount,
  LONG                  lMaximumCount,
  LPCWSTR               lpName
);
```

첫번째 파라미터는 상속에 대한 속성을 결정한다. 두번째 파라미터는 초기 카운트를 지정한다. 0일 경우 비신호 상태가 된다. 

세번째 파라미터는 최대 값을 지정할 수 있다. 마찬가지로 핸들 값을 반환한다. 나머지는 뮤텍스와 마찬가지로 

좋은 예제는 <a href="https://pastime0.tistory.com/entry/CreateSemaphore">여기</a>에 잘 설명되어 있다.

#### Event(동기화 객체)

이름 처럼 뭔가 발생했음을 알리는 동기화 객체이다. `Critical Section`, `Mutex`, `Semaphore`는 공유 자원을 보호하기 위해 사용되며 `Event`는 스레드의 작업 순서 등을 조정하기 위해 신호를 보내는데 사용 된다.

마찬가지로 대기 상태의 스레드는 이벤트가 신호상태가 될 때까지 대기하는데, 대기 함수가 대기 상태를 풀며 이벤트를 처리하는데 자동 리셋과 수동 리셋으로 나뉘어 진다. 

말 그대로 대기 상태가 종료되면 자동으로 이벤트를 비신호 상태로 변경하는 것과, 스레드가 비신호 상태로 변경할 때 까지 신호를 유지하는 수동적인 상태를 의미한다.

`CreateEvent`로 생성하며 원형은 다음과 같다.

```c++
HANDLE CreateEventW(
  LPSECURITY_ATTRIBUTES lpEventAttributes,
  BOOL                  bManualReset,
  BOOL                  bInitialState,
  LPCWSTR               lpName
);
```

두번째 파라미터는 위에서 말한 처리 방법을 의미하는데 TRUE의 경우 수동 리셋, FALSE의 경우 자동 리셋을 의미한다.
세번째 파라미터가 TRUE로 전달되는 경우 이벤트 생성과 동시에 이벤트를 기다리고 있던 스레드가 바로 사용할 수 있도록 해준다.  마찬가지로 이름을 설정하여 `OpenEvent` 함수로 핸들을 얻어올 수 있다.

특이한 점은 대기함수 없이 임의로 신호상태를 변경할 수 있다. `SetEvent, ResetEvent` 함수를 통해 가능하다. 순서대로 신호 상태 설정, 비신호 상태 설정이다.

## [+] Analysis(Event)

예제를 이용해 먼저 데드락을 발생 시킨다.

해당 프로세스에 어태치하여 모든 스레드의 콜스택을 확인하면 다음과 같이 확인할 수 있다.

```
0:000> ~*k

.  0  Id: 2b48.2014 Suspend: 1 Teb: 002bb000 Unfrozen
 # ChildEBP RetAddr  
00 0019f55c 77394719 ntdll!NtWaitForSingleObject+0xc
01 0019f5d0 77394672 KERNELBASE!WaitForSingleObjectEx+0x99
02 0019f5e4 00403072 KERNELBASE!WaitForSingleObject+0x12
03 0019f5fc 00404d98 ProcessHangApp!CProcessHangAppDlg::OnBtnHung+0x42  
04 0019f610 00404b7a ProcessHangApp!_AfxDispatchCmdMsg+0x4d [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\cmdtarg.cpp @ 78] 
05 0019f648 00405a6f ProcessHangApp!CCmdTarget::OnCmdMsg+0x152 [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\cmdtarg.cpp @ 372] 
06 0019f670 00416901 ProcessHangApp!CDialog::OnCmdMsg+0x1c [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\dlgcore.cpp @ 85] 
07 0019f6c0 00417660 ProcessHangApp!CWnd::OnCommand+0x9a [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\wincore.cpp @ 2801] 
08 0019f790 004190dd ProcessHangApp!CWnd::OnWndMsg+0x44 [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\wincore.cpp @ 2113] 
09 0019f7b4 004138bf ProcessHangApp!CWnd::WindowProc+0x2c [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\wincore.cpp @ 2099] 
0a 0019f828 00414076 ProcessHangApp!AfxCallWndProc+0xc5 [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\wincore.cpp @ 268] 
0b 0019f848 768abf1b ProcessHangApp!AfxWndProc+0x34 [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\wincore.cpp @ 417] 
0c 0019f874 768a83ea USER32!_InternalCallWinProc+0x2b
0d 0019f95c 7688beca USER32!UserCallWinProcCheckWow+0x3aa
0e 0019f9c8 7688bc57 USER32!SendMessageWorker+0x20a
0f 0019fa0c 768c6f06 USER32!SendMessageW+0x137
10 0019fa30 768c6c03 USER32!xxxButtonNotifyParent+0x54
11 0019fa58 768c610e USER32!xxxBNReleaseCapture+0x141
12 0019fafc 768c55c2 USER32!ButtonWndProcWorker+0xaae
13 0019fb28 768abf1b USER32!ButtonWndProcA+0x52
14 0019fb54 768a83ea USER32!_InternalCallWinProc+0x2b
15 0019fc3c 768a7c9e USER32!UserCallWinProcCheckWow+0x3aa
16 0019fcb8 7688a2c3 USER32!DispatchMessageWorker+0x20e
17 0019fce8 768863ae USER32!IsDialogMessageW+0x103
18 0019fd14 0041b851 USER32!IsDialogMessageA+0x4e
19 0019fd28 00418036 ProcessHangApp!CWnd::IsDialogMessageA+0x3b [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\winocc.cpp @ 194] 
1a 0019fd34 00405e12 ProcessHangApp!CWnd::PreTranslateInput+0x2b [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\wincore.cpp @ 4606] 
1b 0019fd48 00418fc1 ProcessHangApp!CDialog::PreTranslateMessage+0xa0 [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\dlgcore.cpp @ 80] 
1c 0019fd60 0040668f ProcessHangApp!CWnd::WalkPreTranslateTree+0x2d [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\wincore.cpp @ 3379] 
1d 0019fd7c 00406d54 ProcessHangApp!AfxInternalPreTranslateMessage+0x3f [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\thrdcore.cpp @ 233] 
1e 0019fd88 00406789 ProcessHangApp!CWinThread::PreTranslateMessage+0xb [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\thrdcore.cpp @ 777] 
1f 0019fd9c 0040671d ProcessHangApp!AfxPreTranslateMessage+0x24 [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\thrdcore.cpp @ 252] 
20 0019fdac 004067e6 ProcessHangApp!AfxInternalPumpMessage+0x2b [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\thrdcore.cpp @ 178] 
21 0019fdb8 0041870f ProcessHangApp!AfxPumpMessage+0x1e [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\thrdcore.cpp @ 190] 
22 0019fddc 00405687 ProcessHangApp!CWnd::RunModalLoop+0xc9 [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\wincore.cpp @ 4661] 
23 0019fdf0 004057ca ProcessHangApp!CWnd::CreateRunDlgIndirect+0x3d [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\dlgcore.cpp @ 474] 
24 0019fe48 004026a8 ProcessHangApp!CDialog::DoModal+0x123 [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\dlgcore.cpp @ 633] 
25 0019ff1c 0062f5ff ProcessHangApp!CProcessHangAppApp::InitInstance+0x68 
26 0019ff34 005da275 ProcessHangApp!AfxWinMain+0x5d [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\winmain.cpp @ 37] 
27 (Inline) -------- ProcessHangApp!invoke_main+0x1a [f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl @ 102] 
28 0019ff80 74358494 ProcessHangApp!__scrt_common_main_seh+0xf6 [f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl @ 283] 
29 0019ff94 775f41c8 KERNEL32!BaseThreadInitThunk+0x24
2a 0019ffdc 775f4198 ntdll!__RtlUserThreadStart+0x2f
2b 0019ffec 00000000 ntdll!_RtlUserThreadStart+0x1b
```

대기함수인 `WaitForSingleObject` 함수 호출 후 대기 상태에 빠져있다. 호출 당시의 파라미터를 확인하여 핸들을 찾는다.

```
0:000> kvL
 # ChildEBP RetAddr  Args to Child              
00 0019f55c 77394719 0000035c 00000000 00000000 ntdll!NtWaitForSingleObject+0xc (FPO: [3,0,0])
01 0019f5d0 77394672 0000035c ffffffff 00000000 KERNELBASE!WaitForSingleObjectEx+0x99 (FPO: [SEH])
02 0019f5e4 00403072 0000035c ffffffff 0019fe54 KERNELBASE!WaitForSingleObject+0x12 (FPO: [Non-Fpo])
03 0019f5fc 00404d98 00000000 0064f508 00000111 ProcessHangApp!CProcessHangAppDlg::OnBtnHung+0x42 (FPO: [Non-Fpo]) (CONV: thiscall)
04 0019f610 00404b7a 0019fe54 000003e8 00000000 ProcessHangApp!_AfxDispatchCmdMsg+0x4d (FPO: [Non-Fpo]) (CONV: stdcall)
05 0019f648 00405a6f 000003e8 00000000 00000000 ProcessHangApp!CCmdTarget::OnCmdMsg+0x152 (FPO: [Non-Fpo]) (CONV: thiscall)
06 0019f670 00416901 000003e8 00000000 00000000 ProcessHangApp!CDialog::OnCmdMsg+0x1c (FPO: [Non-Fpo]) (CONV: thiscall)
07 0019f6c0 00417660 000003e8 001e0e4c fdfaeff6 ProcessHangApp!CWnd::OnCommand+0x9a (FPO: [Non-Fpo]) (CONV: thiscall)
08 0019f790 004190dd 00000111 000003e8 001e0e4c ProcessHangApp!CWnd::OnWndMsg+0x44 (FPO: [Non-Fpo]) (CONV: thiscall)
09 0019f7b4 004138bf 00000111 000003e8 001e0e4c ProcessHangApp!CWnd::WindowProc+0x2c (FPO: [Non-Fpo]) (CONV: thiscall)
0a 0019f828 00414076 0019fe54 003e0c3a 00000111 ProcessHangApp!AfxCallWndProc+0xc5 (FPO: [Non-Fpo]) (CONV: stdcall)
0b 0019f848 768abf1b 003e0c3a 00000111 000003e8 ProcessHangApp!AfxWndProc+0x34 (FPO: [Non-Fpo]) (CONV: stdcall)
0c 0019f874 768a83ea 00414042 003e0c3a 00000111 USER32!_InternalCallWinProc+0x2b
0d 0019f95c 7688beca 00414042 00000000 00000111 USER32!UserCallWinProcCheckWow+0x3aa (FPO: [SEH])
0e 0019f9c8 7688bc57 0106f970 00000000 001e0e4c USER32!SendMessageWorker+0x20a (FPO: [Non-Fpo])
0f 0019fa0c 768c6f06 003e0c3a 00000111 000003e8 USER32!SendMessageW+0x137 (FPO: [Non-Fpo])
10 0019fa30 768c6c03 0115b400 00000000 00000000 USER32!xxxButtonNotifyParent+0x54 (FPO: [Non-Fpo])
11 0019fa58 768c610e 008ab690 00000000 0115b400 USER32!xxxBNReleaseCapture+0x141 (FPO: [Non-Fpo])
12 0019fafc 768c55c2 0115b400 00000000 00000202 USER32!ButtonWndProcWorker+0xaae (FPO: [6,33,4])
13 0019fb28 768abf1b 001e0e4c 00000202 00000000 USER32!ButtonWndProcA+0x52 (FPO: [Non-Fpo])
14 0019fb54 768a83ea 768c5570 001e0e4c 00000202 USER32!_InternalCallWinProc+0x2b
15 0019fc3c 768a7c9e e4f2a6c0 00007ffa 00000202 USER32!UserCallWinProcCheckWow+0x3aa (FPO: [SEH])
16 0019fcb8 7688a2c3 00000000 0086bd50 0086bd48 USER32!DispatchMessageWorker+0x20e (FPO: [Non-Fpo])
17 0019fce8 768863ae 003e0c3a 0086bd48 0019fe54 USER32!IsDialogMessageW+0x103 (FPO: [Non-Fpo])
18 0019fd14 0041b851 003e0c3a 0086bd48 0086bd48 USER32!IsDialogMessageA+0x4e (FPO: [Non-Fpo])
19 0019fd28 00418036 0086bd48 0019fd48 00405e12 ProcessHangApp!CWnd::IsDialogMessageA+0x3b (FPO: [Non-Fpo]) (CONV: thiscall)
1a 0019fd34 00405e12 0086bd48 003e0c3a 00405d72 ProcessHangApp!CWnd::PreTranslateInput+0x2b (FPO: [Non-Fpo]) (CONV: thiscall)
1b 0019fd48 00418fc1 0086bd48 0019fe54 0086bd48 ProcessHangApp!CDialog::PreTranslateMessage+0xa0 (FPO: [Non-Fpo]) (CONV: thiscall)
1c 0019fd60 0040668f 003e0c3a 0086bd48 006d4bf8 ProcessHangApp!CWnd::WalkPreTranslateTree+0x2d (FPO: [Non-Fpo]) (CONV: stdcall)
1d 0019fd7c 00406d54 0086bd48 0019fd9c 00406789 ProcessHangApp!AfxInternalPreTranslateMessage+0x3f (FPO: [Non-Fpo]) (CONV: cdecl)
1e 0019fd88 00406789 0086bd48 0086bd48 0086bd18 ProcessHangApp!CWinThread::PreTranslateMessage+0xb (FPO: [Non-Fpo]) (CONV: thiscall)
1f 0019fd9c 0040671d 0086bd48 006d4bf8 00406e93 ProcessHangApp!AfxPreTranslateMessage+0x24 (FPO: [Non-Fpo]) (CONV: cdecl)
20 0019fdac 004067e6 00000001 0019fe54 0041870f ProcessHangApp!AfxInternalPumpMessage+0x2b (FPO: [0,0,0]) (CONV: stdcall)
21 0019fdb8 0041870f 00000001 0019fe54 00000000 ProcessHangApp!AfxPumpMessage+0x1e (FPO: [0,0,0]) (CONV: stdcall)
22 0019fddc 00405687 00000004 0019fe54 00000000 ProcessHangApp!CWnd::RunModalLoop+0xc9 (FPO: [Non-Fpo]) (CONV: thiscall)
23 0019fdf0 004057ca 006dd0b0 00000000 00400000 ProcessHangApp!CWnd::CreateRunDlgIndirect+0x3d (FPO: [Non-Fpo]) (CONV: thiscall)
24 0019fe48 004026a8 fdfae77a 0064f150 00000001 ProcessHangApp!CDialog::DoModal+0x123 (FPO: [Non-Fpo]) (CONV: thiscall)
25 0019ff1c 0062f5ff 00000000 006db7c0 002b8000 ProcessHangApp!CProcessHangAppApp::InitInstance+0x68 (FPO: [Non-Fpo]) (CONV: thiscall)
26 0019ff34 005da275 00400000 00000000 00864394 ProcessHangApp!AfxWinMain+0x5d (FPO: [Non-Fpo]) (CONV: stdcall)
27 (Inline) -------- -------- -------- -------- ProcessHangApp!invoke_main+0x1a (Inline Function @ 005da275) (CONV: cdecl)
28 0019ff80 74358494 002b8000 74358470 585cfd56 ProcessHangApp!__scrt_common_main_seh+0xf6 (FPO: [Non-Fpo]) (CONV: cdecl)
29 0019ff94 775f41c8 002b8000 61526f70 00000000 KERNEL32!BaseThreadInitThunk+0x24 (FPO: [Non-Fpo])
2a 0019ffdc 775f4198 ffffffff 7760f327 00000000 ntdll!__RtlUserThreadStart+0x2f (FPO: [SEH])
2b 0019ffec 00000000 005da32a 002b8000 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])
```

확인하면 0x35C 핸들을 기다리는 것으로 확인된다. `!handle` 명령으로 해당 핸들을 확인한다.

```
0:000> !handle 35c f
Handle 35c
  Type         	Event
  Attributes   	0
  GrantedAccess	0x1f0003:
         Delete,ReadControl,WriteDac,WriteOwner,Synch
         QueryState,ModifyState
  HandleCount  	3
  PointerCount 	98306
  Name         	\Sessions\1\BaseNamedObjects\Win32UserDebug
  Object Specific Information
    Event Type Auto Reset
    Event is Waiting
```

이벤트 타입이며 `Win32UserDebug` 라는 이름을 가진 이벤트 동기화 객체인 것을 확인할 수 있다.

해당 소스코드는 다음과 같다.

```c++
void CProcessHangAppDlg::OnBtnHung() 
{
	// NAMED EVENT 생성(얻기)
	HANDLE hNmdEvent = CreateEvent(NULL,	// security attribute
			FALSE,	// manual reset
			TRUE,	// signaled
			_T("Win32UserDebug"));

	// 실패
	if (hNmdEvent == NULL)
	{
		// failed to create or open named event
		ASSERT(hNmdEvent);
		MessageBox(_T("CreateEvent failed!"));
		return;
	}

	// wait
	if (WAIT_OBJECT_0 == WaitForSingleObject(hNmdEvent, INFINITE))
	{
		// 메시지 박스의 확인을 눌러야 이벤트를 signaled 상태로 바꾼다.
		MessageBox(_T("i'm handling NamedEvent now!"));

		// make event to signal
		SetEvent(hNmdEvent);
	}

	CloseHandle(hNmdEvent);
}
```

`!handle` 명령을 통해 핸드르이 정보를 살펴 봤지만 이벤트의 경우 소유하고 있는 프로세스나 스레드가 무엇인지 확인할 수 없다. 이 때는 Process Hacker, Process Explorer 같은 툴로 해당 핸들을 소유하고 있는 프로세스를 찾아 종료하면 된다. 

## [+] Analysis(Critical Section)

크리티컬 섹션의 경우 섹션 내 `OwningThread` 정보를 사용하여 소유하고 있는 스레드의 정보를 쉽게 확인할 수 있다.
예제 파일의 경우 새로운 스레드에서 `Enter~Section`과 `Leave~Section`을 반복하며 동작한다. 이 때 메인 스레드에서 `Enter~Section`을 호출하게 되면 대기 상태에 빠지게 된다.

마찬가지로 새로 생성된 스레드의 콜 스택을 확인하면 다음과 같은 것을 확인할 수 있다.

```
0:004> kvL
 # ChildEBP RetAddr  Args to Child              
00 04e5fe98 775b336b 006d4ddc 00000000 00000000 ntdll!NtWaitForAlertByThreadId+0xc (FPO: [2,0,0])
01 04e5feb8 775f0550 00000000 00000000 ffffffff ntdll!RtlpWaitOnAddressWithTimeout+0x33 (FPO: [Non-Fpo])
02 04e5fefc 775b3299 00000004 00000000 00000000 ntdll!RtlpWaitOnAddress+0xa5 (FPO: [Non-Fpo])
03 04e5ff38 775cec86 00403d70 00403d70 0019fdfc ntdll!RtlpWaitOnCriticalSection+0xaf (FPO: [Non-Fpo])
04 04e5ff60 775ceba9 04e5ff80 00403e18 006d4dd8 ntdll!RtlpEnterCriticalSectionContended+0xd6 (FPO: [Non-Fpo])
05 04e5ff68 00403e18 006d4dd8 00000000 0019fdfc ntdll!RtlEnterCriticalSection+0x49 (FPO: [1,0,0])
06 04e5ff80 74358494 0019fdfc 74358470 48857908 ThreadHangApp!ThreadProc+0xa8 (FPO: [Non-Fpo]) (CONV: stdcall)
07 04e5ff94 775f41c8 0019fdfc 049633a4 00000000 KERNEL32!BaseThreadInitThunk+0x24 (FPO: [Non-Fpo])
08 04e5ffdc 775f4198 ffffffff 7760f324 00000000 ntdll!__RtlUserThreadStart+0x2f (FPO: [SEH])
09 04e5ffec 00000000 00403d70 0019fdfc 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo])
```

`ntdll!RtlEnterCriticalSection` 내 사용 된 첫번째 파라미터를 보면 크리티컬 섹션의 포인터 이므로 해당 섹션의 정보를 확인할 수 있다.

`dt` 명령을 이용해 해당 섹션의 정보를 확인하면 소유하고 있는 스레드를 확인할 수 있다.

```
0:004> dt _RTL_CRITICAL_SECTION 006d4dd8
ThreadHangApp!_RTL_CRITICAL_SECTION
   +0x000 DebugInfo        : 0x008e6760 _RTL_CRITICAL_SECTION_DEBUG
   +0x004 LockCount        : 0n-6
   +0x008 RecursionCount   : 0n1
   +0x00c OwningThread     : 0x00002660 Void
   +0x010 LockSemaphore    : 0xffffffff Void
   +0x014 SpinCount        : 0x20007d0
```

또 좋은 명령어로 `locks` 명령이 있는데 크리티컬 섹션의 정보를 출력하고 소유하고 있는 스레드와 대기하고 있는 스레드의 목록을 확인할 수 있다.

```
0:004> !locks

CritSec ThreadHangApp!g_CriticalSection+0 at 006d4dd8
WaiterWoken        No
LockCount          1
RecursionCount     1
OwningThread       2660
EntryCount         0
ContentionCount    1
*** Locked

Scanned 13 critical sections
```



## [+] 사용 명령어

### [-] k 

: 콜 스택 출력

```
k, kb, kc, kd, kp, kP, kv (Display Stack Backtrace)
The k* commands display the stack frame of the given thread, together with related information..

User-Mode, x86 Processor

[~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] [FrameCount]
[~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] = BasePtr [FrameCount]
[~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] = BasePtr StackPtr InstructionPtr
[~Thread] kd [WordCount]

Kernel-Mode, x86 Processor

[Processor] k[b|p|P|v] [c] [n] [f] [L] [M] [FrameCount]
[Processor] k[b|p|P|v] [c] [n] [f] [L] [M] = StackPtr FrameCount
[Processor] k[b|p|P|v] [c] [n] [f] [L] [M] = BasePtr StackPtr InstructionPtr
[Processor] kd [WordCount]

User-Mode, x64 Processor

[~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] [FrameCount]
[~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] = StackPtr FrameCount
[~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] = StackPtr InstructionPtr FrameCount
[~Thread] kd [WordCount]

Kernel-Mode, x64 Processor

[Processor] k[b|p|P|v] [c] [n] [f] [L] [M] [FrameCount]
[Processor] k[b|p|P|v] [c] [n] [f] [L] [M] = StackPtr FrameCount
[Processor] k[b|p|P|v] [c] [n] [f] [L] [M] = StackPtr InstructionPtr FrameCount
[Processor] kd [WordCount]

User-Mode, ARM Processor

[~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] [FrameCount]
[~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] = StackPtr FrameCount
[~Thread] k[b|p|P|v] [c] [n] [f] [L] [M] = StackPtr InstructionPtr FrameCount
[~Thread] kd [WordCount]

Kernel-Mode, ARM Processor

[Processor] k[b|p|P|v] [c] [n] [f] [L] [M] [FrameCount]
[Processor] k[b|p|P|v] [c] [n] [f] [L] [M] = StackPtr FrameCount
[Processor] k[b|p|P|v] [c] [n] [f] [L] [M] = StackPtr InstructionPtr FrameCount
[Processor] kd [WordCount]

Parameters

Thread 
Specifies the thread whose stack is to be displayed. If you omit this parameter, the stack of the current thread is displayed. For more information about thread syntax, see Thread Syntax. You can specify threads only in user mode.

Processor 
Specifies the processor whose stack is to be displayed. For more information about processor syntax, see Multiprocessor Syntax.

b 
Displays the first three parameters that are passed to each function in the stack trace.

c 
Displays a clean stack trace. Each display line includes only the module name and the function name.

p 
Displays all of the parameters for each function that is called in the stack trace. The parameter list includes each parameter's data type, name, and value. The p option is case sensitive. This parameter requires full symbol information.

P 
Displays all of the parameters for each function that is called in the stack trace, like the p parameter. However, for P, the function parameters are printed on a second line of the display, instead of on the same line as the rest of the data.

v 
Displays frame pointer omission (FPO) information. On x86-based processors, the display also includes calling convention information.

n 
Displays frame numbers.

f 
Displays the distance between adjacent frames. This distance is the number of bytes that separate the frames on the actual stack.

L 
Hides source lines in the display. L is case sensitive.

M 
Displays output using Debugger Markup Language. Each frame number in the display is a link that you can click to set the local context and display local variables. For information about the local context, see .frame.

FrameCount 
Specifies the number of stack frames to display. You should specify this number in hexadecimal format, unless you have changed the radix by using the n (Set Number Base) command. The default value is 20 (0x14), unless you have changed the default value by using the .kframes (Set Stack Length) command.

BasePtr 
Specifies the base pointer for the stack trace. The BasePtr parameter is available only if there is an equal sign (=) after the command.

StackPtr 
Specifies the stack pointer for the stack trace. If you omit StackPtr and InstructionPtr, the command uses the stack pointer that the rsp (or esp) register specifies and the instruction pointer that the rip (or eip) register specifies.

InstructionPtr 
Specifies the instruction pointer for the stack trace. If you omit StackPtr and InstructionPtr, the command uses the stack pointer that the rsp (or esp) register specifies and the instruction pointer that the rip (or eip) register specifies.

WordCount 
Specifies the number of DWORD_PTR values in the stack to dump. The default value is 20 (0x14), unless you changed the default value by using the .kframes (Set Stack Length) command.

Environment
Modes 
 User mode, kernel mode
 
Targets 
 Live, crash dump
 
Platforms 
 All 

Additional Information
For more information about the register context and other context settings, see Changing Contexts.

Remarks
When you issue the k, kb, kp, kP, or kv command, a stack trace is displayed in a tabular format. If line loading is enabled, source modules and line numbers are also displayed.

The stack trace includes the base pointer for the stack frame, the return address, and function names.

If you use the kp or kP command, the full parameters for each function that is called in the stack trace are displayed. The parameter list includes each parameter's data type, name, and value. 

This command might be slow. For example, when MyFunction1 calls MyFunction2, the debugger must have full symbol information for MyFunction1 to display the parameters that are passed in this call. This command does not fully display internal Microsoft Windows routines that are not exposed in public symbols. 

If you use the kb or kv command, the first three parameters that are passed to each function are displayed. If you use the kv command, FPO data is also displayed.

On an x86-based processor, the kv command also displays calling convention information.

When you use the kv command, the FPO information is added at the end of the line in the following format.

FPO text Meaning 
FPO: [non-Fpo] No FPO data for the frame.
FPO: [N1,N2,N3] N1 is the total number of parameters. 
N2 is the number of DWORD values for the local variables. 
N3 is the number of registers that are saved.
FPO: [N1,N2] TrapFrame @ Address N1 is the total number of parameters. 
N2 is the number of DWORD values for the locals. 
Address is the address of the trap frame.
FPO: TaskGate Segment:0 Segment is the segment selector for the task gate.
FPO: [EBP 0xBase] Base is the base pointer for the frame.
 
The kd command displays the raw stack data. Each DWORD value is displayed on a separate line. Symbol information is displayed for those lines together with associated symbols. This format creates a more detailed list than the other k* commands. The kd command is equivalent to a dds (Display Memory) command that uses the stack address as its parameter.

If you use the k command at the beginning of a function (before the function prolog has been executed), you receive incorrect results. The debugger uses the frame register to compute the current backtrace, and this register is not set correctly for a function until its prolog has been executed.

In user mode, the stack trace is based on the stack of the current thread. For more information about threads, see Controlling Processes and Threads.

In kernel mode, the stack trace is based on the current register context. You can set the register context to match a specific thread, context record, or trap frame. 

Additional Information
For more information about the register context and other context settings, see Changing Contexts.

```

### [-] ~ 

: 스레드 정보 확인

```
Thread Syntax
Many debugger commands have thread identifiers as their parameters. A tilde ( ~ ) appears before the thread identifier. 

The thread identifier can be one of the following values.

Thread identifier Description 
~.
 The current thread.
 
~#
 The thread that caused the current exception or debug event.
 
~*
 All threads in the process.
 
~Number
 The thread whose index is Number. 
 
~~[TID]
 The thread whose thread ID is TID. (The brackets are required And you cannot add a space between the second tilde and the opening bracket.)
 
~[Expression]
 The thread whose thread ID is the integer to which the numerical Expression resolves.
 

 

Threads are assigned indexes as they are created. Note that this number differs from the thread ID that the Microsoft Windows operating system uses.

When debugging begins, the current thread is the one that caused the present exception or debug event (or the active thread when the debugger attached to the process). That thread remains the current thread until you specify a new one by using a ~s (Set Current Thread) command or by using the Processes and Threads window in WinDbg.

Thread identifiers typically appear as command prefixes. Note that not all wildcard characters are available in all commands that use thread identifiers. 

An example of the ~[Expression] syntax would be ~[@$t0]. In this example, the thread changes depending on the value of a user-defined pseudo-register. This syntax allows debugger scripts to programmatically select a thread.

Controlling Threads in Kernel Mode
In kernel mode, you cannot control threads by using thread identifiers. For more information about how to access thread-specific information in kernel mode, see Changing Contexts.

Note  You can use the tilde character ( ~ ) to specify threads during user-mode debugging. In kernel-mode debugging, you can use the tilde to specify processors. For more information about how to specify processors, see Multiprocessor Syntax.
```

### [-] !handle

: 핸들 정보

```
!handle
The !handle extension displays information about a handle or handles that one or all processes in the target system own.

User-Mode 

!handle [Handle [UMFlags [TypeName]]] 
!handle -?
Kernel-Mode 

    !handle [Handle [KMFlags [Process [TypeName]]]] 

Parameters

Handle 
Specifies the index of the handle to display. If Handle is -1 or if you omit this parameter, the debugger displays data for all handles that are associated with the current process. If Handle is 0, the debugger displays data for all handles.

UMFlags 
(User mode only) Specifies what the display should contain. This parameter can be a sum of any of the following bit values. (The default value is 0x1.)


Bit 0 (0x1) 
Displays handle type information.

Bit 1 (0x2) 
Displays basic handle information.

Bit 2 (0x4) 
Displays handle name information.

Bit 3 (0x8) 
Displays object-specific handle information, when available.

KMFlags 
(Kernel mode only) Specifies what the display should contain. This parameter can be a sum of any of the following bit values. (The default value is 0x3.)


Bit 0 (0x1) 
Displays basic handle information.

Bit 1 (0x2) 
Displays information about objects.

Bit 2 (0x4) 
Displays free handle entries. If you do not set this bit and you omit Handle or set it to zero, the list of handles that are displayed does not include free handles. If Handle specifies a single free handle, it is displayed even if you do not set this bit. 

Bit 4 (0x10) 
(Windows XP and later) Displays the handle from the kernel handle table instead of the current process.

Bit 5 (0x20) 
(Windows XP and later) Interprets the handle as a thread ID or process ID and displays information about the corresponding kernel object.

Process 
(Kernel mode only) Specifies a process. You can use the process ID or the hexadecimal address of the process object. This parameter must refer to a currently running process on the target system. If this parameter is -1 or if you omit it, the current process is used. If this parameter is 0, handle information from all processes is displayed.

TypeName 
Specifies the type of handle that you want to examine. Only handles that match this type are displayed. TypeName is case sensitive. Valid types include Event, Section, File, Port, Directory, SymbolicLink, Mutant, WindowStation, Semaphore, Key, Token, Process, Thread, Desktop, IoCompletion, Timer, Job, and WaitablePort.

-? 
(User mode only) Displays some Help text for this extension in the Debugger Command window.

DLL
Windows 2000 
 
Kdextx86.dll 
Uext.dll 
Ntsdexts.dll 
 
Windows XP and later 
 
Kdexts.dll 
Uext.dll 
Ntsdexts.dll 
 

 

Additional Information
For more information about handles, see the !htrace extension, the Microsoft Windows SDK documentation and Microsoft Windows Internals by Mark Russinovich and David Solomon. (These resources may not be available in some languages and countries.) 

Remarks
You can use the !handle extension during user-mode and kernel-mode live debugging. You can also use this extension on kernel-mode dump files. However, you cannot use this extension on user-mode dump files, unless you specifically created them with handle information. (You can create create such dump files by using the .dump /mh (Create Dump File) command.)

During live user-mode debugging, you can use the .closehandle (Close Handle) command to close one or more handles.

The following examples are user-mode examples of the !handle extension. The following command displays a list of all handles.

0:000> !handle
Handle 4
  Type          Section
Handle 8
  Type          Event
Handle c
  Type          Event
Handle 10
  Type          Event
Handle 14
  Type          Directory
Handle 5c
  Type          File
6 Handles
Type            Count
Event           3
Section         1
File            1
Directory       1
The following command displays detailed information about handle 0x8.

0:000> !handle 8 f
Handle 8
  Type          Event
  Attributes    0
  GrantedAccess 0x100003:
         Synch
         QueryState,ModifyState
  HandleCount   2
  PointerCount  3
  Name          <none>
  Object Specific Information
    Event Type Auto Reset
    Event is Waiting
The following examples are kernel-mode examples of !handle. The following command lists all handles, including free handles.

kd> !handle 0 4
processor number 0
PROCESS 80559800  SessionId: 0  Cid: 0000    Peb: 00000000  ParentCid: 0000
    DirBase: 00039000  ObjectTable: e1000d60  TableSize: 380.
    Image: Idle

New version of handle table at e1002000 with 380 Entries in use

0000: free handle, Entry address e1002000, Next Entry fffffffe
0004: Object: 80ed5238  GrantedAccess: 001f0fff
0008: Object: 80ed46b8  GrantedAccess: 00000000
000c: Object: e1281d00  GrantedAccess: 000f003f
0010: Object: e1013658  GrantedAccess: 00000000
......
0168: Object: ffb6c748  GrantedAccess: 00000003 (Protected)
016c: Object: ff811f90  GrantedAccess: 0012008b
0170: free handle, Entry address e10022e0, Next Entry 00000458
0174: Object: 80dfd5c8  GrantedAccess: 001f01ff
......
The following command show detailed information about handle 0x14 in the kernel handle table.

kd> !handle 14 13
processor number 0
PROCESS 80559800  SessionId: 0  Cid: 0000    Peb: 00000000  ParentCid: 0000
    DirBase: 00039000  ObjectTable: e1000d60  TableSize: 380.
    Image: Idle

Kernel New version of handle table at e1002000 with 380 Entries in use
0014: Object: e12751d0  GrantedAccess: 0002001f
Object: e12751d0  Type: (80ec8db8) Key
    ObjectHeader: e12751b8
        HandleCount: 1  PointerCount: 1
        Directory Object: 00000000  Name: \REGISTRY\MACHINE\SYSTEM\CONTROLSET001\CONTROL\SESSION MANAGER\EXECUTIVE
The following command shows information about all handles to Section objects in all processes.

!handle 0 3 0 Section
...
PROCESS fffffa8004f48940
    SessionId: none  Cid: 0138    Peb: 7f6639bf000  ParentCid: 0004
    DirBase: 10cb74000  ObjectTable: fffff8a00066f700  HandleCount:  39.
    Image: smss.exe

Handle table at fffff8a00066f700 with 39 entries in use

0040: Object: fffff8a000633f00  GrantedAccess: 00000006 (Inherit) Entry: fffff8a000670100
Object: fffff8a000633f00  Type: (fffffa80035fef20) Section
    ObjectHeader: fffff8a000633ed0 (new version)
        HandleCount: 1  PointerCount: 262144
...
```

### [-] dt

: 자료형 정보, 구조체 확인

```
dt (Display Type)
The dt command displays information about a local variable, global variable or data type. This can display information about simple data types, as well as structures and unions.

User-Mode Syntax

dt [-DisplayOpts] [-SearchOpts] [module!]Name [[-SearchOpts] Field] [Address] [-l List] 
dt [-DisplayOpts] Address [-l List] 
dt -h 

Kernel-Mode Syntax

[Processor] dt [-DisplayOpts] [-SearchOpts] [module!]Name [[-SearchOpts] Field] [Address] [-l List] 
dt [-DisplayOpts] Address [-l List] 
dt -h 

Parameters

Processor 
Specifies the processor that is running the process containing the information needed. For more information, see Multiprocessor Syntax. Processors can only be specified in kernel mode.

DisplayOpts 
Specifies one or more of the options given in the following table. These options are preceded by a hyphen.

Option Description 
-a[quantity]
 Show each array element on a new line, with its index. A total of quantity elements will be displayed. There must be no space between the a and the quantity. If -a is not followed by a digit, all items in the array are shown. The -a[quantity] switch should appear immediately before each type name or field name that you want displayed in this manner. 
 
-b
 Display blocks recursively. If a displayed structure contains substructures, it is expanded recursively to arbitrary depths and displayed in full. Pointers are expanded only if they are in the original structure, not in substructures. 
 
-c
 Compact output. All fields are displayed on one line, if possible. (When used with the -a switch, each array element takes one line rather than being formatted as a several-line block.)
 
-d
 When used with a Name that is ended with an asterisk, display verbose output for all types that begin with Name. If Name does not end with an asterisk, display verbose output.
 
-e
 Forces dt to enumerate types. This option is only needed if dt is mistakenly interpreting the Name value as an instance rather than as a type.
 
-i
 Do not indent the subtypes.
 
-o
 Omit offset values of the structure fields.
 
-p
 Address is a physical address, rather than a virtual address.
 
-r[depth]
 Recursively dumps the subtype fields. If depth is given, this recursion will stop after depth levels. The depth must be a digit between 1 and 9, and there must be no space between the r and the depth. The -r[depth] switch should appear immediately before the address.
 
-s size
 Enumerate only those types whose size in bytes equals the value of size. The -s option is only useful when types are being enumerated. When -s is specified, -e is always implied as well.
 
-t
 Enumerate types only.
 
-v
 Verbose output. This gives additional information such as the total size of a structure and the number of its elements. When this is used along with the -y search option, all symbols are displayed, even those with no associated type information.
 

 

SearchOpts 
Specifies one or more of the options given in the following table. These options are preceded by a hyphen.

Option Description 
-n
 This indicates that the next parameter is a name. This should be used if the next item consists entirely of hexadecimal characters, because it will otherwise be taken as an address.
 
-y
 This indicates that the next parameter is the beginning of the name, not necessarily the entire name. When -y is included, all matches are listed, followed by detailed information on the first match in the list. If -y is not included, only exact matches will be displayed.
 

 

module 
An optional parameter specifying the module that defines this structure. If there is a local variable or type with the same name as a global variable or type, you should include module to specify that you mean the global variable. Otherwise, the dt command will display the local variable, even if the local variable is a case-insensitive match and the global variable is a case-sensitive match. 

Name 
Specifies the name of a type or global variable. If Name ends with an asterisk (*), a list of all matches is displayed. Thus, dt A* will list all data types, globals, and statics beginning with "A", but will not display the actual instances of these types. (If the -v display option is used at the same time, all symbols will be displayed -- not just those with associated type information.) You can also replace Name with a period (.) to signify that you want to repeat the most recently used value of Name.

If Name contains a space, it should be enclosed in parentheses. 

Field 
Specifies the field(s) to be displayed. If Field is omitted, all fields are displayed. If Field is followed by a period (.), the first-level subfields of this field will be displayed as well. If Field is followed with a series of periods, the subfields will be displayed to a depth equal to the number of periods. Any field name followed by a period will be treated as a prefix match, as if the -y search option was used. If Field is followed by an asterisk (*), it is treated as only the beginning of the field, not necessarily the entire field, and all matching fields are displayed. 

Address 
Specifies the address of the structure to be displayed. If Name is omitted, Address must be included and must specify the address of a global variable. Address is taken to be a virtual address unless otherwise specified. Use the -p option to specify a physical address. Use an "at" sign ( @ ) to specify a register (for example, @eax).

List 
Specifies the field name that links a linked list. The Address parameter must be included.

Environment
Modes
 user mode, kernel mode
 
Targets
 live, crash dump
 
Platforms
 all 
 

 

Additional Information
For an overview of memory manipulation and a description of other memory-related commands, see Reading and Writing Memory.

Remarks
The dt command output will always display signed numbers in base 10, and unsigned numbers in hexadecimal.

All parameters of dt that allow symbol values also allow string wildcards. See String Wildcard Syntax for details.

The -y and -n options can precede any Name or Field. The -y option allows you to specify the beginning of the type or structure name. For example, dt -y ALLEN will display data about the type ALLENTOWN. However, you could not display the type ALLENTOWN with dt -y A. Instead, you would have to use dt -ny A, because A is a valid hexadecimal value and would be interpreted as an address without the -n option.

If Name indicates a structure, all fields will be displayed (for example, dt myStruct). If you only want one specific field, you can do dt myStruct myField. This displays the member that C would call myStruct.myField. However, note that the command dt myStruct myField1 myField2 displays myStruct.myField1 and myStruct.myField2. It does not display myStruct.myField1.myField2.

If a structure name or field is followed by a subscript, this specifies a single instance of an array. For example, dt myStruct myFieldArray[3] will display the fourth element of the array in question. But if a type name is followed by a subscript, this specifies an entire array. For example, dt CHAR[8] myPtr will display an eight-character string. The subscript is always taken as decimal regardless of the current radix; an 0x prefix will cause an error.

Because the command uses type information from the .pdb file, it can freely be used to debug any CPU platform.

The type information used by dt includes all type names created with typedef, including all the Windows-defined types. For example, unsigned long and char are not valid type names, but ULONG and CHAR are. See the Microsoft Windows SDK for a full list of all Windows type names.

All types created by typedefs within your own code will be present, as long as they have actually been used in your program. However, types that are defined in your headers but never actually used will not be stored in the .pdb symbol files and will not be accessible to the debugger. To make such a type available to the debugger, use it as the input of a typedef statement. For example, if the following appears in your code, the structure MY_DATA will be stored in the .pdb symbol file and can be displayed by the dt command:

typedef struct _MY_DATA {
    . . .
    } MY_DATA;
typedef  MY_DATA *PMY_DATA; 
On the other hand, the following code would not suffice because both MY_DATA and PMY_DATA are defined by the initial typedef and, therefore, MY_DATA has not itself been used as the input of any typedef statement:

typedef struct _MY_DATA {
    . . .
    } MY_DATA, *PMY_DATA; 
In any event, type information is included only in a full symbol file, not a symbol file that has been stripped of all private symbol information. For more information, see Public and Private Symbols.

If you want to display unicode strings, you need to use the .enable_unicode (Enable Unicode Display) command first. You can control the display of long integers with the .enable_long_status (Enable Long Integer Display) command.

In the following example, dt displays a global variable:

0:000> dt mt1 
   +0x000 a                : 10
   +0x004 b                : 98 'b'
   +0x006 c                : 0xdd
   +0x008 d                : 0xabcd
   +0x00c gn               : [6] 0x1
   +0x024 ex               : 0x0 
In the following example, dt displays the array field gn:

0:000> dt mt1 -a gn 
   +0x00c gn : 
    [00] 0x1
    [01] 0x2
    [02] 0x3
    [03] 0x4
    [04] 0x5
    [05] 0x6 
The following command displays some subfields of a variable:

0:000> dt mcl1 m_t1 dpo 
   +0x010 dpo  : DEEP_ONE
   +0x070 m_t1 : MYTYPE1 
The following command displays the subfields of the field m_t1. Because the period automatically causes prefix matching, this will also display subfields of any field that begins with "m_t1":

0:000> dt mcl1 m_t1. 
   +0x070 m_t1  : 
      +0x000 a     : 0
      +0x004 b     : 0 ''
      +0x006 c     : 0x0
      +0x008 d     : 0x0
      +0x00c gn    : [6] 0x0
      +0x024 ex    : 0x0 
You could repeat this to any depth. For example, the command dt mcl1 a..c. would display all fields to depth four, such that the first field name began with a and the third field name began with c.

Here is a more detailed example of how subfields can be displayed. First, display the Ldr field:

0:000> dt nt!_PEB Ldr 7ffdf000 
   +0x00c Ldr : 0x00191ea0 
Now expand the pointer type field:

0:000> dt nt!_PEB Ldr Ldr. 7ffdf000 
   +0x00c Ldr  : 0x00191ea0
      +0x000 Length : 0x28
      +0x004 Initialized : 0x1 ''
      +0x008 SsHandle : (null)
      +0x00c InLoadOrderModuleList : _LIST_ENTRY [ 0x191ee0 - 0x192848 ]
      +0x014 InMemoryOrderModuleList : _LIST_ENTRY [ 0x191ee8 - 0x192850 ]
      +0x01c InInitializationOrderModuleList : _LIST_ENTRY [ 0x191f58 - 0x192858 ]
      +0x024 EntryInProgress : (null) 
Now display the CriticalSectionTimeout field:

0:000> dt nt!_PEB CriticalSectionTimeout 7ffdf000 
   +0x070 CriticalSectionTimeout : _LARGE_INTEGER 0xffffe86d`079b8000 
Now expand the CriticalSectionTimeout structure subfields one level deep:

0:000> dt nt!_PEB CriticalSectionTimeout. 7ffdf000 
   +0x070 CriticalSectionTimeout  :  0xffffe86d`079b8000
      +0x000 LowPart                 : 0x79b8000
      +0x004 HighPart                : -6035
      +0x000 u                       : __unnamed
      +0x000 QuadPart                : -25920000000000 
Now expand the CriticalSectionTimeout structure subfields two levels deep:

0:000> dt nt!_PEB CriticalSectionTimeout.. 7ffdf000 
   +0x070 CriticalSectionTimeout   :  0xffffe86d`079b8000
      +0x000 LowPart                  : 0x79b8000
      +0x004 HighPart                 : -6035
      +0x000 u                        :
         +0x000 LowPart                  : 0x79b8000
         +0x004 HighPart                 : -6035
      +0x000 QuadPart                 : -25920000000000 
The following command displays an instance of the data type MYTYPE1 that is located at the address 0x0100297C:

0:000> dt 0x0100297c MYTYPE1 
   +0x000 a                : 22
   +0x004 b                : 43 '+'
   +0x006 c                : 0x0
   +0x008 d                : 0x0
   +0x00c gn               : [6] 0x0
   +0x024 ex               : 0x0 
The following command displays an array of 10 ULONGs at the address 0x01002BE0:

0:000> dt -ca10 ULONG 01002be0 
[0] 0x1001098
[1] 0x1
[2] 0xdead
[3] 0x7d0
[4] 0x1
[5] 0xcd
[6] 0x0
[7] 0x0
[8] 0x0
[9] 0x0 
The following command continues the previous display at a different address. Note that "ULONG" does not need to be re-entered:

0:000> dt -ca4 . 01002d00 
Using sym ULONG
[0] 0x12
[1] 0x4ac
[2] 0xbadfeed
[3] 0x2 
Here are some examples of type display. The following command displays all types and globals beginning with the string "MY" in the module thismodule. Those prefixed with an address are actual instances; those without addresses are type definitions:

0:000> dt thismodule!MY* 
010029b8  thismodule!myglobal1
01002990  thismodule!myglobal2
          thismodule!MYCLASS1
          thismodule!MYCLASS2
          thismodule!MYCLASS3
          thismodule!MYTYPE3::u
          thismodule!MYTYPE1
          thismodule!MYTYPE3
          thismodule!MYTYPE3
          thismodule!MYFLAGS 
When performing type display, the -v option can be used to display the size of each item. The -s size option can be used to only enumerate items of a specific size. Again, those prefixed with an address are actual instances; those without addresses are type definitions:

0:001> dt -s 2 -v thismodule!* 
Enumerating symbols matching thismodule!*, Size = 0x2
Address   Size Symbol
           002 thismodule!wchar_t
           002 thismodule!WORD
           002 thismodule!USHORT
           002 thismodule!SHORT
           002 thismodule!u_short
           002 thismodule!WCHAR
00427a34   002 thismodule!numberOfShips
00427a32   002 thismodule!numberOfPlanes
00427a30   002 thismodule!totalNumberOfItems 
Here is an example of the -b option. The structure is expanded and the OwnerThreads array within the structure is expanded, but the Flink and Blink list pointers are not followed: 

kd> dt nt!_ERESOURCE -b 0x8154f040 
   +0x000 SystemResourcesList :  [ 0x815bb388 - 0x816cd478 ]
      +0x000 Flink            : 0x815bb388
      +0x004 Blink            : 0x816cd478
   +0x008 OwnerTable       : (null)
   +0x00c ActiveCount      : 1
   +0x00e Flag             : 8
   +0x010 SharedWaiters    : (null)
   +0x014 ExclusiveWaiters : (null)
   +0x018 OwnerThreads     :
    [00]
      +0x000 OwnerThread      : 0
      +0x004 OwnerCount       : 0
      +0x004 TableSize        : 0
    [01]
      +0x000 OwnerThread      : 0x8167f563
      +0x004 OwnerCount       : 1
      +0x004 TableSize        : 1
   +0x028 ContentionCount  : 0
   +0x02c NumberOfSharedWaiters : 0
   +0x02e NumberOfExclusiveWaiters : 0
   +0x030 Address          : (null)
   +0x030 CreatorBackTraceIndex : 0
   +0x034 SpinLock         : 0
Here is an example of dt in kernel mode. The following command produces results similar to !process 0 0:

kd> dt nt!_EPROCESS -l ActiveProcessLinks.Flink -y Ima -yoi Uni 814856f0 
ActiveProcessLinks.Flink at 0x814856f0
---------------------------------------------
UniqueProcessId : 0x00000008
ImageFileName : [16] "System"

ActiveProcessLinks.Flink at 0x8138a030
---------------------------------------------
UniqueProcessId : 0x00000084
ImageFileName : [16] "smss.exe"

ActiveProcessLinks.Flink at 0x81372368
---------------------------------------------
UniqueProcessId : 0x000000a0
ImageFileName : [16] "csrss.exe"

ActiveProcessLinks.Flink at 0x81369930
---------------------------------------------
UniqueProcessId : 0x000000b4
ImageFileName : [16] "winlogon.exe"

.... 
If you want to execute a command for each element of the list, use the !list extension.

Finally, the dt -h command will display a short help text summarizing the dt syntax.
```

### [-] !locks

: 현재 프로세스의 크리티컬 섹션 정보

```
!locks (!ntsdexts.locks)
The !locks extension in Ntsdexts.dll displays a list of critical sections associated with the current process.

This extension command should not be confused with the !kdext*.locks extension command.

    !locks [Options] 

Parameters

Options 
Specifies the amount of information to be displayed. Any combination of the following options can be used:


-v 
Causes the display to include all critical sections, even those that are not currently owned.

-o 
(Windows XP and later) Causes the display to only include orphaned information (pointers that do not actually point to valid critical sections).

DLL
Windows 2000
 Ntsdexts.dll 
 
Windows XP and later 
 Ntsdexts.dll 
 

 

Additional Information
For other commands and extensions that can display critical section information, see Displaying a Critical Section. For information about critical sections, see the Microsoft Windows SDK documentation, the Windows Driver Kit (WDK) documentation, and Microsoft Windows Internals by Mark Russinovich and David Solomon. 

Remarks
This extension command shows all critical sections that have been initialized by calling RtlInitializeCriticalSection. If there are no critical sections, then no output will result.

Here is an example:

 
0:000> !locks

CritSec w3svc!g_pWamDictator+a0 at 68C2C298
LockCount          0
RecursionCount     1
OwningThread       d1
EntryCount         1
ContentionCount    0
*** Locked

CritSec SMTPSVC+66a30 at 67906A30
LockCount          0
RecursionCount     1
OwningThread       d0
EntryCount         1
ContentionCount    0
*** Locked
```

Windbg index를 생활화 하자.

# [+] Reference

1. ***Windows Debugging 2/e - Windbg로 배우는 윈도우 디버깅***