---
layout: article
title: "[Dev]Programming 2"
key: 19700101
tags:
  - Windows
  - Dev
  - C++
toc: true
mathjax: true
mathjax_autoNumber: true
---

# [+] C++ Language

<!--more-->

## [+] Class & Array

### Object Array

객체를 배열의 형태로 선언하여 사용해본다.

```c++
#include <iostream>
using namespace std;

class Point
{
	int x, y;

public:
	Point()
	{
		cout << "Point() Call" << endl;
		x = y = 0;
	}
	Point(int _x, int _y)
	{
		x = _x;
		y = _y;
	}

	int GetX() { return x; }
	int GetY() { return y; }
	void SetX(int _x) { x = _x; }
	void SetY(int _y) { y = _y; }
};

int main()
{
	Point arr[5];

	for (int i = 0; i < 5;i++)
	{
		arr[i].SetX(i * 2);
		arr[i].SetY(i * 3);
	}

	for (int j = 0; j < 5; j++)
	{
		cout << "x: " << arr[j].GetX() << " ";
		cout << "y: " << arr[j].GetY() << endl;
	}
	return 0;
}

```

```
Output >>
Point() Call
Point() Call
Point() Call
Point() Call
Point() Call
x: 0 y: 0
x: 2 y: 3
x: 4 y: 6
x: 6 y: 9
x: 8 y: 12
```

`main()`에서 알 수 있듯이 객체 배열을 선언하였다. `arr[0~4]` 까지 총 5개의 배열에 `Point` 객체가 존재하는 것이다. 그렇기 때문에 클래스 내에 정의되어 있는 `Point()` 가 5번 호출되며 `'Point() Call'` 이 5번 출력되게 된다.

 좀 더 복잡하게 Object Pointer Array로 가본다...  말 그대로 객체 포인터로 구성되어 있는 배열을 의미한다.

```c++
#include <iostream>
using namespace std;

class Point
{
	int x, y;
	
public:
	Point()
	{
		cout << "Point() Call" << endl;
		x = y = 0;
	}
	Point(int _x, int _y)
	{
		x = _x;
		y = _y;
	}
	
	int GetX() { return x; }
	int GetY() { return y; }
	void SetX(int _x) { x = _x; }
	void SetY(int _y) { y = _y; }
};

int main(void)
{
	Point *arr[5]; // 객체 포인터 배열 선언
	
	for (int i = 0; i < 5; i++)
	{
		arr[i] = new Point(i * 2, i * 3);
	}
	for (int j = 0; j < 5; j++)
	{
		cout << "x: " << arr[j]->GetX() << ' ';
		cout << "y: " << arr[j]->GetY() << endl;
	}
	for (int k = 0; k < 5; k++)
	{
		delete arr[k];
	}
	return 0;
}
```

살짝 어렵... `Point *arr[5]` 를 보면 포인터 배열을 선언하고 있다. 그렇기 때문에 5개의 포인터가 생성된다. 
`new Point(i*2,i*3)` 에서 5개의 `Point`객체를 생성하고 해당하는 주소 값을 포인터 배열에 저장될 것 이다. 그리고 `i*2`와 `i*3`을 인자로 받을 수 있는 생성자를 호출하며 객체가 생성될 것이다.

`new`를 사용했기 때문에 힙 영역에 생성이 되고 객체의 주소 값이 `Point`클래스의 포인터 형으로 반환될 것이다.

## [+] Quiz

### NameCard

이전에 작성했던 NameCard를 포인터 배열을 이용하여 객체 생성을 해본다.

```c++
//NameCard.h
#pragma once
#include <iostream>
using namespace std;

class NameCard
{
	char *name;
	char *phone;
	char *addr;
	char *level;

public:

	NameCard(char*, char*, char*, char*);
	~NameCard();
	void ShowData();
	
};

NameCard::~NameCard()
{
	delete[]name;
	delete[]phone;
	delete[]addr;
	delete[]level;

}

NameCard::NameCard(char *_name, char *_phone, char *_addr, char *_level)
{
	name = new char[strlen(_name) + 1];
	strcpy(name, _name);
	phone = new char[strlen(_phone) + 1];
	strcpy(phone, _phone);
	addr = new char[strlen(_addr) + 1];
	strcpy(addr, _addr);
	level = new char[strlen(_level) + 1];
	strcpy(level, _level);
}

void NameCard::ShowData()
{
	cout << "=====================================================" << endl;
	cout << "이름 : " << name << "\n" << "전화 : " << phone << "\n" << "주소 : " << addr << "\n" << "등급 : " << level << endl;
}
```

```c++
//NameCard.cpp
#include <iostream>
#include "NameCard.h"
using namespace std;

const int SIZE = 20;

int main(void)
{
	NameCard *n[3];
	char name[SIZE];
	char phone[SIZE];
	char addr[SIZE];
	char level[SIZE];

	for (int i = 0; i < 3; i++)
	{

		cout << "=========================입력========================" << endl;
		cout << "이름 : "; cin >> name;
		cout << "전화 : "; cin >> phone;
		cout << "주소 : "; cin >> addr;
		cout << "등급 : "; cin >> level;

		n[i] = new NameCard(name, phone, addr, level);
		if (i == 2)
		{
			cout << "\n====================데이터출력=======================" << endl;
		}
	}

	for (int j = 0; j < 3; j++)
	{
		n[j]->ShowData();
	}
}
```

끄읏. 소스는 <a href="https://github.com/Shhoya/Shhoya.github.io/tree/master/SourceCode">여기</a>..

## [+] This Pointer

### Concept

클래스 내에 멤버함수에 `this`라는 이름의 포인터를 사용 가능하다고 한다.
다음 소스를 이용해 무엇을 의미하는지 확인해본다.

```c++
#include <iostream>
using namespace std;

class Person
{
public:
	Person *GetThis() { return this; }
};

int main(void)
{
	cout << "**** p1 ****" << endl;
	Person *p1 = new Person();
	cout << "Pointer p1: " << p1 << endl;
	cout << "This p1: " << p1->GetThis() << endl;
	cout << "**** p2 ****" << endl;
	Person *p2 = new Person();
	cout << "Pointer p2: " << p1 << endl;
	cout << "This p2: " << p1->GetThis() << endl;
	return 0;

}
```

출력 결과를 확인하면 `this`의 값과 각 포인터 변수의 값이 같은 것을 확인할 수 있다.
즉, this는 자기 자신을 참조하는 용도로 사용된다. 자기 참조 포인터라고도 부른다.

### Usage

```c++
#include <iostream>
using namespace std;

class Data
{
	int aa;
	int bb;
	
public:
	Data(int,int);
	void print();
	
};

Data::Data(int aa, int bb)
{
	this->aa = aa;
	this->bb = bb;
}

void Data::print()
{
	cout << aa << ' ' << bb << endl;
}

int main(void)
{
	Data d(100, 200);
	d.print();
	return 0;
}
```

음 하면서 느껴지는 C++의 단점은 과하게 편리하게 만들어진 언어?라는 생각이든다;
`this->aa` , `this->bb` 구문을 확인하면 위에서 설명한대로 진행되기 때문에 의도한 대로 값이 저장된다.

그러나 만약 매개변수의 이름과 멤버변수의 이름이 같다면?

`this->aa=aa`가 `aa=aa` 라면..? 멤버변수는 무시당하고 매개변수로 모두 읽게 된다.
굳이 변수이름을 같게해서 This Pointer를 사용하는 이유를 모르겠으나...
외워야 하는 변수의 이름이 줄어드는 효과가 있어서 이렇게 사용한다고 한다..;



## [+] Friend

### Concept

기존 알고있던 상식으로는 `private`로 선언된 멤버 변수는 외부에서 접근이 불가능하다. 하지만 지금 이야기하는 `friend`속성을 이용하여 가능하도록 할 수 있다.
책에 역시 예제가 잘되있다..

```c++
#include <iostream>
using namespace std;

class Counter
{
	int val;
	
public:
	Counter();
	void Print() const;
	friend void SetX(Counter &, int); //friend 선언
};

Counter::Counter()
{
	val = 0;
}

void Counter::Print() const
{
	cout << val << endl;
}

void SetX(Counter &c, int val) // 전역변수
{
	c.val = val;
}

int main(void)
{
	Counter cnt;
	cnt.Print();

	SetX(cnt, 2002);
	cnt.Print();
	return 0;
}
```

확인해보면 `SetX` 함수는 멤버변수가 아닌 전역변수이다. 그럼에도 메인함수에서 생성한 객체 `cnt`를 매개변수로 이용하여 호출하고 이를 이용해 `Counter` 클래스의 private 멤버 변수를 변경할 수 있다.

이건 바로 주석에 써있듯이 `friend` 선언에 의한 것이다.



# [+] Reference

1. <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=147521">열혈강의 C++ 프로그래밍</a>