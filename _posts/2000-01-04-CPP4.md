---
layout: article
title: "[Dev]Programming 4"
key: 19700101
tags:
  - Dev
toc: true
mathjax: true
mathjax_autoNumber: true
published : true
---

# [+] Pure vFunc & Abstract Class

<!--more-->

## [+] Concept

이전 포스팅에서 해결된 `Employee` 클래스를 확인해보자. 

```c++
/* Employee Class */

class Employee
{
protected:
	char name[20];

public:
	Employee(const char* _name);
	const char* GetName();
	virtual int GetPay() { return 0; };
};

Employee::Employee(const char* _name)
{
	strcpy(name, _name);
}

const char* Employee::GetName()
{
	return name;
}
```

`GetPay` 함수는 아무런 기능도 없고, 지닐 필요도 없다.
해당 함수를 호출하기 위한 것이 아닌, 오버라이딩을 이용하여 서브 클래스의 함수를 호출하는 용도로 사용되기 때문이다.

이런 경우 선언만 하고 정의를 하지 않아도 된다.

```c++
/* Employee Class */

class Employee
{
protected:
	char name[20];

public:
	Employee(const char* _name);
	const char* GetName();
	virtual int GetPay()=0;	// Pure
};

```

컴파일러에게 해당 함수는 호출될 일이 없으므로 선언만 하고 정의는 하지 않는다. 라고 말하는 것과 같다.
위에서 말한 것과 같이 다른 용도로 사용되기 때문에!

이렇게 하나 이상의 멤버 함수가 `Pure Virtual Function` 인 클래스를 `Abstract Class`(추상 클래스) 라고 한다. 

추상 클래스는 객체화 하지 못한다. 함수의 정의가 생략되었기 때문에 완전한 클래스가 아니기 때문에 객체를 생성하지 못한다.

실제로 메인함수에 `Employee e` 라고 선언하면 오류를 확인할 수 있다. 

```C++ 추상 클래스 형식의 개체를 사용할 수 없습니다.            함수은(는) 순수 가상 함수입니다.``` 라는 오류를 볼 수 있다.

## [+] Quiz

`Employee Problem` 이 해결되었지만 완성은 아니다. 판매직을 의미하는 `SalesPerson` 클래스를 정의하라.

`SalesPerson`은 연봉제(기본급여) + 인센티브(판매 수익 x 0.15)로 급여가 계산된다.

### [-] Solution

```c++
/* SalesPerson Class */

class SalesPerson :public Permanent
{
	int sell;

public:
	SalesPerson(const char* _name, int _sal, int _sell);
	int GetPay();
};

SalesPerson::SalesPerson(const char* _name, int _sal, int _sell) :Permanent(_name, _sal)
{
	sell = _sell;
}

int SalesPerson::GetPay()
{
	return Permanent::GetPay() + sell * 0.15;
}
```

`SalesPerson` 은 `Permanent` 클래스의 특성을 동시에 지니므로 `Employee` 클래스를 상속하는게 아니라 `Permanent` 클래스를 상속받아 위와 같이 쉽게 만들 수 있다. 확장성 쵝오...

전체 코드

```c++
#include <iostream>
#pragma warning(disable:4996)

using namespace std;



/* Employee Class */

class Employee
{
protected:
	char name[20];

public:
	Employee(const char* _name);
	const char* GetName();
	virtual int GetPay() = 0;
};

Employee::Employee(const char* _name)
{
	strcpy(name, _name);
}

const char* Employee::GetName()
{
	return name;
}

/* Permanent Class */

class Permanent :public Employee
{
	int salary;

public:
	Permanent(const char* _name, int sal);
	int GetPay();
};

Permanent::Permanent(const char* _name, int sal) : Employee(_name)
{
	strcpy(name, _name);
	salary = sal;
}

int Permanent::GetPay()
{
	return salary;
}

class Temporary : public Employee
{
	int time, pay;

public:
	Temporary(const char* _name, int _time, int _pay);
	int GetPay();
};

Temporary::Temporary(const char* _name, int _time, int _pay) :Employee(_name)
{
	time = _time;
	pay = _pay;
}

int Temporary::GetPay()
{
	return time*pay;
}

/* SalesPerson Class */

class SalesPerson :public Permanent
{
	int sell;

public:
	SalesPerson(const char* _name, int _sal, int _sell);
	int GetPay();
};

SalesPerson::SalesPerson(const char* _name, int _sal, int _sell) :Permanent(_name, _sal)
{
	sell = _sell;
}

int SalesPerson::GetPay()
{
	return Permanent::GetPay() + sell * 0.15;
}

/* Department class */

class Department
{
	Employee* empList[10];
	int idx;

public:
	Department() : idx(0) {};
	void AddEmployee(Employee* emp);
	void ShowList();
};

void Department::AddEmployee(Employee* emp)
{
	empList[idx++] = emp;
}

void Department::ShowList()
{
	for (int i = 0; i < idx; i++)
	{
		cout << "name : " << empList[i]->GetName() << endl;
		cout << "pay : " << empList[i]->GetPay() << endl;
		cout << endl;
	}
}

int main()
{
	Department department;

	department.AddEmployee(new Permanent("KIM", 2000));
	department.AddEmployee(new Permanent("Shin", 3000));
	department.AddEmployee(new Temporary("Choi",10,200));
	department.AddEmployee(new Temporary("LEE",12,300));
	department.AddEmployee(new SalesPerson("Shh0ya", 2000, 3000));

	department.ShowList();
	return 0;

}
```

# [+] Virtual Destructor

## [+] Problem

가상 함수 외에도 `virtual` 키워드는 소멸자에도 필요하다. 다음의 코드를 보면 문제점을 알 수 있다.

```c++
#include <iostream>
#pragma warning(disable:4996)

using namespace std;

class AAA
{
	char* str1;
	
public:
	AAA(const char* _str);
	~AAA();
	virtual void ShowString();
};

AAA::AAA(const char* _str)
{
	str1 = new char[strlen(_str) + 1];
	strcpy(str1, _str);
}

AAA::~AAA()
{
	cout << "~AAA() Call" << endl;
	delete[] str1;
}

void AAA::ShowString()
{
	cout << str1 << ' ';
}

class BBB :public AAA
{
	char* str2;

public:
	BBB(const char* _str1, const char* _str2);
	~BBB();
	virtual void ShowString();
};

BBB::BBB(const char* _str1, const char* _str2) :AAA(_str1)
{
	str2 = new char[strlen(_str2) + 1];
	strcpy(str2, _str2);
}

BBB::~BBB()
{
	cout << "~BBB() Call" << endl;
	delete[] str2;
}

void BBB::ShowString()
{
	AAA::ShowString();
	cout << str2 << endl;
}


int main()
{
	// 상속 관계이므로 문제 없음
	AAA* a = new BBB("Good", "Evening");
	BBB* b = new BBB("Good", "Morning");

	// 둘 다 BBB 클래스의 ShowString 호출
	a->ShowString();	
	b->ShowString();

	cout << "---Destruct Object ---" << endl;

	//동적 생성한 객체 소멸
	delete a;
	delete b;
	
	return 0;
}
```

별 문제 없어보인다. 실제 출력해보면 문제점을 발견할 수 있다.

```
Good Evening
Good Morning
---Destruct Object ---
~AAA() Call
~BBB() Call
~AAA() Call
```

소멸자를 보면 문제를 볼 수 있다. `BBB` 클래스의 소멸자가 한번 덜 호출됐다.

`a`는 `BBB` 클래스의 객체를 참조하지만 `AAA` 타입의 포인터로 참조를 하고 있기 때문에 `delete a`는 `AAA` 클래스의 소멸자만 호출하게 된다.

정상적이라면 `~BBB` -> `~AAA` -> `~BBB` -> `~AAA` 여야 한다.

이러한 문제는 꽤 크다. 메모리 누수가 발생하기 때문이다.

해당 문제를 해결하는 방법은 베이스 클래스의 소멸자에 `virtual` 키워드를 추가하는 것이다.

```c++
class AAA
{
	char* str1;
	
public:
	AAA(const char* _str);
	virtual ~AAA();
	virtual void ShowString();
};
```

```
Good Evening
Good Morning
---Destruct Object ---
~BBB() Call
~AAA() Call
~BBB() Call
~AAA() Call
```

정상적으로 동작하는 것을 볼 수 있다.

`AAA* a` 는 `BBB` 클래스의 객체를 참조한다. `delete a`를 했을 때,  기존과 마찬가지로 `AAA` 타입이므로 `AAA`의 소멸자를 호출하려 한다. 그런데 virtual 키워드로 인해 서브 클래스의 소멸자를 호출한다.

이름은 다르지만 둘 다 소멸자인 관계로 virtual 함수를 오버라이딩 했을 때와 같은 현상이 발생한다. 

그 다음 `BBB` 클래스의 소멸자가 호출되고 정상적으로 `AAA` 클래스의 소멸자를 호출하여 모두 정상 동작하게 되는 것이다.

# [+] Virtual Function

가상함수의 원리에 대해 알아본다. 책에서는 진도가 급하다면 넘어가라고 했지만 사실 내게 매우 중요한 부분이다.

가상 함수 테이블과 가상 함수 동작 원리에 대해 알면 할 수 있는게 많아진다.

## [+] Class Member Function

먼저 클래스의 멤버 함수를 좀 더 알아본다.

```c++
#include <iostream>

using namespace std;

class Data
{
	int data;

public:
	Data(int num);
	void ShowData();
	void Add(int num);
};

Data::Data(int num)
{
	data = num;
}

void Data::Add(int num)
{
	data += num;
}

void Data::ShowData()
{
	cout << "Data : " << data << endl;
}

int main()
{
	Data ddd(10);
	ddd.Add(10);
	ddd.ShowData();
	return 0;
}
```

다음은 C 스타일로 구조체와 전역함수를 이용해 클래스를 흉내낸 것이다.

```c
#include <iostream>

using namespace std;

struct Data
{
	int data;
	void (*ShowData)(Data*);
	void (*Add)(Data*, int);
};

void ShowData(Data* THIS)
{
	cout << "Data : " << THIS->data << endl;
}

void Add(Data* THIS, int num)
{
	THIS->data += num;
}

int main()
{
	Data ddd1 = { 10,ShowData,Add };
	ddd1.Add(&ddd1, 10);
	ddd1.ShowData(&ddd1);
    
    Data ddd2 = {1, ShowData, Add};
    ddd2.Add(&ddd2,1);
    ddd2.ShowData(&ddd2);
    
    return 0;
}
```

```
Data : 20
Data : 2
```

위에 정의된 `Data` 구조체를 보면 `data`라는 멤버 변수가 선언되어 있다. 그리고 각 함수 포인터가 선언되어 있다.
메인 함수에서는 구조체 변수 `ddd1`을 생성하고 `10, ShowData, Add` 로 초기화 하고 있다.

`ddd1`과 `ddd2`는 함수 `ShowData`와 `Add` 를 공유하고 있다고 볼 수 있다.

실제로 생성되는 객체도 유사한 형태를 지닌다.

**객체가 생성되면 멤버 변수는 객체 내에 존재한다. 그러나 멤버 함수는 메모리의 한 공간에 존재하며 모든 객체가 공유하는 형태를 취한다.**

굳.... 쉽게 말하면 객체 별로 멤버 함수가  메모리 내 나눠져있지 않다는 뜻이다. 멤버 함수 하나를 갖는 클래스의 객체 1,2,3이 있다면 메모리 내에 멤버 함수는 하나만 존재한다. 객체 별로 3개가 있지 않다는 이야기



