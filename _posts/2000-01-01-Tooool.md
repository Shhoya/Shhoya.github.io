---
layout: article
title: "[Dev]Programming"
key: 19700101
tags:
  - Windows
  - Dev
toc: true
mathjax: true
mathjax_autoNumber: true
---

# [+] C++ Language

<!--more-->

## [+] Basic

### Gazua

홀로 공부하는 C++.. C와 Python과 더불어 C++을 공부해보기로 했다.

### I/O

```c++
#include <iostream>
using namespace std;

int main(void){
   	int value=0;
    cout << "Hello World" << endl; //endl (개행)
    cout << "Value 입력 : ";
    cin >> value;
    value+=1;
    cout << "Value : " << value << endl;
}
```

```
Console
Hello World
Value 입력 : 1
Value : 2
```

### Function Overloading

이 기능 좀 좋은듯... C에서는 선언된 함수명으로 함수를 구분한다. 하지만 C++에서는 함수명과 매개변수까지 확인해서 함수를 구분한다. 엄청..나다!!!!!!

```c++
#include <iostream>
using namespace std;

int OverF(int val){
    val += 1;
    return val;
}

int OverF(int val, int val2){
    return val + val2;
}

int main(void){
    int a,b;
    a=0verF(1);
    b=0verF(1,2);
    cout << "OverF : " << a << endl;
    cout << "OverF : " << b << endl;
    return 0;
    
}
```

```
console
OverF : 2
OverF : 3
```

잘돌아간다... 뭐 굳이 이렇게 오버로드를 할 필요가 있나 싶지만...? 잘생각해봐야지뭐;

### OverLoading 연습문제

```c++
#include <iostream>

using namespace std;

swap()

int main(void) {
	int num1 = 20, num2 = 30;
	swap(&num1, &num2);
	std::cout << num1 << " " << num2 << std::endl;
	char ch1 = 'a';
	char ch2 = 'z';
	swap(&ch1, &ch2);
	std::cout << ch1 << " " << ch2 << std::endl;
	double db11 = 1.111, db12 = 5.555;
	swap(&db11, &db12);
	std::cout << db11 << " " << db12 << std::endl;
	return 0;

}
```

```
예상 출력 결과
30 20
z a
5.555 1.111
```



### Default Argument

기본 매개변수라는게 존재한다. 함수에 매개변수를 전달하지 않고 함수를 호출할 때 사용된다. 유용한듯..?

```c++
#include <iostream>
using namespace std;

int func(int a=0){   //int a=0 <- Default Argument
    a+=1;
    return a;
}

int main(void){
    cout << func(1) << endl;
    cout << func() << endl;
    return 0;
}
```

```
Console
2
1
```

선언된 func 함수에는 매개변수를 받도록 되어있다. 그러나 main함수에서 보듯이 func() 처럼 매개변수를 전달하지 않을 경우 원래는 컴파일 에러가 뚜둥 뜰 것이다. 하지만 Default Argument 라는 속성 때문에 호출 시 매개변수가 알아서 0으로 세팅된다. 유용한 듯 하다.

음 직육면체의 넓이를 구하는 프로그램이란다... 활용하는 코드를 본다.

```c++
#include <iostream>
using namespace std;

int BoxVolume(int length, int height=1, int width=1); //함수 선언

int main(void){
    
    cout << "[3, 3, 3] : " << BoxVolume(3,3,3) << endl;
    cout << "[2, 4, Default] : " << BoxVolume(2,4) << endl;
    cout << "[4, Default, Default] : " <<BoxVolume(4) << endl;
    return 0;
    }

int BoxVolume(int length, int height, int width){
    return length*height*width;
}
```

```
Console
27
8
4
```

개꾸울...다만 조심해야 될껀, Overload와 Default Argument를 같이 쓸 때는 조심해야 된다.

### In-line Function

인라인 함수에 아주 좋은 예

```c++
//Normal
#include <iostream>
using namespace std;

int SQUARE(int x){
    return x*x;
}

int main(void){
    cout << SQUARE(5) << endl;
    return 0;
}
//In-line
inline int SQUARE(int x){
    return x*x;
}

int main(void){
    cout << SQUARE(5) << endl;  // cout << ((5)*(5)) << endl; 효과
    return 0;
}

```

함수 호출이 사라진다. 그렇기 때문에 메모리 여유 공간이 늘어난다..

### NameSpace

NameSpace는 협업 시 일어나는 선언된 함수들의 이름이 충돌되는 문제에 대한 대안으로 나온 속성이다.
A라는 회사와 B라는 회사가 협업하여 추후에 코드를 합치려고 하였는데 중복되는 함수의 이름이 있다.. 그럼 일일이 해당 함수이름을 누군가는 다 바꿔줘야한다. 이럴 때 사용 가능한 유용한 기능이 NameSpace이다.

```c++
#include <iostream>
using namespace std;

namespace A{
int func(){
    return 2+2;
}
}

namespace B{
int func(){
    return 1+1;
}
}

int main(void){
    cout << "A회사 : " << A::func() <<endl;
    cout << "B회사 : " << B::func() <<endl;
    return 0;
}
```

```
Console
A회사 : 4
B회사 : 2
```

위의 코드처럼 사용할 수 있다. namespace ~ 로  중괄호('{ }')를 이용하여 감싸주면 된다. 요로코롱 하고 함수 호출 시 'A::func()' 해주면 충돌이 나지 않고 아름답게 실행된다.

```c++
#include <iostream>
using namespace std;
int a=0;

int main(void){
    int a=1;
    cout << a+1 << endl;
    cout << ::a+1 << endl; // 전역변수 증가
    return 0
}
```

보통 지역변수와 전역변수의 이름이 같을 때 지역변수의 값을 우선 시 한다.. 이 때 전역변수에 접근 가능하당다.



### Bank program

```c++
/* 계좌개설, 입금, 출금, 잔액조회*/
/********************************************/
/*ID 중복안됨, 입.출금액은 무조건 0보다 크다*/
/*계좌번호, 이름, 잔액만 저장 배열을 이용함**/
/********************************************/


#include <iostream>
using namespace std;
const int buffer = 20;

typedef struct _Account
{
	int id;
	int balance;
	char name[buffer];
}Account;

Account pArray[100];
int index = 0;

void menu();
void makeAc();
void deposit();
void withdraw();
void inquire();

enum { MAKE = 1, INQUIRE, DEPOSIT, WITHDRAW, EXIT };

int main(void) {

	int select=0;

	while (1) {
		menu();
		cout << "Select : ";
		cin >> select;
		printf("%d\n", select);
		if (select < 1) {
			cout << "잘못된 입력\n" << endl;
			break;
		}
		switch (select) {
		case MAKE:
			makeAc();
			break;
		case INQUIRE:
			inquire();
			break;
		case DEPOSIT:
			deposit();
			break;
		case WITHDRAW:
			withdraw();
			break;
		case EXIT:
			return 0;
		default:
			cout << "입력 값 범위 초과\n" << endl;
			break;
		}
	}


}


void menu() {
	cout << "[*] Menu" << endl;
	cout << "[+] Make Account" << endl;
	cout << "[+] Inquire" << endl; 
	cout << "[+] Deposit" << endl;
	cout << "[+] Withdraw" << endl;
	cout << "[+] Exit" << endl;

}

void makeAc() {
	int id;
	int balance;
	char name[buffer];

	cout << "[+]계좌 개설[+]" << endl;
	cout << "[+]계좌 ID :";
	cin >> id;
	cout << "[+]이름 : ";
	cin >> name;
	cout << "[+]입금금액 : ";
	cin >> balance;
	pArray[index].id = id;
	strcpy(pArray[index].name, name);
	pArray[index].balance = balance;
	index++;
}

void inquire() {
	
	for (int i = 0; i < index; i++) {
		cout << "======================" << endl;
		cout << "계좌 ID : " << pArray[i].id << endl;
		cout << "이름 :" << pArray[i].name << endl;
	    cout << "잔액 : " << pArray[i].balance << endl;
		cout << "\n";

	}
}

void deposit() {
	int id;
	int money;
	
	cout << "=========Deposit========\n";
	cout << "계좌 ID 입력 : ";		cin >> id;
	
	for (int i = 0; i < index; i++) {

		if (pArray[i].id == id) {
			cout << "입금 금액 : ";		cin >> money;
			pArray[i].balance += money;
			cout << "입금 완료\n" << endl;
			return;
		}

	}
	cout << "존재하지 않는 ID" << endl;
	
}

void withdraw() {
	int id;
	int money;
	
	cout << "=========Withdraw=========\n";
	cout << "계좌 ID 입력 : ";		cin >> id;
	
	for (int i = 0; i < index; i++) {

		if (pArray[i].id == id) {
			cout << "출금 금액 : ";		cin >> money;
			if (pArray[i].balance < money) {
				cout << "출금 한도 초과" << endl;
				return;
			}
			else {
				pArray[i].balance -= money;
				cout << "출금 완료\n" << endl;
				return;

			}


		}

	}
	cout << "존재하지 않는 ID" << endl;
}
```



## [+] C++ 

### Boolean

참과 거짓을 나타내는 자료형 Boolean...

사용방법

```c++
#include <iostream>
using namespace std;

bool func(int a);

int main(void) {
	int a;
	bool result;
	cout << "입력 : ";		cin >> a;
	result = func(a);
	if (result == true) {
		cout << "TRUE" << endl;
		return 0;
	}

	else {
		cout << "FALSE" << endl;
		return 0;
	}
}

bool func(int a) {
	
	if (a > 0) {
		return true;
	}

	else {
		return false;
	}

}
```



### Reference 1

레퍼런스란, 별명을 지어주는 것이다. 근데 이게 골때리는게 연산자 '&'을 사용한다... 헷갈리게스리... 안그래도 포인터 다시해야되는데 ~~fxxk~~

```c++
#include <iostream>
using namespace std;

int main(void){
    int a = 1;
    int &ref = a;	// 레퍼런스 선언
    int *pa = &a;	// 포인터 변수 선언과 주소
    
    return 0;    
}
```

아래 코드를 실행해보면 두개의 변수는 마치 하나와 같다. 

```c++
#include <iostream>
using namespace std;

int main(void) {
	int a=0;
	
	int &ref = a;
	
	a++;
	cout << "a :" << a << endl;
	cout << "ref :" << ref << endl;

	ref++;
	cout << "ref :" << ref << endl;
	cout << "a :" << a << endl;

}
```

```
Console
a:1
ref:1
ref:2
a:2
```

오... 나름 중요한 개념인 것 같다. C언어로 예를 드니 좀더 쉬운 것 같다. C에서는 메모리 공간에 하나의 변수만 선언이 가능하다. 그러나 C++에서 이 레퍼런스는 하나의 메모리 공간에 변수를 하나 더 맵핑 시키는것과 같은 효과이다. 기깔난다.

이러한 레퍼런스의 장점에 대해 공부하자아

### Reference 2

#### Call by Reference

간단한 스왑 소스코드를 보자..

```c++
int swap(int *a, int *b);

int main(void) {
	int a,b,c,d;
	a = 10, b = 20, c = 30, d = 40;
	swap(&a, &b);
	swap(&c, &d);
}

int swap(int *a, int *b) {
	int tmp = *a;
	*a = *b;
	*b = tmp;
	cout << "SWAP :" << *a <<" "<< *b << endl;
	return 0;
}
```

```
Console
SWAP : 20 10
SWAP : 40 30
```

Call by Reference를 이용하여 각 값을 스왑하는 소스코드이다. 포인터를 이용해 참조되는 메모리 공간에 직접 접근이 가능하다는 장점이 존재한다. 하지만 잘못된 메모리 주소 참조나 연산으로 인해 치명적인 오류가 될 수 있다는 단점 또한 존재한다. 그렇기 때문에 C에서 포인터를 핵심적으로 가르치는것 같다.

<a href="#reference-1">Reference</a>를 다시 보면 이러한 단점을 레퍼런스 속성을 이용해 커버가 가능하다는 것을 알 수 있다. 

```c++
#include <iostream>
using namespace std;

int swap(int &a, int &b) {
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
	cout << "rSwap :" << a << " " << b << endl;
	return 0;
}

int main(void) {

	int a, b, c, d;
	a = 10, b = 20, c = 30, d = 40;
	swap(a, b);
	swap(c, d);
}
```

아... 이거 개꿀.... 복잡하게 생각할 꺼 없이 호출되는 함수에서 인자를 전달받을 때 레퍼런스로 받으면 전달된 인자와 같은 메모리 공간에 할당되어 사용이 가능하다. 개꿀띠. 

그러나 전문가들은 함수 호출 시, 그냥 `swap(a,b);` 로 호출을 하기 때문에 이게 Call by Reference인지 value인지 모르기 때문에 코드가 길어지면 매우 불편하다고 안쓰는게 낫다고 한다.. 뭐 사용하는 사람 맘임..

#### Call by Value

책에 나온 예제를 살펴본다. 간단히 개인정보?를 출력해주는 프로그램이다.

```c++
#include <iostream>
using namespace std;

struct _Person {
	int age;
	char name[20];
	char pid[20];
}; typedef struct _Person Person;

void showData(Person p);

int main(void) {
	Person man;
	cout << "Name : ";
	cin >> man.name;
	cout << "Age : ";
	cin >> man.age;
	cout << "PersonID : ";
	cin >> man.pid;
	
	showData(man);

}

void showData(Person p) {
	cout << "이 름 : " << p.name << endl;
	cout << "나 이 : " << p.age << endl;
	cout << "주민등록번호 :" << p.pid << endl;

}
```

``main``함수에서 ``showData`` 함수를 호출할 때 넘겨주는 인자가 구조체 변수 ``man``을 그대로 넘기고 있다. ``age, name, pid`` 를 합해 총 44바이트를 함수로 전달하여 사용한다. 매우 좋지 않은걸 알 수 있다.. 이럴 때 레퍼런스를 이용해 가벼운 마음으로 이용할 수 있다.

```c++
void showData(const Person &p) {
	cout << "이 름 : " << p.name << endl;
	cout << "나 이 : " << p.age << endl;
	cout << "주민등록번호 :" << p.pid << endl;
	
}
```

 ``showData``함수에서 인자를 전달받을 때 레퍼런스 형태로 전달받고 ``const``로 상수처리를 해줌으로써 출력만 해주는 함수의 역할을 다하기 위해 함수 내에서 데이터를 바꿀 수 없도록 하였다..

### Think

정리한번하자.

1. 객체지향프로그래밍
2. 입/출력이 좀 편함..
3. overloading 이란 좀 짱인 기능이 있음. 함수이름이 중복되어도 매개변수까지 확인하여 호출하기 때문에 유연함
4. Default argument 속성이 있기 때문에 함수 선언 및 정의 시 디폴트 값 설정이 가능하다..
5. inline 만 붙여주면 inline 함수가 된다. (함수호출 과정이 사라지기 때문에 성능 향상)
6. Namespace라는 속성이 존재하며 이는 협업 시 함수명등의 충돌에 대해 유연하게 대처 가능하다..
7. Reference 는 포인터와 비슷하다! 포인터의 장점만 뽑아놨다..? 메모리에 직접 접근할 수 있으나 포인터연산을 하지 못하도록 하여 잘못된 메모리 참조등의 오류가 나지 않게 할 수 있다. 음.. 여긴 더 공부해야된다.

### Reference 3

#### Return Type

레퍼런스를 리턴하는 함수에 대한 설명이다. 집중해야된다.. 포인터때와 같은 느낌인데...?;;

```c++
#include <iostream>
using namespace std;

int &inc(int &val);

int main(void) {
	int a = 10; // (1)특정 메모리 공간에 a라는 이름을 할당해주고 해당 공간에 10을 저장
	int &ref = inc(a); //(3) inc 함수 내에 val은 소멸되고 해당 주소에 ref라는 이름을 다시 지정. 즉 a와 ref의 주소는 같다. 

	cout << " A : " << a << endl;
	cout << " Ref : " << ref << endl;
	return 0;

}

//(2)a를 &val로 전달받는다. a의 메모리공간에 val이라는 이름이 하나 더 할당..
int &inc(int &val) {
	val++; // 1증가, val=11이고 a=11
	return val; //val을 리턴함. 이때 리턴 형태는 레퍼런스 형태
}
```

주석으로 내 나름대로 정리를해봤다. 머리아프긴하다 사알짝...
책에 결론적으로 레퍼런스 형태로 리턴을 쓰지말라고 한다.!!

### new & delete

#### malloc(), free()

C에서 메모리 동적할당을 위해 malloc 함수와 free함수를 써봤다. C++에서는 이를 대신하여 new와 delete가 존재한다. 매우 직설적이군..!

```c++
#include <iostream>

using namespace std;

int main(void) {
	int size;
	cout << "배열 크기 : " << endl;
	cin >> size;

	int *arr = (int*)malloc(sizeof(int)*size); //C style
	
	for (int i = 0; i < size; i++) {
		arr[i] = i + 10;
	}

	for (int j = 0; j < size; j++) {
		cout << "Array[" << j << "] :" << arr[j] << endl;
	}

	free(arr); //C style
	return 0;
}
```

이번엔 C++..

```c++
#include <iostream>

using namespace std;

int main(void) {
	int size;
	cout << "배열 크기 : " << endl;
	cin >> size;

	int *arr = new int[size]; //C++ style
	
	for (int i = 0; i < size; i++) {
		arr[i] = i + 10;
	}

	for (int j = 0; j < size; j++) {
		cout << "Array[" << j << "] :" << arr[j] << endl;
	}

	delete[] arr; //C++ style
	return 0;
}
```

지린다... 엄청엄청 편해진 것을 볼 수 있다. 아 근데 포인터를 다시 공부해야 할 느낌이다.^^^

적절하게 delete를 통해 동적할당을 해제해주지 않으면 메모리 공간이 부족하게 될 것이다. 이런 중에 new 를 이용해 또 메모리 할당을 하게 될 경우 할당을 할 수 없을 것이다. 이 때 new 는 NULL 포인터를 반환하게 된다. 그렇기 때문에 아래와 같이 코딩하는 것이 올바르다.

```c++
#include <iostream>

using namespace std;

int main(void) {
	int size;
	cout << "배열 크기 : " << endl;
	cin >> size;

	int *arr = new int[size]; //C++ style
    if(arr==NULL){ //정상적인 할당 여부 확인
        cout << "실패" << endl;
        return -1;
    }
	for (int i = 0; i < size; i++) {
		arr[i] = i + 10;
	}

	for (int j = 0; j < size; j++) {
		cout << "Array[" << j << "] :" << arr[j] << endl;
	}

	delete[] arr; //C++ style
	return 0;
}
```

### Struct & Class

부류를 형성하는 데이터들을 하나의 자료형으로 정의하여 관리 및 구현을 용이하게 하기 위해 구조체가 등장.

C++에서는 구조체를 하나의 자료형으로 인정한다. 그렇기 때문에 C와 다르게 typedef 로 별칭 설정등을 안해도 된다.. 꿀?

이제 데이터만 가지고 구조체를 만드는 것이 아니라 함수까지 구조체 안에 포함하여 만들어 본다.. 책에 나온 예제와 같이 은행에 관한 기능들을 구조체를 이용해 만들어본다.

```c++
#include <iostream>
using namespace std;

struct Banking {
	char Acct[20];
	char pwd[20];
	char name[20];
	int balance;

	void deposit(int money) {
		balance += money;
	}

	void withdraw(int money) {
		if (balance < money) {
			cout << "잔액부족" << endl;
		}
		balance -= money;

	}

};

int main(void) {
	int money=0;
	Banking a{ "Shhoya","P@ssw0rd","Shh",100000 };
	cout << "입력(입금) : ";
	cin >> money;
	a.deposit(money);
	cout << "잔액 : " << a.balance << endl;
	cout << "입력(출금) : ";
	cin >> money;
	a.withdraw(money);
	cout << "잔액 : " << a.balance << endl;

	return 0;
}
```

C와는 다르게 구조체에 함수를 멤버로 포함시킬 수 있다. 음 신박하군.

자 C++에서 정의한 구조체는 더 이상 구조체가 아니다. 클래스라고 말할 수 있다. 라고 책에 나와있다. 이는 클래스에 대해 단계적으로 접근하기 위한 저자의 의도라고 생각된다. 하지만 틀린 말은 아니다.

> Class = Attribute + Method

실제 C++에서의 구조체를 보면 위와 같은 형태다. 멤버 변수와 멤버 함수로 이루어져있기 때문에 클래스라고 할 수 있다. 클래스라는 큰 틀안에 구조체도 포함되기 때문이다.

이제 실제 클래스로 구성을 해본다.

```c++
#include <iostream>
using namespace std;

class Banking {

public:
	
	char Acct[20];
	char pwd[20];
	char name[20];
	int balance;

	void deposit(int money) {
		balance += money;
	}
	void withdraw(int money) {
		if (balance < money) {
			cout << "잔액부족" << endl;
		}
		balance -= money;
	}

};

int main(void) {
	int money=0;
	Banking a{ "shhoya","P@ssw0rd","shh",100000 };
	cout << "입력(입금) : ";
	cin >> money;
	a.deposit(money);
	cout << "잔액 : " << a.balance << endl;
	cout << "입력(출금) : ";
	cin >> money;
	a.withdraw(money);
	cout << "잔액 : " << a.balance << endl;

	return 0;
}
```

이제부터 정말 중요한 클래스와 객체에 대한 내용이다 집중하자~

## [+] Class & Object

### Concept

위에서 작성한 클래스 안의 변수는 이제 객체(object)라고 부를 수 있다. 객체와 클래스란 무엇인가 한번 보자. 이 책 정말 추천한다;

데이터 추상화(Data Abstraction)란 코끼리를 예로 들어본다.

코끼리의 특징은 ,

1. 코의 길이가 5미터 내외
2. 무게가 약 1톤
3. 발이 4개
4. 코로 사물을 옮기거나 음식 섭취 가능

자 이제 여기서 1,2,3은 데이터 적인 측면, 4는 기능적인 측면의 특징인 것을 볼 수 있다. 즉 데이터추상화란 현실의 사물을 데이터적인 측면과 기능적인 측면을 통해 정의하는 것을 데이터 추상화라고 할 수 있다.

위의 은행기능 코드에서 살펴보면 'acct, pwd, name, balance'는 데이터적인 측면이고, 'depsoit, withdraw' 는 기능적인 측면임을 인지할 수 있다.

이렇게 추상화된 데이터를 가지고 자료형으로 정의하게 되는데 이때 사용하는 것이 클래스(Class)다.

### Class

위의 은행기능 코드를 살펴보면 확연히 알 수 있다. 데이터적인 측면과 기능적인 측면을 통해 데이터 추상화를 진행하였고 이 추상화된 데이터를 가지고 자료형으로 정의하여 클래스화 시킨다. 

### Object

추상화된 데이터를 자료형으로 정의한다. 즉, 클래스화를 시켰다면 그 클래스를 사용해야 의미가 있다.
int, float.. 등과 같이 자료형이 정의되어 있는 이유가 무엇인가. 쓸라고 있는거다. 

그렇다면 사용하기 위해선? 변수선언. 하지만 클래스를 사용하여 정의된 자료형의 변수는 객체(object)라고 부른다.

그리고 클래스를 기반으로 객체를 생성하는 것을 인스턴스화(Instantiation)라고 한다. 객체화 이런 말도 쓴다고 한다.

### Member Access Control

#### Public & Private

클래스 정의 시 ``public:`` 을 적어준 것에 대한 이유에 대해 알아본다.
말 그대로 public은 외부접근까지 허용해주겠다는 의미이고 private는 내부접근만 허용하겠다는 의미이다.

이에 대한 예제 코드이다. 무조건 책과 똑같이 코드를 쓰기보단 조금씩 배운걸 적용해가면서 써보자ㅏ

```c++
#include <iostream>
using namespace std;

const bool open = true;
const bool close = false;

class Door {
	
private: //클래스 내부접근만 가능
	int state;

public: //클래스 외부접근 허용
	
	void Open() {
		state = open;
	}

	void Close() {
		state = close;
	}

	void showState() {
		cout << "State : " << ((state == open) ? "Open" : "Close") << endl; //삼항연산자를 이용
	}
};

int main(void) {
	Door a;
	//a.state = 1; 실제 오류를 확인하면 액세스 거부
	a.Open(); // public으로 인해 접근 가능
	a.showState();
	a.Close();
	a.showState();
	return 0;

}
```

자 해당하는 맴버 접근제어에 대해 알아보자. 아래의 private로 선언되었기 때문에 int형 변수 state는 외부에서 접근이 불가능하다.  하지만 public으로 선언된 Open(), Close(), showState() 함수에 접근이 가능하다. main 함수에서 접근 시 액세스 거부가 되며 값을 바꾸지 못한다. 하지만 public 선언된 Open()이나 Close()함수를 이용하여 값을 변경한다.

```c++
private: //클래스 내부접근만 가능
	int state;
public: //클래스 외부접근 허용
	
	void Open() {
		state = open;
	}

	void Close() {
		state = close;
	}

	void showState() {
		cout << "State : " << ((state == open) ? "Open" : "Close") << endl; //삼항연산자를 이용
	}
```

너무좋다 왜쓰는지는 점점 알게 될 것이다.

자 그런데 여기서 ``Door` 클래스를 보면 한눈에 알아보기가 쉽지 않다. 멤버 함수를 클래스 외부에 정의하는 방법이 있다. 말이 좀 어려워서 그렇지 쉽게 생각하면 클래스에는 함수에 대한 선언을 하고 정의는 클래스 외부에 정의하는 것이다. 이러면 좋은 점은 역시 가독성이 좋아질 것이라 생각된다.

```c++
#include <iostream>
using namespace std;

const bool open = true;
const bool close = false;
class Door {
	//함수 및 변수만 선언함으로써 가독성 향상
private:
	int state;
	
public:
	
	void Open();
	void Close();
	void showState();
};
//함수 외부 정의
void Door::Open() {
	state = open;
}
void Door::Close() {
	state = close;
}

void Door::showState() {
	cout << "현재 상태 : " << ((state == open) ? "OPEN" : "CLSOE") << endl;
}

int main(void) {
	Door a;
	a.Open();
	a.showState();
	a.Close();
	a.showState();
}
```

짠.. 클래스 ``Door::Open`` 을 보면 ``Door`` 클래스에 있는 ``Open``함수에 대한 정의를 하는 것을 볼 수 있다.
이쯤되면 모두가 한번쯤 거쳐가는 계산기를 만들어보자..!

#### Calc

조건 : 무엇을 몇번 연산하였는지 출력, 변수는 private, 함수는 public.

```c++
<CalC.cpp>
#include <iostream>
#include "CalC.h"
using namespace std;

int main(void) {
	CalC a;
	a.Init();
	
	int a1, a2;
	cin >> a1 >> a2;
	
	cout << a1 << " + " << a2 << " = " << a.Add(a1, a2) << endl;
	cout << a1 << " - " << a2 << " = " << a.Sub(a1, a2) << endl;
	cout << a1 << " * " << a2 << " = " << a.Mul(a1, a2) << endl;
	cout << a1 << " / " << a2 << " = " << a.Div(a1, a2) << endl;

	a.showOpcnt();
}
```

```c++
<CalC2.cpp>
#include <iostream>
#include "CalC.h"

void CalC::Init() {
	add = 0, sub = 0, mul = 0, div = 0;
}

double CalC::Add(double a1, double a2) {

	add++;
	return a1 + a2;
}

double CalC::Sub(double a1, double a2) {

	sub++;
	return a1 - a2;
}

double CalC::Mul(double a1, double a2) {
	
	mul++;
	return a1 * a2;
}

double CalC::Div(double a1, double a2) {

	div++;
	return a1 / a2;
}

void CalC::showOpcnt() {
	
	cout << "1. 덧셈 : " << add << endl;
	cout << "2. 뺄셈 : " << sub << endl;
	cout << "3. 곱셈 : " << mul << endl;
	cout << "4. 나눗셈 : " << div << endl;
}
```

```c++
<CalC.h>
#include <iostream>
using namespace std;

class CalC {

private:
	int add, sub, mul, div;
public:

	void Init();
	double Add(double a1, double a2);
	double Sub(double a1, double a2);
	double Mul(double a1, double a2);
	double Div(double a1, double a2);
	void showOpcnt();
};

```



다음은 문자열을 설정하고 출력하는 기능을 하는 클래스를 만들어본다..

```c++
<main.cpp>
#include <iostream>
#include "Printer.h"
using namespace std;

int main(void) {

	Printer p;
	p.setString("Shhoya");
	p.pString();

	p.setString("I Love C++");
	p.pString();
	
}

<Printer.h>
#include <iostream>
using namespace std;

class Printer {
private:
	char str1[20];


public:
	void setString(char *a);
	void pString();
};

void Printer::setString(char *a) {

	strcpy(str1, a);
}

void Printer::pString() {
	
	cout << str1 << endl;

}
```

GoooooooooooooooooooD!



### Characteristic

캡슐화(Encapsulation)과 정보 은닉(Information Hiding)이라는 두 가지 특성을 충족하는 클래스가 좋은 클래스라고 할 수 있다고 한다. 이번엔 캡슐화와 정보 은닉에 대한 것이다.



#### Information Hiding

정보은닉의 요점은 다음과 같다. **객체 외부에서 객체 내에 존재하는 멤버 변수에 직접 접근할 수 있는 권한이 있을 경우 정보 은닉 특성을 충족하지 못한다.**

```c++
#include <iostream>

using namespace std;

class Point {

public:
	int x; // x 의 범위 100
	int y; // y 의 범위 100
};


int main(void) {
	int x, y;
	cout << "X , Y :";
	cin >> x >> y;
	
	Point p;
	p.x = x;
	p.y = y;
	cout << "x : " << x << "\ny : " << y << endl;
	return 0;

}
```

음 책에서 굉장히 인상 깊던 말이 었는데 위의 코드에서 우리가 예상한 내용은 x, y의 범이가 0~100의 입력 값을 받아 뭔가를 출력해야 한다.

그런데 0보다 작거나 100보다 큰 수를 입력했을 경우다. 우리가 봤을 땐 분명 오류고 그로 인해 뒤에 다른 코드들에 분명한 영향을 끼칠 것 이다.

그런데 컴퓨터는 우리와 다르게 오류 없는 코드로 저 코드를 인식한다. 전혀 이상할게 없기 때문이다.

해당하는 정보 은닉 특성을 충족하는 코드는 다음과 같다.

```c++
#include <iostream>

using namespace std;

class Point {

	int x, y;
public:
	int GetX() {
		return x;
	}
	int GetY() {
		return y;
	}

	bool SetX(int); //선언
	bool SetY(int);
};

bool Point::SetX(int _x) {
	
	if (_x < 0 || _x>100) {
		cout << "X 값 입력 오류" << endl;
		return false;
	}
	x = _x;
}

bool Point::SetY(int _y) {

	if (_y < 0 || _y>100) {
		cout << "Y 값 입력 오류" << endl;
		return false;
	}
	y = _y;
}

int main(void) {
	
	int x = 0;
	int y = 0;
	cout << "X, Y 입력 : ";
	cin >> x >> y;
	Point p;
	if (p.SetX(x) != false && p.SetY(y) != false) {
		cout << "X : " << p.GetX() << endl;
		cout << "Y : " << p.GetY() << endl;
		return 0;
	}

	return 0;
}
```

위에서 보면 ``private`` 인지 ``public``인지 ``int x, y``에 대한 선언이 존재하지 않는다. 이런 경우 디폴트로 ``private``로 설정되게 된다. 이 때 만약 ``class Point`` 가 아닌 ``struct Point``라면 디폴트로 ``public``을 사용하게 된다.



#### Encapsulation

캡슐화란 **"관련 있는 데이터와 함수를 하나의 단위로 묶는것"**
관련 있는 데이터와 함수를 **클래스**라는 하나의 캡슐에 정의 하는 것.

```c++
// Encapsulation.h
#include <iostream>
using namespace std;

class Point {
	int x, y;
	
public:
	int GetX() {
		return x;
	}
	int GetY() {
		return y;
	}
	
	bool SetX(int);
	bool SetY(int);

	void ShowData();
};

bool Point::SetX(int _x) {
	
	if (_x < 0 || _x>100) {
		cout << "X 입력 오류" << endl;
		return false;
	}
	x = _x;
}

bool Point::SetY(int _y) {
	if (_y < 0 || _y>100) {
		cout << "Y 입력 오류" << endl;
		return false;
	}
	y = _y;
}

void Point::ShowData() {
	cout << "X : " << GetX() << endl;
	cout << "Y : " << GetY() << endl;
}
```

```c++
//encapsulation.cpp
#include <iostream>
#include "encap.h"
using namespace std;

int main(void) {

	int x = 0, y = 0;
	cout << "X, Y 입력 : ";
	cin >> x >> y;
	Point p;
	if (p.SetX(x) != false && p.SetY(y) != false) {
		p.ShowData();
		return 0;
	}
	return 0;
}
```

간단하게 encapsulation을 적용한 예이다. 내 스타일대로 책과는 약간 다르게 코딩해보았다....
이런게 바로 묘미.

### Constructor & Destructor

우리말로 생성자와 소멸자

#### Constructor

개인정보를 담고 있는 ``Person`` 이라는 이름의 클래스를 정의한다. 기본 기능은 데이터를 저장하고 출력하는 것이다.

```c++
// Person.h
#include <iostream>
using namespace std;

const int SIZE = 100;

class Person {
	
	char name[SIZE];
	char phone[SIZE];
	int age;

public:
	void ShowData();
	void SetData(char*,char*,int);
};

void Person::ShowData() {
	cout << "이름 : " << name << endl;
	cout << "전화 : " << phone << endl;
	cout << "나이 : " << age << endl;
}

void Person::SetData(char *_name, char *_phone, int _age) {

	strcpy(name, _name);
	strcpy(phone, _phone);
	age = _age;
}
```

```c++
//Person.cpp
#include <iostream>
#include "Person.h"
using namespace std;

int main(void) {
	
	//Person p= { "Shhoya","010-1111-2222",31 };
	Person p;
	p.SetData("Shhoya", "010-1111-2222", 31);
	p.ShowData();
	return 0;

}
```

위와 같은 방식은 생성과 동시에 초기화 하는 것과는 매우 먼 코드이다.
또한 중요한 건 프로그래머에게 제약을 가한다. **Person 클래스는 생성 후 초기화를 할 때 SetData 함수를 이용해야 한다**라는 것을 꼭 기억해야한다.

이럴 때 사용하는 것이 생성자이다.!

먼저 객체의 생성 과정에 대해 알아보자. 객체는 생성 될 때 메모리 할당, 생성자 호출 단계를 걸치게 되어 있다. 

생성자는 함수이고 클래스의 이름과 같은 이름을 가진다. 또한 리턴하지도 않고 리턴 타입도 선언되지 않는다.

```c++
#include <iostream>
using namespace std;

const int SIZE = 20;

class A {
	int i, j;
public:
	A()//생성자
	{
		cout << "생성자 호출 " << endl;
		i = 10; j = 20;
	}
	void Show() {
		cout << i << ' ' << j << endl;
	}
};

class B {
	int j, k;
public:
	B(int _j, int _k) {
		j = _j, k = _k;
	}
	void Show() {
		cout << j << ' ' << k << endl;
	}
};

int main(void) {
	A a;
	a.Show();
	B b(111, 222);
	b.Show();
	return 0;
}
```

위의 소스코드는 A 클래스와 B클래스가 각기 다른 방식으로 생성자를 호출하는 것을 볼 수 있다.

이를 토대로 위에서 만들었던 개인정보가 출력되는 소스코드를 코딩해본다.

```c++
//Person.h
#include <iostream>
using namespace std;

const int SIZE = 100;

class Person {
	
	char name[SIZE];
	char phone[SIZE];
	int age;

public:
	Person(char*, char*, int);
	void ShowData();
	
};

Person::Person(char* _name, char* _phone, int _age) {
	strcpy(name, _name);
	strcpy(phone, _phone);
	age = _age;
}

void Person::ShowData() {
	cout << "이름 : " << name << endl;
	cout << "전화 :" << phone << endl;
	cout << "나이 : " << age << endl;
}
```

```c++
//Person.cpp
#include <iostream>
#include "Person.h"
using namespace std;

int main(void) {
	
	Person p("Shhoya", "010-1111-2222", 31);
	p.ShowData();
	return 0;

}
```

Good!!! 재밌다 C++...

자 이번엔 생성자의 특성에 대한 설명이다.

1. 생성자를 정의하지 않으면 기본(Default) 생성자가 삽입된다.
2. 생성자도 함수이므로 오버로딩(Overloading)이 가능하다.
3. 생성자도 함수이므로 Default Argument가 가능하다.

기본 생성자의 경우 아래와 같은 형태를 띈다.

```c++
class Point{
    int x,y;
public:
	Point(){}    
}
```

위에 보면 아무론 인자 값을 받지 않는 void 생성자이고 아무런 기능도 존재하지 않는다. 이처럼 아무런 생성자도 정의하지 않으면 위와 같은 형태의 기본 생성자가 삽입되는 것이다.
단, **하나의 생성자라도 정의되어 있으면 이 기본 생성자는 삽입되지 않는다.**

```c++
//Point.h
#include <iostream>
using namespace std;

class Point {

	int x, y;

public:
	Point(int _x = 0, int _y = 0)  //Default
	{
		x = _x;
		y = _y;
	}

	void ShowData() {
		cout << x << ' ' << y << endl;
	}

};
```

```c++
#include <iostream>
#include "Point.h"
using namespace std;

int main(void) {

	Point p;
	p.ShowData();
	Point p2(10, 20);
	p2.ShowData();
	return 0;
}
```

```
Output >>
0 0
10 20
```

위를 보면 디폴트 매개변수를 이용해 기본 생성자도 사용 가능하게 되어있는 것을 볼 수 있다.
와나 놀라운 C++...

자 이제 생성자의 메모리 동적 할당이다. 객체가 생성되는 과정(메모리 할당, 생성자 호출)를 기억하자

```c++
//Person.h
#include <iostream>
using namespace std;

class Person
{
	char *name;
	char *phone;
	int age;

public:
	Person(char *, char *, int);
	void ShowData();
	void DelMem();
};

Person::Person(char* _name, char* _phone, int _age)
{
	name = new char[strlen(_name) + 1]; //동적할당
	strcpy(name, _name);

	phone = new char[strlen(_phone) + 1]; //동적할당
	strcpy(phone, _phone);
	age = _age;
}

void Person::ShowData() 
{
	cout << "이름 : " << name << endl;
	cout << "나이 : " << age << endl;
	cout << "전화 : " << phone << endl;
}

void Person::DelMem()
{
	delete[]name; //할당 메모리 해제
	delete[]phone; //할당 메모리 해제
}
```

```c++
//Person.cpp
#include <iostream>
#include "Person.h"
using namespace std;

int main(void)
{
	Person p("Shhoya","010-1111-2222",31);
    p.ShowData();
    p.DelMem();
    return 0;
}
```

당연히 컴파일도 잘되고 실행도 잘된다. 그러나 여기서 문제가 무엇이냐!
메모리 해제를 과연 잊지않고 개발자가 항상 잘 해줄 수 있느냐, 잘하더라도 분명 실수가 있을 것이다.



#### Destructor

위에서 말한 문제점을 해결할 수 있는 것이 바로 소멸자(Destructor) 이다.
객체의 소멸 과정을 보면 소멸자를 호출하고 메모리 해제의 과정을 걸치게 된다.

소멸자는 함수이고 클래스의 이름 앞에 `~`가 붙는 형태이다.
리턴 하지않고 리턴 타입 선언도 없으며, 매개변수를 받을 수 없고 이에 따라 오버로딩, 디폴트 매개변수 선언도 불가능하다.

```c++
//Person.h
#include <iostream>
using namespace std;

class Person
{
	char *name;
	char *phone;
	int age;

public:
	Person(char *, char *, int);
	~Person();
	void ShowData();
	//void DelMem();
};

Person::Person(char* _name, char* _phone, int _age)
{
	name = new char[strlen(_name) + 1];
	strcpy(name, _name);

	phone = new char[strlen(_phone) + 1];
	strcpy(phone, _phone);
	age = _age;
}

Person::~Person()
{
	delete[]name;
	delete[]phone;
}

void Person::ShowData() 
{
	cout << "이름 : " << name << endl;
	cout << "나이 : " << age << endl;
	cout << "전화 : " << phone << endl;
}

//void Person::DelMem()
//{
//	delete[]name;
//	delete[]phone;
//}
```

```c++
//Person.cpp
#include <iostream>
#include "Person.h"
using namespace std;

int main(void) 
{
	Person p("Shhoya", "010-1111-2222", 31);
	p.ShowData();
	//p.DelMem();
	return 0;
	
}
```

자 위와 같이 사용할 수 있다. 실제 일일이 해제 함수를 호출할 필요가 없어진 것을 알 수 있다. 소멸자가 정의되어 있기 때문에 객체 소멸 시 메모리 공간이 해제되기 때문이다.

## [+] Example

### Quiz

책에 있는 문제 푼 내용

```c++
//4.1h
#pragma once
#include <iostream>
using namespace std;

class Rectangle
{
	int area, round;

public:

	Rectangle(int, int);
	int GetArea();
	int GetGirth();
};

class Circle
{
	float area, round;

public:

	Circle(int);
	float GetArea();
	float GetGirth();
};

Rectangle::Rectangle(int x, int y)
{
	area = x * y;
	round = (x + y) * 2;

}

int Rectangle::GetArea()
{
	return area;
}

int Rectangle::GetGirth()
{
	return round;
}

Circle::Circle(int half)
{
	area = half * half * 3.14;
	round = 2 * half*3.14;

}

float Circle::GetArea()
{
	return area;
}

float Circle::GetGirth()
{
	return round;
}
```

```c++
//4-2.h
#pragma once
#include <iostream>

using namespace std;

class Time
{
	int h, m, s,s2;
	
public:
	
	Time(int=0, int m=0, int =0);
	void ShowTime();
	void ShowTimeSec();
};

Time::Time(int _h, int _m, int _s)
{
	h = _h;
	m = _m;
	s = _s;
	s2 = _h * 3600 + _m * 60 + _s;
}

void Time::ShowTime()
{
	cout << "[ " << h << "시 " << m << "분 " << s << "초" << " ]" << endl;
}

void Time::ShowTimeSec()
{
	cout << s2 << "초" << endl;
}
```

```c++
//4-3.h
#pragma once
#include <iostream>
using namespace std;

class NameCard
{
	char *name;
	char *phone;
	char *addr;
	char *level;

public:
	NameCard(char*, char*, char*, char*);
	~NameCard();
	void ShowData();
	
};

NameCard::NameCard(char *_name, char *_phone, char *_addr, char *_lev)
{
	name = new char[strlen(_name) + 1];
	strcpy(name, _name);
	phone = new char[strlen(_phone) + 1];
	strcpy(phone, _phone);
	addr = new char[strlen(_addr) + 1];
	strcpy(addr, _addr);
	level = new char[strlen(_lev) + 1];
	strcpy(level, _lev);
}

NameCard::~NameCard()
{
	delete[]name;
	delete[]phone;
	delete[]addr;
	delete[]level;
}

void NameCard::ShowData()
{
	cout << "이름 : " << name << endl;
	cout << "전화 : " << phone << endl;
	cout << "주소 : " << addr << endl;
	cout << "직급 : " << level << endl;

}
```

```c++
//main.cpp
#include <iostream>
#include "4-1.h"
#include "4-2.h"
#include "4-3.h"
using namespace std;

void first();
void second();
void third();

int main(void)
{
	cout << "[+] 첫번째 문제 출력" << endl;
	first();
	cout << endl;
	cout << "[+] 두번째 문제 출력" << endl;
	second();
	cout << endl;
	cout << "[+] 세번째 문제 출력" << endl;
	third();
	return 0;
}

void first()
{
	Rectangle rec(3, 4);
	cout << "면적 : " << rec.GetArea() << endl;
	cout << "둘레 : " << rec.GetGirth() << endl;
	Circle cir(5);
	cout << "면적 : " << cir.GetArea() << endl;
	cout << "둘레 : " << cir.GetGirth() << endl;

}

void second()
{
	Time time1(10);
	Time time2(10, 20);
	Time time3(10, 20, 30);

	time2.ShowTime();
	time2.ShowTimeSec();
}

void third()
{
	NameCard Shhoya("Shhoya", "010-1111-2222", "https://shhoya.github.io","1");
	Shhoya.ShowData();
}
```

맞는 답인지는 모르지만 어쨋든 출력 결과대로 잘 나온다.

끗.







# [+] Reference

1. <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=147521">열혈강의 C++ 프로그래밍</a>

