---
layout: article
title: "[Rev]Encoding(Base64, ROT, UU)"
key: 20180903
tags:
  - CTF
  - WriteUp
  - Reversing
  - Binary
toc: true
mathjax: true
mathjax_autoNumber: true
published : false
---

# [+] Encoding

이번에 도쿄 웨스턴에서 Easy라고 명확히 적혀있는 웜업 문제를 풀지 못하고 매우 자괴감에 빠져있다.
알고나면 이걸 못풀었네! 라고 생각했지만 결론적으로 무지한 탓이다. 각 인코딩을 직접 코딩해보고 어셈으로 까본 뒤 문제풀이도 함께 해본다.

## [+] Base64

### Concept

예를 들어 'A'라는 문자를 Base64 로 인코딩 하면 다음과 같다.

```
'A' == 65(0x41)
Binary 'A' = 0 1 0 0 0 0 0 1
Base64 encoding :
	0 1 0 0 0 0 (6 bit) base64 index 16='Q'
	0 1 0 0 0 0 (6 bit) 
	0 0 0 0 0 0 (padding) padding = '='
	0 0 0 0 0 0 (padding) 
	24 bit
'A' == 'QQ=='
```

6bit 씩 잘라서 만들기 때문에 8bit로 이루어진 문자는 6과 8의 최소공배수인 24가 최소 길이가 되고 24,48,72... 이런식이다.

마찬가지로 'AAA' 라는 문자를 인코딩하면 다음과 같이 된다.

```
'AAA' == 656565
Binary 'AAA' = 01000001 01000001 01000001
Base64 encoding :
	0 1 0 0 0 0 (6 bit) index 16='Q'
	0 1 0 1 0 0 (6 bit) index 20='U'
	0 0 0 1 0 1 (6 bit) index 5='F'
	0 0 0 0 0 1 (6 bit) index 1='B'
'AAA' == 'QUFB'
```

위와 같이 24개의 비트로 딱 맞아 떨어지니 패딩비트인 '='이 붙지 않는다.

### C Language

자신에게 주는 벌로 생각하고 C로 열심히 코딩해보자.
개같네;;;



## [+] ROT

###C Language

## [+] UU

C Language

##[+] DecDecDec (Tokyo Western CTF 2018)

### 